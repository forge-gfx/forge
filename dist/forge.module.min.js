import * as a from "three";
import { Loader as bt, FileLoader as Ht, Quaternion as OI, Vector3 as SA, Color as PI, Matrix4 as uI } from "three";
let hA;
function Kt(g) {
  const A = hA.__externref_table_alloc();
  return hA.__wbindgen_export_2.set(A, g), A;
}
function Zt(g, A) {
  try {
    return g.apply(this, A);
  } catch (I) {
    const B = Kt(I);
    hA.__wbindgen_exn_store(B);
  }
}
function kI(g) {
  const A = typeof g;
  if (A == "number" || A == "boolean" || g == null)
    return `${g}`;
  if (A == "string")
    return `"${g}"`;
  if (A == "symbol") {
    const Q = g.description;
    return Q == null ? "Symbol" : `Symbol(${Q})`;
  }
  if (A == "function") {
    const Q = g.name;
    return typeof Q == "string" && Q.length > 0 ? `Function(${Q})` : "Function";
  }
  if (Array.isArray(g)) {
    const Q = g.length;
    let C = "[";
    Q > 0 && (C += kI(g[0]));
    for (let E = 1; E < Q; E++)
      C += ", " + kI(g[E]);
    return C += "]", C;
  }
  const I = /\[object ([^\]]+)\]/.exec(toString.call(g));
  let B;
  if (I && I.length > 1)
    B = I[1];
  else
    return toString.call(g);
  if (B == "Object")
    try {
      return "Object(" + JSON.stringify(g) + ")";
    } catch {
      return "Object";
    }
  return g instanceof Error ? `${g.name}: ${g.message}
${g.stack}` : B;
}
let FI = 0, Mg = null;
function Tg() {
  return (Mg === null || Mg.byteLength === 0) && (Mg = new Uint8Array(hA.memory.buffer)), Mg;
}
const Xg = typeof TextEncoder < "u" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} }, qt = typeof Xg.encodeInto == "function" ? function(g, A) {
  return Xg.encodeInto(g, A);
} : function(g, A) {
  const I = Xg.encode(g);
  return A.set(I), {
    read: g.length,
    written: I.length
  };
};
function vt(g, A, I) {
  if (I === void 0) {
    const t = Xg.encode(g), i = A(t.length, 1) >>> 0;
    return Tg().subarray(i, i + t.length).set(t), FI = t.length, i;
  }
  let B = g.length, Q = A(B, 1) >>> 0;
  const C = Tg();
  let E = 0;
  for (; E < B; E++) {
    const t = g.charCodeAt(E);
    if (t > 127) break;
    C[Q + E] = t;
  }
  if (E !== B) {
    E !== 0 && (g = g.slice(E)), Q = I(Q, B, B = E + g.length * 3, 1) >>> 0;
    const t = Tg().subarray(Q + E, Q + B), i = qt(g, t);
    E += i.written, Q = I(Q, B, E, 1) >>> 0;
  }
  return FI = E, Q;
}
let gg = null;
function _I() {
  return (gg === null || gg.buffer.detached === !0 || gg.buffer.detached === void 0 && gg.buffer !== hA.memory.buffer) && (gg = new DataView(hA.memory.buffer)), gg;
}
const sB = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && sB.decode();
function $I(g, A) {
  return g = g >>> 0, sB.decode(Tg().subarray(g, g + A));
}
function Wt(g, A, I) {
  return hA.decode_wlg(g, A, I);
}
function Vt(g, A, I, B, Q, C, E, t, i, e, n) {
  return hA.raycast_splats(g, A, I, B, Q, C, E, t, i, e, n);
}
async function Tt(g, A) {
  if (typeof Response == "function" && g instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(g, A);
      } catch (B) {
        if (g.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", B);
        else
          throw B;
      }
    const I = await g.arrayBuffer();
    return await WebAssembly.instantiate(I, A);
  } else {
    const I = await WebAssembly.instantiate(g, A);
    return I instanceof WebAssembly.Instance ? { instance: I, module: g } : I;
  }
}
function Xt() {
  const g = {};
  return g.wbg = {}, g.wbg.__wbg_buffer_09165b52af8c5237 = function(A) {
    return A.buffer;
  }, g.wbg.__wbg_buffer_609cc3eee51ed158 = function(A) {
    return A.buffer;
  }, g.wbg.__wbg_get_b9b93047fe3cf45b = function(A, I) {
    return A[I >>> 0];
  }, g.wbg.__wbg_instanceof_Uint8Array_17156bcf118086a9 = function(A) {
    let I;
    try {
      I = A instanceof Uint8Array;
    } catch {
      I = !1;
    }
    return I;
  }, g.wbg.__wbg_length_3b4f022188ae8db6 = function(A) {
    return A.length;
  }, g.wbg.__wbg_length_6ca527665d89694d = function(A) {
    return A.length;
  }, g.wbg.__wbg_length_8cfd2c6409af88ad = function(A) {
    return A.length;
  }, g.wbg.__wbg_length_a446193dc22c12f8 = function(A) {
    return A.length;
  }, g.wbg.__wbg_length_e2d2a49132c1b256 = function(A) {
    return A.length;
  }, g.wbg.__wbg_new_405e22f390576ce2 = function() {
    return new Object();
  }, g.wbg.__wbg_new_9fee97a409b32b68 = function(A) {
    return new Uint16Array(A);
  }, g.wbg.__wbg_new_a12002a7f91c75be = function(A) {
    return new Uint8Array(A);
  }, g.wbg.__wbg_new_e3b321dcfef89fc7 = function(A) {
    return new Uint32Array(A);
  }, g.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(A, I, B) {
    return new Float32Array(A, I >>> 0, B >>> 0);
  }, g.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(A, I, B) {
    return new Uint32Array(A, I >>> 0, B >>> 0);
  }, g.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(A) {
    return new Float32Array(A >>> 0);
  }, g.wbg.__wbg_newwithlength_bd3de93688d68fbc = function(A) {
    return new Uint32Array(A >>> 0);
  }, g.wbg.__wbg_set_10bad9bee0e9c58b = function(A, I, B) {
    A.set(I, B >>> 0);
  }, g.wbg.__wbg_set_65595bdd868b3009 = function(A, I, B) {
    A.set(I, B >>> 0);
  }, g.wbg.__wbg_set_bb8cecf6a62b9f46 = function() {
    return Zt(function(A, I, B) {
      return Reflect.set(A, I, B);
    }, arguments);
  }, g.wbg.__wbg_set_d23661d19148b229 = function(A, I, B) {
    A.set(I, B >>> 0);
  }, g.wbg.__wbg_set_f4f1f0daa30696fc = function(A, I, B) {
    A.set(I, B >>> 0);
  }, g.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(A, I, B) {
    return A.subarray(I >>> 0, B >>> 0);
  }, g.wbg.__wbg_subarray_769e1e0f81bb259b = function(A, I, B) {
    return A.subarray(I >>> 0, B >>> 0);
  }, g.wbg.__wbindgen_debug_string = function(A, I) {
    const B = kI(I), Q = vt(B, hA.__wbindgen_malloc, hA.__wbindgen_realloc), C = FI;
    _I().setInt32(A + 4 * 1, C, !0), _I().setInt32(A + 4 * 0, Q, !0);
  }, g.wbg.__wbindgen_init_externref_table = function() {
    const A = hA.__wbindgen_export_2, I = A.grow(4);
    A.set(0, void 0), A.set(I + 0, void 0), A.set(I + 1, null), A.set(I + 2, !0), A.set(I + 3, !1);
  }, g.wbg.__wbindgen_memory = function() {
    return hA.memory;
  }, g.wbg.__wbindgen_number_new = function(A) {
    return A;
  }, g.wbg.__wbindgen_string_new = function(A, I) {
    return $I(A, I);
  }, g.wbg.__wbindgen_throw = function(A, I) {
    throw new Error($I(A, I));
  }, g;
}
function zt(g, A) {
  return hA = g.exports, KI.__wbindgen_wasm_module = A, gg = null, Mg = null, hA.__wbindgen_start(), hA;
}
async function KI(g) {
  if (hA !== void 0) return hA;
  typeof g < "u" && (Object.getPrototypeOf(g) === Object.prototype ? { module_or_path: g } = g : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof g > "u" && (g = new URL("data:application/wasm;base64,AGFzbQEAAAABtgItYAJ/fwF/YAJ/fwBgA39/fwF/YAF/AGABfwF/YAN/f38AYAV/f39/fwBgBH9/f38AYAFvAX9gAW8Bb2ADb39/AW9gBX9/f39/AX9gA29vfwBgAABgA39+fgBgA39+fgF/YAd/f39/f39/AX9gBn9/f39/fwBgAX0BfWAEf39/fwF/YAABb2ABfwFvYAZ/f39/f38Bf2AAAX9gC39/f39/f39/f39/AX9gAn9/AW9gAXwBb2ACb38Bb2ADb29vAX9gAn9vAGAHf39/f39/fwBgAn9/AX5gAn9+AX9gAn9+AGALfX19fX19fX1/b38Bb2ABfwF9YAV/f35/fwBgBH9+f38AYAV/f31/fwBgBH99f38AYAV/f3x/fwBgBH98f38AYAR/f29vAX9gA39vbwF/YAJ9fQF9ArcIHgN3YmcVX193YmluZGdlbl9zdHJpbmdfbmV3ABkDd2JnFV9fd2JpbmRnZW5fbnVtYmVyX25ldwAaA3diZxpfX3diZ19nZXRfYjliOTMwNDdmZTNjZjQ1YgAbA3diZx1fX3diZ19sZW5ndGhfZTJkMmE0OTEzMmMxYjI1NgAIA3diZxpfX3diZ19uZXdfNDA1ZTIyZjM5MDU3NmNlMgAUA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3diZ19uZXdfYTEyMDAyYTdmOTFjNzViZQAJA3diZxpfX3diZ19zZXRfNjU1OTViZGQ4NjhiMzAwOQAMA3diZx1fX3diZ19sZW5ndGhfYTQ0NjE5M2RjMjJjMTJmOAAIA3diZxpfX3diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwAMA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAAIA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAoDd2JnGl9fd2JnX25ld19lM2IzMjFkY2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAwDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAgDd2JnMV9fd2JnX25ld3dpdGhi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CwJAIAAoAhAiAkUNAEGousIAQQggAhDVBEUNAEEBDAILIAFBATsBJCABIAQ2AiAgAUEANgIcIAFBAToAGCABQd8ANgIUIAEgBDYCECABQQA2AgwgASAENgIIIAEgAzYCBCABQd8ANgIAIAFBKGogARBQAn8gASgCKEUEQAJAIAEtACUNACABQQE6ACUCQCABLQAkQQFGBEAgASgCICEFIAEoAhwhBAwBCyABKAIgIgUgASgCHCIERg0BCyABKAIEIARqIQMgBSAEawwCC0GwusIAEK4EAAsgASgCHCEEIAEgASgCMDYCHCADIARqIQMgASgCLCAEawshBAJAIAIEQCADIAQgAhDVBA0BCyABQcgAaiABQSBqKQIANwMAIAFBQGsgAUEYaikCADcDACABQThqIAFBEGopAgA3AwAgAUEwaiABQQhqKQIANwMAIAEgASkCADcDKAJAIAEtAE0NACACIQMDQCABKAIsIQUgAUHUAGogAUEoahBQAn8gASgCVEUEQCABLQBNDQMgAUEBOgBNAkAgAS0ATEEBRgRAIAEoAkghBSABKAJEIQQMAQsgASgCSCIFIAEoAkQiBEYNBAsgASgCLCAEaiEGIAUgBGsMAQsgASgCRCEEIAEgASgCXDYCRCAEIAVqIQYgASgCWCAEawshBAJAIANFBEBBACEDDAELQbm2wgBBASADENUEDQMgACgCECICRQRAQQAhAkEAIQMMAQsgAiEDIAYgBCACENUEDQMLIAEtAE1FDQALCyACRQ0BQcC6wgBBAiACENUERQ0BC0EBDAELAkAgACgCECICRQ0AQcK6wgBBAyACENUERQ0AQQEMAQsCQAJAAkAgACgCACIDRQRAQQAhAwwBC0EAIQIDQAJAIAAoAggiBCAAKAIETw0AIAMgBGotAABBxQBHDQAgACAEQQFqNgIIDAILAkAgAkUNACAAKAIQIgNFDQBB9bnCAEECIAMQ1QRFDQBBAQwFCyAAECcNAiACQQFrIQIgACgCACIDDQALQQAhAwsgACgCECIEBEBBAUH1s8IAQQEgBBDVBA0DGiAAKAIAIQMLIANFDQEgACgCCCICIAAoAgRPDQEgAiADai0AAEH1AEcNASAAIAJBAWo2AghBAAwCC0EBDAELAkAgACgCECICRQ0AQcW6wgBBBCACENUERQ0AQQEMAQsgABAnCyAB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AWogBiARGyADa2whAwwDCyABIApBjIHCABCtAgALQZyBwgBBKUHIgcIAEO0CAAtBoP/BAEEXQZyAwgAQ7QIACyAPIAZBAWo2AgAgAkEEaiAJOgAAIAIgAzYCACACQQhqIQIgBCAFQQFqIgVHDQALCyAAQYWAgIB4NgIADwsgBUEBaiEFIAMoAgAhCSADQQRqIQMgCUEATA0ACyAFQQFrIQxBACEDA0ACQCACIAZJBEAgA0EBaiEDIAsgAkEDdGogDDoABQNAIAIgDWogDnEiAiAETw0ACwwBCyACIAZB2IHCABCtAgALIAMgCUcNAAsMAAsAC9IHAQN/AkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAgAOCgAHBwECAwQHBwUHCwJAAkACQAJAAkACQCAALQAEDgcADAEMAgMEDAsgAC0ACEEDRw0LIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQQgASADIAIoAggQpwQMBAsgAC0ACEEDRw0KIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQMgASADIAIoAggQpwQMAwsgAC0ACEEDRw0JIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQIgASADIAIoAggQpwQMAgsgAC0ACEEDRw0IIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQEgASADIAIoAggQpwQMAQsgAC0ACEEDRw0HIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQAgASADIAIoAggQpwQLIABBDEEEEKcEDwsCQAJAIAAtAAQOAgcBAAsgACgCCCIBQfv///8HaiICQQ1NIAJBAkdxDQYgAUGEgICAeEoNBSABQYOAgIB4Rw0GDAULIAAoAggiAUGEgICAeEogAUGDgICAeEZyDQQMBQsgAC0ABEEDRw0EDAULAkACQEEDIAAoAgQiAUEHayICIAJBA08bQQJrDgIBAAULAkACQAJAIAEOBgAHAQcHAgcLIAAtAAhBA0cNBgwICyAAKAIIIgFB7f///wdqIgJBCk0gAkEDR3ENBSABRSABQfv///8H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wQA2AgggAkIBNwIUIAIgAkEEaq1CgICAgJA4hDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQRQwICyACIAA2AgQgAkEBNgIMIAJB8KfBADYCCCACQgE3AhQgAiACQQRqrUKAgICAoDeENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahBFDAcLIAIgAEEEajYCBCACQQE2AgwgAkHwp8EANgIIIAJCATcCFCACIAJBBGqtQoCAgICgOIQ3AyAgAiACQSBqNgIQIAEoAhwgASgCICACQQhqEEUMBgsgASgCHEHFusEAQTkgASgCICgCDBECAAwFCyACIABBBGo2AgQgAkECNgIMIAJBqLvBADYCCCACQgE3AhQgAiACQQRqrUKAgICA8DWENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahBFDAQLIAIgAEEEajYCACACIABBCGo2AgQgAkEDNgIMIAJB6LvBADYCCCACQgI3AhQgAkKAgICA8DUiBCACrYQ3AyggAiAEIAJBBGqthDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQRQwDCyACIABBBGo2AgQgAkECNgIMIAJB8LzBADYCCCACQgE3AhQgAiACQQRqrUKAgICAsDiENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahBFDAILIAIgAEEEajYCACACIABBCGo2AgQgAkECNgIMIAJBsL3BADYCCCACQgI3AhQgAkKAgICAwDgiBCACQQRqrYQ3AyggAiAEIAKthDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQRQwBCyACIABBBGo2AgAgAiAAQQhqNgIEIAJBAjYCDCACQfS9wQA2AgggAkICNwIUIAJCgICAgPA1IgQgAkEEaq2ENwMoIAIgBCACrYQ3AyAgAiACQSBqNgIQIAEoAhwgASgCICACQQhqEEULIAJBMGokAAuXBgEIfyMAQTBrIgEkAAJAAn8CQAJAAkAgACgCACIFBEAgACgCCCIEIAQgACgCBCIHIAQgB0sbayEIIAUhAwNAIAIgCGpFDQMgACACIARqQQFqNgIIIAJBAWohAiADIARqIANBAWohAy0AACIGQTBrQf8BcUEKSSAGQeEAa0H/AXFBBklyDQALIAZB3wBHDQIgAiAEakEBayEGAkAgBARA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IABBABAgDAELIAAQJwsgBEEQaiQAC5QDAQR/AkAgAkEQSQRAIAAhAwwBCwJAIABBACAAa0EDcSIFaiIEIABNDQAgACEDIAUEQCAFIQYDQCADIAE6AAAgA0EBaiEDIAZBAWsiBg0ACwsgBUEBa0EHSQ0AA0AgAyABOgAAIANBB2ogAToAACADQQZqIAE6AAAgA0EFaiABOgAAIANBBGogAToAACADQQNqIAE6AAAgA0ECaiABOgAAIANBAWogAToAACADQQhqIgMgBEcNAAsLIAQgAiAFayICQXxxaiIDIARLBEAgAUH/AXFBgYKECGwhBQNAIAQgBTYCACAEQQRqIgQgA0kNAAsLIAJBA3EhAgsCQCADIAIgA2oiBU8NACACQQdxIgQEQANAIAMgAToAACADQQFqIQMgBEEBayIEDQALCyACQQFrQQdJDQADQCADIAE6AAAgA0EHaiABOgAAIANBBmogAToAACADQQVqIAE6AAAgA0EEaiABOgAAIANBA2ogAToAACADQQJqIAE6AAAgA0EBaiABOgAAIANBCGoiAyAFRw0ACwsgAAudAwIGfwF+QTggAUH/AXEiASABQThPGyECAkAgACgCECIEIAAtABQiAWoiA0EASgRAIAIgA0sNAQJAIARBAEwgASACT3INAANAIARBAWsiBUEDdiEGQcAAIAFBB2oiB0F4cWshAwJAIAVBP00EQCAAIAYgAxCIASAAKAIQIQQgAC0AFCEBDAELAkAgACgCBCIFIAYgB0H4AXFBA3ZqQQdrIgZPBEAgBSAGayIFQQdLDQFBCCAFQcTewQAQqwQACyAGIAVB1N7BABCqBAALIAAgASADaiIBOgAUIAAgBCADQf8BcWsiBDYCECAAIAAoAgAgBmopAAA3AwgLIAFB/wFxIAJPDQEgBEEASg0ACwsgACABIAJrIgE6ABRCfyACrYZCf4UgACkDCCABQT9xrYiDDwsgACAEIAJrNgIQQgAPCyACIANrIQICQCADQf8BcSABSwRAIAAgAxBbIQggACgCECEEDAELIAAgASADayIBOgAUQn8gA62GQn+FIAApAwggAUE/ca2IgyEICyAAIAQgAms2AhAgCCACQT9xrYYLnAMBBX8CQEERQQAgAEGvsARPGyIBIAFBCHIiASAAQQt0IgIgAUECdEH82sIAaigCAEELdEkbIgEg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AEEEaiACKAIEIAIoAggQPUHcoMIAIAAoAgggACgCBCICGyEDQQkgACgCDCACGwshAiADIAIgARDaASAAQRBqJAALZgAjAEEwayIAJABBhOXCAC0AAARAIABBAjYCDCAAQYyhwgA2AgggAEIBNwIUIAAgATYCLCAAIABBLGqtQoCAgIAQhDcDICAAIABBIGo2AhAgAEEIakG0ocIAEKQDAAsgAEEwaiQAC2EBAX8jAEEwayICJAAgAiAANgIMIAJBAjYCFCACQZymwQA2AhAgAkIBNwIcIAIgAkEMaq1CgICAgOA0hDcDKCACIAJBKGo2AhggASgCHCABKAIgIAJBEGoQRSACQTBqJAALYQEBfyMAQTBrIgIkACACIAA2AgwgAkECNgIUIAJB5K7BADYCECACQgE3AhwgAiACQQxqrUKAgICA4DSENwMoIAIgAkEoajYCGCABKAIcIAEoAiAgAkEQahBFIAJBMGokAAthAQF/IwBBMGsiAiQAIAIgADYCDCACQQE2AhQgAkHwp8EANgIQIAJCATcCHCACIAJBDGqtQoCAgICQOIQ3AyggAiACQShqNgIYIAEoAhwgASgCICACQRBqEEUgAkEwaiQAC18BAn8CQCAAKAIAIgFB7f///wdqIgJBCk0gAkEDR3ENACABRSABQfv///8HaiICQQ1NIAJBAkdxIAFBg4CAgHhHIAFBhICAgHhMcXJyDQAgACgCBCABQQJ0QQQQpwQLC1wBA38gAC0AACIBQQNLIAFBA0dyRQRAIAAoAgQiACgCACEBIABBBGooAgAiAygCACICBEAgASACEQMACyADKAIEIgIEQCABIAIgAygCCBCnBAsgAEEMQQQQpwQLC2sBAn9BqJbAACECAkACQAJAAkAgAS0AACIDQQNrQQAgA0EEa0H/AXFBA0kbQQFrDgMAAQIDC0EAIQEMAgsgAUEBaiEBQdStwAAhAgwBCyABQQRqIQFBkK7AACECCyAAIAI2AgQgACABNgIAC2gBA38CQAJAAkACQEEDIAEoAgBB7f///wdqIgQgBEELTxtBAmsOAwABAgMLIAFBBGohAkGcm8AAIQMMAgtB2LPAACEDIAEhAgwBCyABQQRqIQJBjLXAACEDCyAAIAM2AgQgACACNgIAC2sBAn9B1LfAACECAkACQAJAAkAgAS0AACIDQQNrQQAgA0EEa0H/AXFBA0kbQQFrDgMAAQIDC0EAIQEMAgsgAUEBaiEBQejQwAAhAgwBCyABQQRqIQFBpNHAACECCyAAIAI2AgQgACABNgIAC2gBA38CQAJAAkACQEEDIAEoAgBB7f///wdqIgQgBEELTxtBAmsOAwABAgMLIAFBBGohAkGwvsAAIQMMAgtB7NbAACEDIAEhAgwBCyABQQRqIQJBoNjAACEDCyAAIAM2AgQgACACNgIAC2sBAn9B5OzAACECAkACQAJAAkAgAS0AACIDQQNrQQAgA0EEa0H/AXFBA0kbQQFrDgMAAQIDC0EAIQEMAgsgAUEBaiEBQdDzwAAhAgwBCyABQQRqIQFBjPTAACECCyAAIAI2AgQgACABNgIAC2gBA38CQAJAAkACQEEDIAEoAgBB7f///wdqIgQgBEELTxtBAmsOAwABAgMLIAFBBGohAkGA4cAAIQMMAgtB1PnAACEDIAEhAgwBCyABQQRqIQJBiPvAACEDCyAAIAM2AgQgACACNgIAC2sBAn9B6JLBACECAkACQAJAAkAgAS0AACIDQQNrQQAgA0EEa0H/AXFBA0kbQQFrDgMAAQIDC0EAIQEMAgsgAUEBaiEBQeSZwQAhAgwBCyABQQRqIQFBoJrBACECCyAAIAI2AgQgACABNgIAC2gBA38CQAJAAkACQEEDIAEoAgBB7f///wdqIgQgBEELTxtBAmsOAwABAgMLIAFBBGohAkHEicEAIQMMAgtB6J/BACEDIAEhAgwBCyABQQRqIQJBnKHBACEDCyAAIAM2AgQgACACNgIAC1gBAn8jAEEQayICJAAgAS0AAEEDRwR/QQAFIAJBCGogASgCBCIBKAIAIAEoAgQoAiQRAQAgAigCDCEDIAIoAggLIQEgACADNgIEIAAgATYCACACQRBqJAALWAECfyMAQRBrIgIkACABLQAAQQNHBH9BAAUgAkEIaiABKAIEIgEoAgAgASgCBCgCGBEBACACKAIMIQMgAigCCAshASAAIAM2AgQgACABNgIAIAJBEGokAAueGQITfwF+IwBBIGsiDiQAAn8gACgCACIAKAIABEACfyABIQsjAEEwayIIJAAgACgCCCERIAAoAgQhCSAAKAIAIQ0CQAJAAkACQANAAkAgESAQIgpGBEBBACEADAELIAlFDQUgCiARRyESIApBAWohECAJQQFrIQUgDSIBLQAAIQZBACECAkACQANAAkAgBsBBAEgEQCAGQR9xIQAgASACaiIDQQFqLQAAQT9xIQQgBkH/AXEiDUHfAU0EQCAAQQZ0IARyIQMMAgsgA0ECai0AAEE/cSAEQQZ0ciEEIA1B8AFJBEAgBCAAQQx0ciEDDAILIABBEnRBgIDwAHEgA0EDai0AAEE/cSAEQQZ0cnIiA0GAgMQARw0BDAoLIAZB/wFxIQMLAkACQCADQTBrQQlNBEAgAiAFRg0LIAEgAmoiAEEBaiwAACIGQb9/Sg0BIAAgCSACayIAQQEgAEG8ssIAEOwDAAsgAg0BQQAhBAwDCyACQQFqIQIMAQsLAkAgASACaiIHLAAAQb9/SgRAIAEtAAAhAAJAIAJBAUYEQEEBIQQgASEDIABBK2sOAwQBBAELIABBK0YEQCACQQFrIQQgAUEBaiEDIAJBCkkNAQwDCyABIQMgAiEEIAJBCU8NAgtBACEFA0AgAy0AAEEwayIAQQlLBEBBASEEDAQLIANBAWohAyAAIAVBCmxqIQUgBEEBayIEDQALDAMLIAEgCUEAIAJBzLLCABDsAwALQQAhBSAEIQADQCAARQ0CIAMtAABBMGsiDUEJSwRAQQEhBAwCC0ECIQQgBa1CCn4iFUIgiKcNASADQQFqIQMgAEEBayEAIA0gFaciDGoiBSAMTw0ACwsgCCAEOgAUQYCwwgBBKyAIQRRqQbC0wgBBwLTCABCgAgALIAkgBWshDAJAAkACQAJAIAVFDQAgCSACayIAIAVNBEAgAiAMRg0BDAkLIAEgBWogAmoiAywAAEG/f0wNCCADLAAAQb9/TA0BCyABIAVqIAJqIQ0gECARRw0CIAVFIAsoAhRBBHFFIAZB/wFxQegAR3JyDQIgBUEBRwRAIAdBAWosAABBv39MDQILIAdBAWohBgNAQQAhACAGIA1GDQQCfyAGLAAAIgNBAE4EQCADQf8BcSEDIAZBAWoMAQsgBi0AAUE/cSEJIANBH3EhBCADQV9NBEAgBEEGdCAJciEDIAZBAmoMAQsgBi0AAkE/cSAJQQZ0ciEJIANBcEkEQCAJIARBDHRyIQMgBkEDagwBCyAEQRJ0QYCA8ABxIAYtAANBP3EgCUEGdHJyIgNBgIDEAEYNBSAGQQRqCyEGIANBwQBrQV5xQQpqIANBMGsgA0E5SxtBEEkNAAsMAgsgByAAQQAgBUHsssIAEOwDAAsgByAFQQEgBUGcssIAEOwDAAsCQCAKRQ0AIAtB/LLCAEECEOUDRQ0AIBIhAAwBCyABIAJqIQoCQAJAAkAgBUECSQ0AIAovAABB38gARw0AIAdBAWoiCiwAAEG/f0wNASAFQQFrIQULIAwgAmshCQNAIAohAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAFIgRFDQACQCABLQAAQSRrDgsCAQEBAQEBAQEBAAELIARBAUYNBSABLAABQb9/Sg0EIAEgBEEBIARB/LPCABDsAwALIAEgBGohCkEAIQIgASEGA0AgAiEAIAYiAiAKRg0RAn8gAiwAACIDQQBOBEAgA0H/AXEhBSACQQFqDAELIAItAAFBP3EhBSADQR9xIQYgA0FfTQRAIAZBBnQgBXIhBSACQQJqDAELIAItAAJBP3EgBUEGdHIhBSADQXBJBEAgBSAGQQx0ciEFIAJBA2oMAQsgBkESdEGAgPAAcSACLQADQT9xIAVBBnRyciEFIAJBBGoLIgYgACACa2ohAiAFQSRrDgsCAAAAAAAAAAAAAgALAAsgBEEBRg0BIAEsAAFBv39KDQEgASAEQQEgBEGws8IAEOwDAAsCQAJAAkAgAARAAkAgACAESSICRQRAIAAgBEcNASALIAEgABDlA0UNBEEBIQAMFQsgACABaiwAAEG/f0oNAgsgASAEQQAgAEGQs8IAEOwDAAsgCyABIAAQ5QNFDQJBASEADBILIAsgASAAEOUDRQ0AQQEhAAwRCyACRQRAIAAgBEYNAQwUCyAAIAFqLAAAQUBIDRMLIAAgAWohCiAEIABrIQUMDAsgCCAEQQFrIgA2AiQgCEEANgIgIAggADYCHCAIQSQ2AhQgCEEkNgIoIAhBAToALCAIIAFBAWoiADYCGCAIQQhqIAhBFGoQUCAIKAIIQQFHDQ0CQCAIKAIMIgdBf0cEQCAHQQFqIQIgBEEBRw0BDAULIwBBIGsiACQAIABBADYCGCAAQQE2AgwgAEG8x8IANgIIIABCBDcCECAAQQhqQcCzwgAQpAMACyAALAAAQb9/Sg0DDAQLAkACfyABLAABIgBBAE4EQCAAQf8BcQwBCyABLQACQT9xIgMgAEEfcSICQQZ0ciAAQV9NDQAaIAEtAANBP3EgA0EGdHIiAyACQQx0ciAAQXBJDQAaIAJBEnRBgIDwAHEgAS0ABEE/cSADQQZ0cnILQS5HBEBBASEAIAtBnLTCAEEBEOUDDQ8gASwAAUFASA0BDAMLIAtB/LLCAEECEOUDBEBBASEADA8LAkAgBEEDTwRAIAEsAAJBQEgNAQsgAUECaiEKIARBAmshBQwMCyABIARBAiAEQYy0wgAQ7AMACyABIARBASAEQaC0wgAQ7AMAC0EBIQAgC0GctMIAQQEQ5QMNDAsgAUEBaiEKIARBAWshBQwICwJAIAIgBE8EQCACIARHDQIgB0ECaiICDQEMBgsgASACaiwAAEFASA0BIAdBAmohAgsgAiAESQ0BIAIgBEYNAgwDCyABIARBASACQcCzwgAQ7AMACyABIAJqLAAAQUBIDQELIAEgAmohCiAEIAJrIQUCQAJAAkACQCAHDgMKAQAFCyAALwAAQdOgAUYEQEH7s8IAIQIMAwsgAC8AAEHCoAFGBEBB+rPCACECDAMLIAAvAABB0owBRgRAQfmzwgAhAgwDCyAALwAAQcyoAUYEQEH4s8IAIQIMAwsgAC8AAEHHqAFGBEBB97PCACECDAMLIAAvAABBzKABRgRAQfazwgAhAgwDCyAALwAAQdKgAUcNAUH1s8IAIQIMAgsgAC0AAEHDAEYEQEH0s8IAIQIMAgsgAC0AAEH1AEYNBQwICyAALQAAQfUARw0HDAMLQQEhACALIAJBARDlA0UNBAwHCyABIAQgAiAEQdCzwgAQ7AMACyABLQABQfUARw0EIAdBAk8NAEEBIQcMBwsgASwAAkG/f0wNBgsgACAHaiEUIAdBAWshACABQQJqIgYhAgJAA0BBASETIAIgFEYNAQJ/IAIsAAAiA0EATgRAIANB/wFxIQMgAkEBagwBCyACLQABQT9xIQ8gA0EfcSEMIANBX00EQCAMQQZ0IA9yIQMgAkECagwBCyACLQACQT9xIA9BBnRyIQ8gA0FwSQRAIA8gDEEMdHIhAyACQQNqDAELIAxBEnRBgIDwAHEgAi0AA0E/cSAPQQZ0cnIiA0GAgMQARg0CIAJBBGoLIQIgA0Ewa0EKSSADQeEAa0EGSXINAAtBACETCwJAAkACQAJAIAdBAWsOAgYAAQtBASEAIAYtAABBK2sOAwUBBQELAkAgBi0AAEErRgRAIAdBAmshACABQQNqIQYgB0ELTw0BDAILIAdBCkkNAQtBACEDA0AgBi0AACICQcEAa0FfcUEKaiACQTBrIAJBOUsbIgJBD0sgA0H/////AEtyDQUgBkEBaiEGIAIgA0EEdHIhAyAAQQFrIgANAAsMAQtBACEDA0AgBi0AACICQcEAa0FfcUEKaiACQTBrIAJBOUsbIgJBD0sNBCAGQQFqIQYgAiADQQR0ciEDIABBAWsiAA0ACwsgE0VBgIDEACADIANBgLADc0GAgMQAa0GAkLx/SRsiAEGAgMQARnINAiAIIAA2AgQgAEEgSSAAQf8Aa0EhSXINAiAIQQRqIAsQjQFFDQALQQEhAAwCCyAHIAVBASAFQYCzwgAQ7AMACyASIQAgCyABIAQQ5QNFDQELCyAIQTBqJAAgAAwECyAAIAdBASAHQeSzwgAQ7AMACyABIAQgACAEQaCzwgAQ7AMACyAHIAAgBSAAQdyywgAQ7AMAC0GsssIAEK4EAAsMAQsgDkEANgIcIA4gATYCGCAOQgA3AhAgDiAAKQIENwIIIA5BCGpBARAfCyAOQSBqJAALXAEBfyMAQTBrIgMkACADIAE2AgwgAyAANgIIIANBATYCFCADQYzBwgA2AhAgA0IBNwIcIAMgA0EIaq1CgICAgJDEAIQ3AyggAyADQShqNgIYIANBEGogAhCkAwALZQEDfwJAAkACQAJAQQIgASgCAEH7////B2oiBCAEQQ5PGw4DAAECAwsgAUEEaiECQZybwAAhAwwCCyABQQRqIQJBpKfAACEDDAELQeCnwAAhAyABIQILIAAgAzYCBCAAIAI2AgALZQEDfwJAAkACQAJAQQIgASgCAEH7////B2oiBCAEQQxPGw4DAAECAwsgAUEEaiECQZybwAAhAwwCCyABQQRqIQJBpKfAACEDDAELQeCnwAAhAyABIQILIAAgAzYCBCAAIAI2AgALZQEDfwJAAkACQAJAQQIgASgCAEH7////B2oiBCAEQQ5PGw4DAAECAwsgAUEEaiECQbC+wAAhAwwCCyABQQRqIQJBuMrAACEDDAELQfTKwAAhAyABIQILIAAgAzYCBCAAIAI2AgALZQEDfwJAAkACQAJAQQIgASgCAEH7////B2oiBCAEQQxPGw4DAAECAwsgAUEEaiECQbC+wAAhAwwCCyABQQRqIQJBuMrAACEDDAELQfTKwAAhAyABIQILIAAgAzYCBCAAIAI2AgALZQEDfwJAAkACQAJAQQIgASgCAEH7////B2oiBCAEQQ5PGw4DAAECAwsgAUEEaiECQYDhwAAhAwwCCyABQQRqIQJBoO3AACEDDAELQdztwAAhAyABIQILIAAgAzYCBCAAIAI2AgALZQEDfwJAAkACQAJAQQIgASgCAEH7////B2oiBCAEQQxPGw4DAAECAwsgAUEEaiECQYDhwAAhAwwCCyABQQRqIQJBoO3AACEDDAELQdztwAAhAyABIQILIAAgAzYCBCAAIAI2AgALZQEDfwJAAkACQAJAQQIgASgCAEH7////B2oiBCAEQQ5PGw4DAAECAwsgAUEEaiECQcSJwQAhAwwCCyABQQRqIQJBpJPBACEDDAELQeCTwQAhAyABIQILIAAgAzYCBCAAIAI2AgALZQEDfwJAAkACQAJAQQIgASgCAEH7////B2oiBCAEQQxPGw4DAAECAwsgAUEEaiECQcSJwQAhAwwCCyABQQRqIQJBpJPBACEDDAELQeCTwQAhAyABIQILIAAgAzYCBCAAIAI2AgALnAECA38BbyMAQSBrIgMkACADIAAoAgAQ3AQiBDYCACADIAI2AgQgAiAERwRAIANBADYCCCADIANBBGogA0EIahCMAwALEO0DIgQQ3AMiBSUBEA0hBhBpIgIgBiYBIAVBhAFPBEAgBRDGAQsgAiAAKAIAIAFBAnYQpgQgAkGEAU8EQCACEMYBCyAEQYQBTwRAIAQQxgELIANBIGokAAtTAQN/IAAtAABBA0YEQCAAKAIEIgAoAgAhAiAAQQRqKAIAIgMoAgAiAQRAIAIgAREDAAsgAygCBCIBBEAgAiABIAMoAggQpwQLIABBDEEEEKcECwttAQF/IAEoAhwhAiABKAIgKAIMIQECQAJAAkACQCAAKAIALQAAQQFrDgMBAgMACyACQcD3wQBBAyABEQIADwsgAkHD98EAQQMgARECAA8LIAJBxvfBAEEKIAERAgAPCyACQdD3wQBBCSABEQIAC1IBAX8jAEEQayICJAACfyAAKAIAIgAtAABFBEAgAUHq3cAAQQQQ5QMMAQsgAiAAQQFqNgIMIAFB7t3AAEEEIAJBDGpB+NrAABB/CyACQRBqJAALUQEBfyMAQRBrIgIkAAJ/IAAoAgAiAC0AAEECRwRAIAIgADYCDCABQeyHwQBBDCACQQxqQdyHwQAQfwwBCyABQZ6JwQBBFBDlAwsgAkEQaiQAC1EBAX8jAEEQayICJAACfyAAKAIAIgAtAABBAkcEQCACIAA2AgwgAUHo1MEAQQwgAkEMakHY1MEAEH8MAQsgAUHE2sEAQRQQ5QMLIAJBEGokAAtQAQF/IwBBMGsiACQAIABBATYCDCAAQdCWwgA2AgggAEIBNwIUIAAgAEEvaq1CgICAgPA9hDcDICAAIABBIGo2AhAgAEEIakH8h8AAEKQDAAtRAQF/IwBBMGsiACQAIABBATYCDCAAQbTBwgA2AgggAEIBNwIUIAAgAEEvaq1CgICAgPDDAIQ3AyAgACAAQSBqNgIQIABBCGpBjIjAABCkAwALQwEDfwJAIAJFDQADQCAALQAAIgQgAS0AACIFRgRAIABBAWohACABQQFqIQEgAkEBayICDQEMAgsLIAQgBWshAwsgAwtMAQF/IwBBEGsiAiQAAn8gAC0AAEECRwRAIAIgADYCDCABQcSZwABBDCACQQxqQbSZwAAQfwwBCyABQfaawABBFBDlAwsgAkEQaiQAC1ABA38CQAJAAkBBAyABKAIAQQdrIgQgBEEDTxtBAmsOAgABAgsgAUEEaiECQaiWwAAhAwwBC0HQtMAAIQMgASECCyAAIAM2AgQgACACNgIAC0wBAX8jAEEQayICJAACfyAALQAAQQJHBEAgAiAANgIMIAFB2LzAAEEMIAJBDGpByLzAABB/DAELIAFBir7AAEEUEOUDCyACQRBqJAALUAEDfwJAAkACQEEDIAEoAgBBB2siBCAEQQNPG0ECaw4CAAECCyABQQRqIQJB1LfAACEDDAELQeTXwAAhAyABIQILIAAgAzYCBCAAIAI2AgALTAEBfyMAQRBrIgIkAAJ/IAAtAABBAkcEQCACIAA2AgwgAUGo38AAQQwgAkEMakGY38AAEH8MAQsgAUHa4MAAQRQQ5QMLIAJBEGokAAtQAQN/AkACQAJAQQMgASgCAEEHayIEIARBA08bQQJrDgIAAQILIAFBBGohAkHk7MAAIQMMAQtBzPrAACEDIAEhAgsgACADNgIEIAAgAjYCAAtQAQN/AkACQAJAQQMgASgCAEEHayIEIARBA08bQQJrDgIAAQILIAFBBGohAkHoksEAIQMMAQtB4KDBACEDIAEhAgsgACADNgIEIAAgAjYCAAtMAQF/IwBBEGsiAiQAAn8gAC0AAEECRwRAIAIgADYCDCABQeyHwQBBDCACQQxqQdyHwQAQfwwBCyABQZ6JwQBBFBDlAwsgAkEQaiQAC14AIAEoAgAlASACKAIAJQEgAygCACUBEBkhAUEBIQMCQEGI5cIAKAIAQQFGBEAgAEGM5cIAKAIANgIEDAELIAAgAUEARzoAAUEAIQMLIAAgAzoAAEGI5cIAQgA3AgALSAECfyAAKAIAIgFB+////wdqIgJBDU0gAkECR3EgAUGDgICAeEcgAUGEgICAeExxciABRXJFBEAgACgCBCABQQJ0QQQQpwQLC0gBAn8gACgCACIBQfv///8HaiICQQtNIAJBAkdxIAFBg4CAgHhHIAFBhICAgHhMcXIgAUVyRQRAIAAoAgQgAUECdEEEEKcECwtCAQF/IAIgACgCACAAKAIIIgNrSwRAIAAgAyACEJMBIAAoAgghAwsgACgCBCADaiABIAIQOxogACACIANqNgIIQQALQgEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhCgASAAKAIIIQMLIAAoAgQgA2ogASACEDsaIAAgAiADajYCCEEAC08BAn8gACgCBCECIAAoAgAhAwJAIAAoAggiAC0AAEUNACADQfjDwgBBBCACKAIMEQIARQ0AQQEPCyAAIAFBCkY6AAAgAyABIAIoAhARAAALTgEBfyMAQRBrIgIkACACIAAoAgAiADYCDCABQeGhwQBBDkHvocEAQQ0gAEEEakG4h8EAQdSHwQBBAyACQQxqQfSGwQAQwwEgAkEQaiQAC04BAX8jAEEQayICJAAgAiAAKAIAIgBBBGo2AgwgAUGIhsEAQQlBkYbBAEELIABB6IXBAEGchsEAQQkgAkEMakH4hcEAEMMBIAJBEGokAAtOAQF/IwBBEGsiAiQAIAIgACgCACIANgIMIAFBptnBAEEOQcTZwQBBDSAAQQRqQbTZwQBBi87BAEEDIAJBDGpBuM3BABDDASACQRBqJAALSAEBfyMAQRBrIgIkACACQQhqIAEQ8wIgAiACKAIIIAIoAgwoAhgRAQAgAigCBCEBIAAgAigCADYCACAAIAE2AgQgAkEQaiQAC08BAn9BheXCAC0AABogASgCBCECIAEoAgAhA0EIQQQQ9QMiAUUEQEEEQQgQ0wQACyABIAI2AgQgASADNgIAIABB2KHCADYCBCAAIAE2AgALQgEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhC5ASAAKAIIIQMLIAAoAgQgA2ogASACEDsaIAAgAiADajYCCEEAC0kBAX8jAEEQayICJAAgAiAANgIMIAFB0bXAAEEOQd+1wABBDSAAQQRqQZCZwABBrJnAAEEDIAJBDGpBzJjAABDDASACQRBqJAALSQEBfyMAQRBrIgIkACACIAA2AgwgAUHl2MAAQQ5B89jAAEENIABBBGpBpLzAAEHAvMAAQQMgAkEMakHgu8AAEMMBIAJBEGokAAtJAQF/IwBBEGsiAiQAIAIgADYCDCABQc37wABBDkHb+8AAQQ0gAEEEakH03sAAQZDfwABBAyACQQxqQfjcwAAQwwEgAkEQaiQAC0kBAX8jAEEQayICJAAgAiAANgIMIAFB4aHBAEEOQe+hwQBBDSAAQQRqQbiHwQBB1IfBAEEDIAJBDGpB9IbBABDDASACQRBqJAALQgEBfyMAQSBrIgMkACADQQA2AhAgA0EBNgIEIANCBDcCCCADIAE2AhwgAyAANgIYIAMgA0EYajYCACADIAIQpAMACz0BAn8gACAAKAIEIgMgAms2AgQgACAAKAIAIAIgA0tyIgQ2AgBBASEDIAQEfyADBSAAKAIIIAEgAhDlAwsLRgECfwJAAkACQCABLQAAQQFrDgIAAQILIAFBBGohAkHgp8AAIQMMAQsgAUEEaiECQdizwAAhAwsgACADNgIEIAAgAjYCAAtGAQJ/AkACQAJAIAEtAABBAWsOAgABAgsgAUEEaiECQfTKwAAhAwwBCyABQQRqIQJB7NbAACEDCyAAIAM2AgQgACACNgIAC0YBAn8CQAJAAkAgAS0AAEEBaw4CAAECCyABQQRqIQJB3O3AACEDDAELIAFBBGohAkHU+cAAIQMLIAAgAzYCBCAAIAI2AgALRgECfwJAAkACQCABLQAAQQFrDgIAAQILIAFBBGohAkHgk8EAIQMMAQsgAUEEaiECQeifwQAhAwsgACADNgIEIAAgAjYCAAs+AQF/IwBBEGsiAiQAIAJBCGogASABKAIAKAIEEQEAIAIoAgwhASAAIAIoAgg2AgAgACABNgIEIAJBEGokAAumAQICfwF+IAAoAgAhACABKAIUIgJBEHFFBEAgAkEgcUUEQCAAIAEQrwQPCyMAQYABayICJAAgACkDACEEQQAhAANAIAAgAmpB/wBqIASnQQ9xIgNBMHIgA0E3aiADQQpJGzoAACAAQQFrIQAgBEIPViAEQgSIIQQNAAsgAUEBQY/EwgBBAiAAIAJqQYABakEAIABrEDUgAkGAAWokAA8LIAAgARD+AQs5AQF/IAAoAgAhACABKAIUIgJBEHFFBEAgAkEgcUUEQCAAIAEQxQEPCyAAIAEQ/AEPCyAAIAEQ/QELOQEBfyAAKAIAIQAgASgCFCICQRBxRQRAIAJBIHFFBEAgACABEKkDDwsgACABEIQCDwsgACABEIMCCzkBAX8gACgCACEAIAEoAhQiAkEQcUUEQCACQSBxRQRAIAAgARCtBA8LIAAgARCEAg8LIAAgARCDAgs7AQF/IwBBEGsiAiQAIAIgACgCADYCDCABQYWJwQBBFkGbicEAQQMgAkEMakHAhsEAEMkBIAJBEGokAAs7AQF/IwBBEGsiAiQAIAIgACgCADYCDCABQfCIwQBBEUGBicEAQQQgAkEMakHgiMEAEMkBIAJBEGokAAs7AQF/IwBBEGsiAiQAIAIgACgCADYCDCABQYWXwQBBG0HUh8EAQQMgAkEMakHAhsEAEMkBIAJBEGokAAs9AQF+QYXlwgAtAAAaIAApAgAhAUEMQQQQ9QMiAARAIAAgATcCBCAAQYCAgIB4NgIAIAAPC0EEQQwQ0wQACzsBAX8jAEEQayICJAAgAiAAKAIANgIMIAFB8M3BAEEbQYvOwQBBAyACQQxqQYTNwQAQyQEgAkEQaiQACzgAAkAgAkGAgMQARg0AIAAgAiABKAIQEQAARQ0AQQEPCyADRQRAQQAPCyAAIAMgBCABKAIMEQIACzgBAX8jAEEQayICJAAgAiAANgIMIAFByJrAAEERQdmawABBBCACQQxqQbiawAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFB3ZrAAEEWQfOawABBAyACQQxqQZiYwAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFB9arAAEEbQayZwABBAyACQQxqQZiYwAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFB3L3AAEERQe29wABBBCACQQxqQcy9wAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFB8b3AAEEWQYe+wABBAyACQQxqQay7wAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBic7AAEEbQcC8wABBAyACQQxqQay7wAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBrODAAEERQb3gwABBBCACQQxqQZzgwAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBweDAAEEWQdfgwABBAyACQQxqQfjawAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFB8fDAAEEbQZDfwABBAyACQQxqQfjawAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFB8IjBAEERQYGJwQBBBCACQQxqQeCIwQAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBhYnBAEEWQZuJwQBBAyACQQxqQcCGwQAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBhZfBAEEbQdSHwQBBAyACQQxqQcCGwQAQyQEgAkEQaiQACzwBAX8jAEEQayICJAAgAkGQksIANgIMIAIgADYCCCACQQhqQZSSwgAgAkEMakGUksIAIAFB5J/CABBrAAs4AQF/IwBBEGsiAiQAIAIgADYCDCABQeywwgBBDUH5sMIAQQQgAkEMakHcsMIAEMkBIAJBEGokAAs5AQF/IwBBEGsiAyQAIAMgATYCDCADIAA2AgggA0EIakGswsIAIANBDGpBrMLCACACQeyOwgAQawALMAEBfyMAQRBrIgIkACACQQhqIAAQ8wIgAigCCCABIAIoAgwoAhARAAAgAkEQaiQACzIBAX8gASgCFCICQRBxRQRAIAJBIHFFBEAgACABEMUBDwsgACABEPwBDwsgACABEP0BCzIBAX8gASgCFCICQRBxRQRAIAJBIHFFBEAgACABEK0EDwsgACABEIQCDwsgACABEIMCCzIBAX8gASgCFCICQRBxRQRAIAJBIHFFBEAgACABEKkDDwsgACABEIQCDwsgACABEIMCCzMBAX8jAEEQayICJAAgAiAAKAIANgIMIAFB7IfBAEEMIAJBDGpB3IfBABB/IAJBEGokAAszAQF/IwBBEGsiAiQAIAIgACgCADYCDCABQejUwQBBDCACQQxqQdjUwQAQfyACQRBqJAALLQACQCAAIAEQrANFDQAgAARAQYXlwgAtAAAaIAAgARD1AyIBRQ0BCyABDwsACzcBAX8jAEEgayIBJAAgAUEANgIYIAFBATYCDCABQdzZwgA2AgggAUIENwIQIAFBCGogABCkAwALMwEBfyAAKAIAIgFBhICAgHhMIAFBg4CAgHhHcSABRXJFBEAgACgCBCABQQJ0QQQQpwQLCzABAX8jAEEQayICJAAgAiAANgIMIAFBxJnAAEEMIAJBDGpBtJnAABB/IAJBEGokAAsvACAAQZybwAA2AgQgACABIAFBACABLQAAQQJrQf8BcSIAQQFGGyAAQQJLGzYCAAswAQF/IwBBEGsiAiQAIAIgADYCDCABQdi8wABBDCACQQxqQci8wAAQfyACQRBqJAALLwAgAEGwvsAANgIEIAAgASABQQAgAS0AAEECa0H/AXEiAEEBRhsgAEECSxs2AgALMAEBfyMAQRBrIgIkACACIAA2AgwgAUGo38AAQQwgAkEMakGY38AAEH8gAkEQaiQACy8AIABBgOHAADYCBCAAIAEgAUEAIAEtAABBAmtB/wFxIgBBAUYbIABBAksbNgIACy8AIABBxInBADYCBCAAIAEgAUEAIAEtAABBAmtB/wFxIgBBAUYbIABBAksbNgIACzABAX8jAEEQayICJAAgAiAANgIMIAFB7IfBAEEMIAJBDGpB3IfBABB/IAJBEGokAAssAQF/IwBBEGsiACQAIABBCGoiAiABQfyVwgBBCxCmAyACEK4CIABBEGokAAuEAQEDfyMAQSBrIgQkACAEQQhqIgMQ8AECf0GF5cIALQAAGkEkQQQQ9QMiAgRAIAJB5LrAADYCACACIAE2AiAgAiAANgIcIAIgAykCADcCBCACQQxqIANBCGopAgA3AgAgAkEUaiADQRBqKQIANwIAIAIMAQtBBEEkENMEAAsgBEEgaiQACzgBAX9BASEBIAAtAARFBEAgACgCACIBKAIcQY7EwgBBASABKAIgKAIMEQIAIQELIAAgAToABCABC5ABAQN/IwBBIGsiAyQAIANBCGoiAhDwAQJ/QYXlwgAtAAAaQShBBBD1AyIBBEAgAUGcgsAANgIAIAEgAikCADcCBCABIAApAgA3AhwgAUEMaiACQQhq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NgIMIABBhKLCACABKAIEIAEoAggiAC0ACCAALQAJEMEBAAsgACADNgIEIAAgAjYCACAAQeihwgAgASgCBCABKAIIIgAtAAggAC0ACRDBAQALKgAgAEH/AXFFBEBDAAAAAA8LIABBAWtB/wFxs0NFIpE9lEMAABDBkhBSCy0AIAEoAhwgAiADIAEoAiAoAgwRAgAhAiAAQQA6AAUgACACOgAEIAAgATYCAAsyAQF/IAEoAhxBvMHCAEEBIAEoAiAoAgwRAgAhAiAAQQA6AAUgACACOgAEIAAgATYCAAshAAJAIAEgAxCsAwRAIAAgASADIAIQ3wMiAA0BCwALIAALIgEBfyAAKAIAIgAgAEEfdSICcyACayAAQX9zQR92IAEQbAslACAARQRAQfiPwgBBMhDIBAALIAAgAiADIAQgBSABKAIQEQsACygAIAEgACgCAC0AAEECdCIAQeC8wgBqKAIAIABBzLzCAGooAgAQ5QMLGQEBf0GAgICAeCABayAATyACIAFpQQFGGwslACABIAAtAABBAnQiAEH8tcAAaigCACAAQey1wABqKAIAEOUDCyUAIABBnJvAADYCBCAAIAFBBGpBACABKAIAQYKAgIB4Rhs2AgALIQAgAEHwosAANgIEIAAgAUEBakEAIAEtAABBAkYbNgIACyUAIAEgAC0AAEECdCIAQZDZwABqKAIAIABBgNnAAGooAgAQ5QMLJQAgAEGwvsAANgIEIAAgAUEEakEAIAEoAgBBgoCAgHhGGzYCAAshACAAQYTGwAA2AgQgACABQQFqQQAgAS0AAEECRhs2AgALJQAgASAALQAAQQJ0IgBB+PvAAGooAgAgAEHo+8AAaigCABDlAwslACAAQYDhwAA2AgQgACABQQRqQQAgASgCAEGCgICAeEYbNgIACyEAIABBsOjAADYCBCAAIAFBAWpBACABLQAAQQJGGzYCAAshACAAQbSOwQA2AgQgACABQQFqQQAgAS0AAEECRhs2AgALJQAgAEHEicEANgIEIAAgAUEEakEAIAEoAgBBgoCAgHhGGzYCAAslACABIAAtAABBAnQiAEGMosEAaigCACAAQfyhwQBqKAIAEOUDCyMAIABFBEBB+I/CAEEyEMgEAAsgACACIAMgBCABKAIQEQcACyMAIABFBEBB+I/CAEEyEMgEAAsgACACIAMgBCAB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BBD1AyILBEACQEGF5cIALQAAGkGACEEEEPUDIghFDQJBheXCAC0AABpBgAhBBBD1AyIERQ0AQYXlwgAtAAAaQYAIQQQQ9QMiDkUNAkGF5cIALQAAGkGACEEEEPUDIgxFDQBBheXCAC0AABpBgAhBBBD1AyISRQ0CIANCADcDqAIgA0EBNgLoASADQQA6AOQBIANBADoA4gEgA0EAOgDgASADQTQ7AdwBIANBADYC2AEgAyASNgLUASADQoCAgICAIDcCzAEgAyAMNgLIASADQoCAgICAIDcDwAEgA0KAgICAwAA3A7gBIANBIzsBtAEgA0EANgKwASADIA42AqwBIANCgICAgIAgNwKkASADIAQ2AqABIANCgICAgIAgNwOYASADQoCAgIDAADcDkAEgA0EfOwGMASADQQA2AogBIAMgCDYChAEgA0KAgICAgCA3AnwgAyALNgJ4IANCgICAgIAgNwNwIANCgICAgMAANwNoIANBwAJqQgA3AwAgA0G4AmpCADcDACADQbACakIANwMAIANB/AFqQQA2AgAgA0H0AWpCADcCACADQgA3AuwBIANC1uuC7ur9ifXgADcDgAIgA0LP1tO+0ser2UI3A4gCIANCADcDkAIgA0L56tDQ58mh5OEANwOYAiADQgA3A6ACIANBADYCyAIgA0IANwPQAiADIAY2AtgCIANBADYC5AIgA0EINgKUAyADQoCAgIAQNwLcAiADQoGAgIDAADcCjAMgA0EANgKIAyADQoCAgIAQNwPoAiADQgA3A/ACIANCBDcD+AIgA0KAgICAEDcDgAMMAwsLQQRBgAhBzIDCABDXAwALQQRBgAhB3IDCABDXAwALIAdBADYCqAcgB0EANgKwByAHQQA6ANwKIAdBADYC2AogByAjNwPQCiAHKQOoByEgIAcpA7AHISMgB0HoA2oiBiADQagDEDsaIAdBCGoQSSAHICM3AyggByAgNwMgIAcgITcDGCAHIA02AgwgByAiPgIQIAcgIkIgiD4CFCAHIAU2AgggB0EwaiAGQagDEDshCCAFQQFxBEBBDCEQIAcoAtgDIhJFDQEgBygC3AMhFwNAIBJB1AFrIQQgEkEEaiEGIBIvAd4WIgNBAnQhC0F/IQUCQAJAA0AgC0UEQCADIQUMAgsgBigCACEOIAVBAWohBSAEQYQCaiEEIAtBBGsh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EwAgAEHMuMAANgIEIAAgATYCAAsTACAAQYi5wAA2AgQgACABNgIACxMAIABBxLnAADYCBCAAIAE2AgALEwAgAEGAusAANgIEIAAgATYCAAsTACAAQbC+wAA2AgQgACABNgIACxMAIABBKDYCBCAAQYjbwAA2AgALEwAgAEGA4cAANgIEIAAgATYCAAshACAAQqTFo/yfjvDjADcDCCAAQqqooLmusOaw6QA3AwALEAAgACgCACAAKAIEIAEQMAsRACAAKAIAIAAoAgQgARDVBAsiACAAQsuH6/rgqLu20AA3AwggAELEr9zF2tKv9bh/NwMACxMAIABBKDYCBCAAQcCFwQA2AgALEwAgAEHEicEANgIEIAAgATYCAAsgACAAQrz8k7Ko16DsTDcDCCAAQuuYqJm2gbKefzcDAAshACAAQriynYTMrpfUQjcDCCAAQu/Dv6KOjcrEoH83AwALIAAgAEKcnaLxgrvwoHU3AwggAELRqsqvpcqt8kA3AwALIQAgAEL7wqCWlfy/yHo3AwggAELmsfLlkYe/ybF/NwMACyIAIABC9auQ77TsvKaWfzcDCCAAQrHh7P30uYbLwgA3AwALIAAgAELNnq77nqC2sEE3AwggAELxps+Y0aSn/gE3AwALIAAgAEK3v8ue+N2SoEM3AwggAEKvuaX0x5vV+zA3AwALIQAgAEKWl7rs79nZo3Q3AwggAEKH+OXLhuPSwtQANwMACyEAIABC/O6Qyq7osdU1NwMIIABC2OvVj+a1zN2OfzcDAAshACAAQrzprN2Y1v7ui383AwggAEKk3Nqt0/nNwEU3AwALIQAgAELl6obQ6cP/7Xk3AwggAEL30OLk1cPQ6ad/NwMACyEAIABC5sHsgPKk3YtlNwMIIABChu7u8+efmIeefzcDAAshACAAQs7Is8mT6a+2pX83AwggAELt66KMv7HLkg83AwALIgAgAEKcrtGn56WAwMIANwMIIABC16rLiaf+wYLHADcDAAsiACAAQt3+weC9o+rogn83AwggAEKX2/aYrfP7zY5/NwMACyEAIABCgsDc4LCv07mnfzcDCCAAQpbk17fDtcOKAzcDAAshACAAQrvV0cb1jfDEkH83AwggAELVi9bpuKS4kXk3AwALIQAgAEKynOer2rGju98ANwMIIABCvfif/8L+hsNVNwMACyIAIABC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ZXJFcnJvcgAAAAAEAAAABAAAAE4AAABGcmFtZUhlYWRlckVycm9yV2luZG93U2l6ZVRvb0JpZwAAAAAEAAAABAAAAE8AAABEaWN0aW9uYXJ5RGVjb2RlRXJyb3IAAAAAAAAABAAAAAQAAABQAAAARmFpbGVkVG9SZWFkQmxvY2tIZWFkZXIAAAAAAAQAAAAEAAAAUQAAAEZhaWxlZFRvUmVhZEJsb2NrQm9keQAAAAAAAAAEAAAABAAAAFIAAABGYWlsZWRUb1JlYWRDaGVja3N1bU5vdFlldEluaXRpYWxpemVkRmFpbGVkVG9Jbml0aWFsaXplRmFpbGVkVG9EcmFpbkRlY29kZWJ1ZmZlckZhaWxlZFRvU2tpcEZyYW1lVGFyZ2V0VG9vU21hbGxEaWN0Tm90UHJvdmlkZWRkaWN0X2lkAAAAAAAAAAQAAAAEAAAAUwAAAEZTRURlY29kZXJFcnJvcgAAAAAABAAAAAQAAABUAAAARlNFVGFibGVFcnJvclNvdXJjZUlzRW1wdHlOb3RFbm91Z2hCeXRlc0ZvcldlaWdodHNnb3RfYnl0ZXNleHBlY3RlZF9ieXRlcwAAAAAAAAAEAAAABAAAAFUAAABFeHRyYVBhZGRpbmdza2lwcGVkX2JpdHNUb29NYW55V2VpZ2h0c01pc3NpbmdXZWlnaHRzTGVmdG92ZXJJc05vdEFQb3dlck9mMk5vdEVub3VnaEJ5dGVzVG9EZWNvbXByZXNzV2VpZ2h0c2hhdmVGU0VUYWJsZVVzZWRUb29NYW55Qnl0ZXN1c2VkYXZhaWxhYmxlX2J5dGVzTm90RW5vdWdoQnl0ZXNJblNvdXJjZVdlaWdodEJpZ2dlclRoYW5NYXhOdW1CaXRzTWF4Qml0c1Rvb0hpZ2gAAAAAAQAAAAEAAABWAAAAAAAAAAEAAAABAAAAVwAAAFYAAABgERAAWAAAAFkAAABaAAAAWwAAAFwAAABVbnN1cHBvcnRlZE9mZnNldG9mZnNldF9jb2RlWmVyb09mZnNldE5vdEVub3VnaEJ5dGVzRm9yTnVtU2VxdWVuY2VzAAAAAAAEAAAABAAAAF0AAABFeHRyYUJpdHNiaXRzX3JlbWFpbmluZ01pc3NpbmdDb21wcmVzc2lvbk1vZGVNaXNzaW5nQnl0ZUZvclJsZUxsVGFibGVNaXNz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ZXJFcnJvcgAAAAAEAAAABAAAAE4AAABGcmFtZUhlYWRlckVycm9yV2luZG93U2l6ZVRvb0JpZwAAAAAEAAAABAAAAE8AAABEaWN0aW9uYXJ5RGVjb2RlRXJyb3IAAAAAAAAABAAAAAQAAABQAAAARmFpbGVkVG9SZWFkQmxvY2tIZWFkZXIAAAAAAAQAAAAEAAAAUQAAAEZhaWxlZFRvUmVhZEJsb2NrQm9keQAAAAAAAAAEAAAABAAAAFIAAABGYWlsZWRUb1JlYWRDaGVja3N1bU5vdFlldEluaXRpYWxpemVkRmFpbGVkVG9Jbml0aWFsaXplRmFpbGVkVG9EcmFpbkRlY29kZWJ1ZmZlckZhaWxlZFRvU2tpcEZyYW1lVGFyZ2V0VG9vU21hbGxEaWN0Tm90UHJvdmlkZWRkaWN0X2lkAAAAAAAAAAQAAAAEAAAAUwAAAEZTRURlY29kZXJFcnJvcgAAAAAABAAAAAQAAABUAAAARlNFVGFibGVFcnJvclNvdXJjZUlzRW1wdHlOb3RFbm91Z2hCeXRlc0ZvcldlaWdodHNnb3RfYnl0ZXNleHBlY3RlZF9ieXRlcwAAAAAAAAAEAAAABAAAAFUAAABFeHRyYVBhZGRpbmdza2lwcGVkX2JpdHNUb29NYW55V2VpZ2h0c01pc3NpbmdXZWlnaHRzTGVmdG92ZXJJc05vdEFQb3dlck9mMk5vdEVub3VnaEJ5dGVzVG9EZWNvbXByZXNzV2VpZ2h0c2hhdmVGU0VUYWJsZVVzZWRUb29NYW55Qnl0ZXN1c2VkYXZhaWxhYmxlX2J5dGVzTm90RW5vdWdoQnl0ZXNJblNvdXJjZVdlaWdodEJpZ2dlclRoYW5NYXhOdW1CaXRzTWF4Qml0c1Rvb0hpZ2gAAAAAAQAAAAEAAABWAAAAAAAAAAEAAAABAAAA/wAAAFYAAAD0IhAAAAEAAFkAAAABAQAAWwAAAAIBAABVbnN1cHBvcnRlZE9mZnNldG9mZnNldF9jb2RlWmVyb09mZnNldE5vdEVub3VnaEJ5dGVzRm9yTnVtU2VxdWVuY2VzAAAAAAAEAAAABAAAAF0AAABFeHRyYUJpdHNiaXRzX3JlbWFpbmluZ01pc3NpbmdDb21wcmVzc2lvbk1vZGVNaXNzaW5nQnl0ZUZvclJsZUxsVGFibGVNaXNz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bEVuY29kaW5nSW52YWxpZENoYXJFbmNvZGluZwAAAAAAAAAEAAAABAAAAEEAAABJbnZhbGlkVGFnRW5jb2RpbmdEZXNlcmlhbGl6ZUFueU5vdFN1cHBvcnRlZFNpemVMaW1pdFNlcXVlbmNlTXVzdEhhdmVMZW5ndGgAAAAAAAQAAAAEAAAANQEAAEN1c3RvbU5vbmVTb21lUmF3UkxFQ29tcHJlc3NlZFJlc2VydmVkAAAAAAAABAAAAAQAAAA2AQAAVG9vTWFueUJpdHNudW1fcmVxdWVzdGVkX2JpdHNsaW1pdE5vdEVub3VnaFJlbWFpbmluZ0JpdHNyZXF1ZXN0ZWRyZW1haW5pbmdBY2NMb2dJc1plcm8AAAAAAAABAAAAAQAAADcBAABBY2NMb2dUb29CaWdnb3RtYXgAAAAAAAAEAAAABAAAAEMAAABHZXRCaXRzRXJyb3IAAAAABAAAAAQAAAA4AQAAAAAAAAQAAAAEAAAARQAAAFByb2JhYmlsaXR5Q291bnRlck1pc21hdGNoZXhwZWN0ZWRfc3Vtc3ltYm9sX3Byb2JhYmlsaXRpZXNUb29NYW55U3ltYm9scwAAAAAEAAAABAAAAEYAAABCbG9ja1NpemVUb29MYXJnZXNpemVJbnZhbGlkQmxvY2t0eXBlTnVtYmVybnVtVGFibGVJc1VuaW5pdGlhbGl6ZWQAAAAAAAAMAAAABAAAAEcAAAAAAAAADAAAAAQAAAA5AQAARwAAAHAwEAA6AQAASQAAADsBAABKAAAAPAEAAAAAAAAEAAAABAAAAEsAAABXaW5kb3dUb29CaWdXaW5kb3dUb29TbWFsbAAAAAAAAAQAAAAEAAAATAAAAEZyYW1lRGVzY3JpcHRvckVycm9yRGljdElkVG9vU21hbGxleHBlY3RlZE1pc21hdGNoZWRGcmFtZVNpemVGcmFtZVNpemVJc1plcm9JbnZhbGlkRnJhbWVTaXplTm90RW5vdWdoQnl0ZXNJbkRpY3Rpb25hcnluZWVkT2Zmc2V0VG9vQmlnb2Zmc2V0YnVmX2xlbgAAAAAABAAAAAQAAABNAAAAUmVhZEZyYW1lSGVhZGVyRXJyb3IAAAAABAAAAAQAAABOAAAARnJhbWVIZWFkZXJFcnJvcldpbmRvd1NpemVUb29CaWcAAAAABAAAAAQAAABPAAAARGljdGlvbmFyeURlY29kZUVycm9yAAAAAAAAAAQAAAAEAAAAUAAAAEZhaWxlZFRvUmVhZEJsb2NrSGVhZGVyAAAAAAAEAAAABAAAAFEAAABGYWlsZWRUb1JlYWRCbG9ja0JvZHlGYWlsZWRUb1JlYWRDaGVja3N1bU5vdFlldEluaXRpYWxpemVkRmFpbGVkVG9Jbml0aWFsaXplRmFpbGVkVG9EcmFpbkRlY29kZWJ1ZmZlckZhaWxlZFRvU2tpcEZyYW1lVGFyZ2V0VG9vU21hbGxEaWN0Tm90UHJvdmlkZWRkaWN0X2lkAAAAAAAABAAAAAQAAABTAAAARlNFRGVjb2RlckVycm9yAAAAAAAEAAAABAAAAFQAAABGU0VUYWJsZUVycm9yU291cmNlSXNFbXB0eU5vdEVub3VnaEJ5dGVzRm9yV2VpZ2h0c2dvdF9ieXRlc2V4cGVjdGVkX2J5dGVzRXh0cmFQYWRkaW5nc2tpcHBlZF9iaXRzVG9vTWFueVdlaWdodHNNaXNzaW5nV2VpZ2h0c0xlZnRvdmVySXNOb3RBUG93ZXJPZjJOb3RFbm91Z2hCeXRlc1RvRGVjb21wcmVzc1dlaWdodHNoYXZlRlNFVGFibGVVc2VkVG9vTWFueUJ5dGVzdXNlZGF2YWlsYWJsZV9ieXRlc05vdEVub3VnaEJ5dGVzSW5Tb3VyY2VXZWlnaHRCaWdnZXJUaGFuTWF4TnVtQml0c01heEJpdHNUb29IaWdoAAAAAAAAAAEAAAABAAAAVgAAAAAAAAABAAAAAQAAAD0BAABWAAAAIDQQAD4BAABZAAAAPwEAAFsAAABAAQAAVW5zdXBwb3J0ZWRPZmZzZXRvZmZzZXRfY29kZVplcm9PZmZzZXROb3RFbm91Z2hCeXRlc0Zvck51bVNlcXVlbmNlcwAAAAAABAAAAAQAAABdAAAARXh0cmFCaXRzYml0c19yZW1haW5pbmdNaXNzaW5nQ29tcHJlc3Npb25Nb2RlTWlzc2luZ0J5dGVGb3JSbGVMbFRhYmxlTWlzc2luZ0J5dGVGb3JSbGVPZlRhYmxlTWlzc2luZ0J5dGVGb3JSbGVNbFRhYmxlAAAAQQEAAAwAAAAEAAAAXwAAAEEBAAAMAAAABAAAAEIBAABfAAAAKDUQAEMBAABiAAAAOwEAAGMAAAA8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YWxzbmVlZGVkAAAAAAAABAAAAAQAAABjAQAAQml0c3RyZWFtUmVhZE1pc21hdGNocmVhZF90aWxEZWNvZGVkTGl0ZXJhbENvdW50TWlzbWF0Y2hkZWNvZGVkAGQBAAAUAAAABAAAALQAAABkAQAAFAAAAAQAAABlAQAAtAAAAMQ8EABmAQAAtwAAADsBAAC4AAAAPAEAAAAAAAAMAAAABAAAALkAAAAAAAAADAAAAAQAAABnAQAAuQAAAAA9EAA6AQAAuwAAADsBAABKAAAAPAEAAGgBAAAYAAAABAAAAL0AAABoAQAAGAAAAAQAAABpAQAAvQAAADw9EABqAQAAwAAAADsBAADBAAAAPAEAAAAAAAAMAAAABAAAAMIAAAAAAAAADAAAAAQAAABrAQAAwgAAAHg9EABsAQAAxQAAADsBAADGAAAAPAEAAElsbGVnYWxMaXRlcmFsU2VjdGlvblR5cGVOb3RFbm91Z2hCeXRlc25lZWRfYXRfbGVhc3QDAAAAAwAAAAoAAAAIAAAA8i4QAPUuEAD4LhAAAi8QAC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnMAAAAIPhAAbQAAACoCAAARAAAAYW4gYXJyYXkgb2YgbGVuZ3RoIDQAAAAAAAAAAAEAAABtAQBBtP3AAAv1KAEAAABtAQAAAAAAAAgAAAAEAAAAbgEAAHN0cnVjdCBXbGcwSGVhZGVyIHdpdGggNyBlbGVtZW50cwAAAMw+EAAhAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogaW52YWxpZCBPbmNlIHN0YXRl+D4QADwAAAAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L3N0ZC9zcmMvc3lzL3N5bmMvb25jZS9ub190aHJlYWRzLnJzPD8QAHwAAAA1AAAAEgAAAGZhaWxlZCB0byBmaWxsIHdob2xlIGJ1ZmZlcgDIPxAAGwAAACUAAAACAAAA5D8QAC9Vc2Vycy9keWxhbi8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3J1enN0ZC0wLjguMC9zcmMvZGVjb2RpbmcvYmxvY2tfZGVjb2Rlci5yc0J1ZyBpbiB0aGlzIGxpYnJhcnkA+D8QAGwAAACYAAAAFgAAAFdyb25nIG51bWJlciBvZiBsaXRlcmFsczogLCBTaG91bGQgaGF2ZSBiZWVuOiAAAIhAEAAaAAAAokAQABQAAAD4PxAAbAAAAK0AAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogYnl0ZXNfdXNlZF9pbl9saXRlcmFsc19zZWN0aW9uID09IHVwcGVyX2xpbWl0X2Zvcl9saXRlcmFscyBhcyB1MzIA+D8QAGwAAACzAAAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IHUzMjo6ZnJvbShieXRlc19pbl9saXRlcmFsc19oZWFkZXIpICsgYnl0ZXNfdXNlZF9pbl9saXRlcmFsc19zZWN0aW9uICsKICAgICAgICAgICAgdTMyOjpmcm9tKGJ5dGVzX2luX3NlcXVlbmNlX2hlYWRlcikgKyByYXcubGVuKCkgYXMgdTMyID09CiAgICBoZWFkZXIuY29udGVudF9zaXplAAD4PxAAbAAAAMEAAAAJAAAA+D8QAGwAAAC6AAAAFwAAAPg/EABsAAAAiwAAABcAAABIb3cgZGlkIHlvdSBldmVuIGdldCB0aGlzLiBUaGUgZGVjb2RlciBzaG91bGQgZXJyb3Igb3V0IGlmIGl0IGRldGVjdHMgYSByZXNlcnZlZC10eXBlIGJsb2NrAPg/EABsAAAAcAAAABEAAABmYWlsZWQgdG8gZmlsbCB3aG9sZSBidWZmZXIAkEIQABsAAAAlAAAAAgAAAKxCEABkZXNjcmlwdGlvbigpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBEaXNwbGF5AAAAAAQAAAAEAAAAbwEAAAAAAAAEAAAABAAAAHABAABVdGY4RXJyb3J2YWxpZF91cF90b2Vycm9yX2xlblJhd1JMRUNvbXByZXNzZWRSZXNlcnZlZAAAAAAAAAAEAAAABAAAAEAAAABUb29NYW55Qml0c251bV9yZXF1ZXN0ZWRfYml0c2xpbWl0AAAAAAAABAAAAAQAAABBAAAATm90RW5vdWdoUmVtYWluaW5nQml0c3JlcXVlc3RlZHJlbWFpbmluZ0FjY0xvZ0lzWmVybwAAAAABAAAAAQAAAHEBAABBY2NMb2dUb29CaWdnb3RtYXgAAAAAAAAEAAAABAAAAEMAAABHZXRCaXRzRXJyb3IAAAAABAAAAAQAAAByAQAAAAAAAAQAAAAEAAAARQAAAFByb2JhYmlsaXR5Q291bnRlck1pc21hdGNoZXhwZWN0ZWRfc3Vtc3ltYm9sX3Byb2JhYmlsaXRpZXNUb29NYW55U3ltYm9scwAAAAAEAAAABAAAAEYAAABCbG9ja1NpemVUb29MYXJnZXNpemVJbnZhbGlkQmxvY2t0eXBlTnVtYmVybnVtVGFibGVJc1VuaW5pdGlhbGl6ZWQAAAAAAAAMAAAABAAAAEcAAAAAAAAADAAAAAQAAABzAQAARwAAALREEABKAAAASQAAAHQBAABKAAAAdQEAAAAAAAAEAAAABAAAAEsAAABXaW5kb3dUb29CaWdXaW5kb3dUb29TbWFsbAAAAAAAAAQAAAAEAAAATAAAAEZyYW1lRGVzY3JpcHRvckVycm9yRGljdElkVG9vU21hbGxleHBlY3RlZE1pc21hdGNoZWRGcmFtZVNpemVGcmFtZVNpemVJc1plcm9JbnZhbGlkRnJhbWVTaXplTm90RW5vdWdoQnl0ZXNJbkRpY3Rpb25hcnluZWVkT2Zmc2V0VG9vQmlnb2Zmc2V0YnVmX2xlbgAAAAAABAAAAAQAAABTAAAARlNFRGVjb2RlckVycm9yAAAAAAAEAAAABAAAAFQAAABGU0VUYWJsZUVycm9yU291cmNlSXNFbXB0eU5vdEVub3VnaEJ5dGVzRm9yV2VpZ2h0c2dvdF9ieXRlc2V4cGVjdGVkX2J5dGVzAAAAAAAAAAQAAAAEAAAAVQAAAEV4dHJhUGFkZGluZ3NraXBwZWRfYml0c1Rvb01hbnlXZWlnaHRzTWlzc2luZ1dlaWdodHNMZWZ0b3ZlcklzTm90QVBvd2VyT2YyTm90RW5vdWdoQnl0ZXNUb0RlY29tcHJlc3NXZWlnaHRzaGF2ZUZTRVRhYmxlVXNlZFRvb01hbnlCeXRlc3VzZWRhdmFpbGFibGVfYnl0ZXNOb3RFbm91Z2hCeXRlc0luU291cmNlV2VpZ2h0QmlnZ2VyVGhhbk1heE51bUJpdHNNYXhCaXRzVG9vSGlnaAAAAAABAAAAAQAAAFYAAAAAAAAAAQAAAAEAAAB2AQAAVgAAACRHEABbAAAAWQAAAHcBAABbAAAAeAEAAFVuc3VwcG9ydGVkT2Zmc2V0b2Zmc2V0X2NvZGVaZXJvT2Zmc2V0Tm90RW5vdWdoQnl0ZXNGb3JOdW1TZXF1ZW5jZXMAAAAAAAQAAAAEAAAAXQAAAEV4dHJhQml0c2JpdHNfcmVtYWluaW5nTWlzc2luZ0NvbXByZXNzaW9uTW9kZU1pc3NpbmdCeXRlRm9yUmxlTGxUYWJsZU1pc3NpbmdCeXRlRm9yUmxlT2ZUYWJsZU1pc3NpbmdCeXRlRm9yUmxlTWxUYWJsZQAAAHkBAAAMAAAABAAAAF8AAAB5AQAADAAAAAQAAAB6AQAAXwAAACxIEAB7AQAAYgAAAHQBAABjAAAAdQEAAAAAAAAQAAAACAAAAGQAAAAAAAAAEAAAAAgAAAB8AQAAZAAAAGhIEAB9AQAAZwAAAH4BAABoAAAAfwEAAIABAAAYAAAABAAAAGoAAACAAQAAGAAAAAQAAACBAQAAagAAAKRIEACCAQAAbQAAAHQBAABuAAAAdQEAAIMBAAAIAAAABAAAAHAAAACDAQAACAAAAAQAAACEAQAAcAAAAOBIEACFAQAAcwAAAHQBAAB0AAAAdQEAAIYBAAAYAAAABAAAAHYAAACGAQAAGAAAAAQAAACHAQAAdgAAABxJEACIAQAAeQAAAHQBAAB6AAAAdQEAAIkBAAAIAAAABAAAACUAAACJAQAACAAAAAQAAAAmAAAAJQAAAFhJEAAnAAAAKAAAACkAAAAqAAAAdQEAAAAAAAAMAAAABAAAAHsAAAAAAAAADAAAAAQAAACKAQAAewAAAJRJEACLAQAAfgAAAHQBAAB/AAAAdQEAAIwBAAAUAAAABAAAAIEAAACMAQAAFAAAAAQAAACNAQAAgQAAANBJEACOAQAAhAAAAHQBAACFAAAAdQEAAAAAAAAEAAAABAAAAFIAAABSZWFkRXJyb3JGb3VuZFJlc2VydmVkQmxvY2sAAAAAAAQAAAAEAAAAhgAAAEJsb2NrVHlwZUVycm9yAAAAAAAABAAAAAQAAACHAAAAQmxvY2tTaXplRXJyb3JCbG9ja0NvbnRlbnRSZWFkRXJyb3JNYWxmb3JtZWRTZWN0aW9uSGVhZGVyZXhwZWN0ZWRfbGVucmVtYWluaW5nX2J5dGVzAAAAAAQAAAAEAAAAiAAAAERlY29tcHJlc3NMaXRlcmFsc0Vycm9yAAAAAAAEAAAABAAAAIkAAABMaXRlcmFsc1NlY3Rpb25QYXJzZUVycm9yAAAAAAAAAAQAAAAEAAAAigAAAFNlcXVlbmNlc0hlYWRlclBhcnNlRXJyb3IAAAAAAAAABAAAAAQAAACLAAAARGVjb2RlU2VxdWVuY2VFcnJvcgAAAAAABAAAAAQAAACMAAAARXhlY3V0ZVNlcXVlbmNlc0Vycm9ySW52YWxpZEZyYW1lQ29udGVudFNpemVGbGFnTWFnaWNOdW1iZXJSZWFkRXJyb3JCYWRNYWdpY051bWJlckZyYW1lRGVzY3JpcHRvclJlYWRFcnJvckludmFsaWRGcmFtZURlc2NyaXB0b3JXaW5kb3dEZXNjcmlwdG9yUmVhZEVycm9yRGljdGlvbmFyeUlkUmVhZEVycm9yRnJhbWVDb250ZW50U2l6ZVJlYWRFcnJvclNraXBGcmFtZW1hZ2ljX251bWJlcmxlbmd0aAAAAAAAAAQAAAAEAAAAjQAAAEJhZE1hZ2ljTnVtAAAAAAAEAAAABAAAAI4AAABIdWZmbWFuVGFibGVFcnJvcgAAAAAAAAAEAAAABAAAAI8AAABEZWNvZGVidWZmZXJFcnJvck5vdEVub3VnaEJ5dGVzRm9yU2VxdWVuY2V3YW50ZWQAAAAAAQAAAAEAAACQAAAAAAAAAAEAAAABAAAAjwEAAJAAAADUTBAAWwAAAJIAAAB3AQAAWwAAAHgBAAAAAAAABAAAAAQAAACTAAAAAAAAAAQAAAAEAAAAkAEAAJMAAAAQTRAASgAAAJUAAAB0AQAASgAAAHUBAACRAQAAFAAAAAQAAACXAAAAkQEAABQAAAAEAAAAkgEAAJcAAABMTRAAkwEAAJoAAAB0AQAAmwAAAHUBAAAAAAAADAAAAAQAAACcAAAAAAAAAAwAAAAEAAAAlAEAAJwAAACITRAAlQEAAJ8AAAB0AQAAoAAAAHUBAAAAAAAACAAAAAQAAAChAAAAAAAAAAgAAAAEAAAAlgEAAKEAAADETRAASgAAAKMAAAB0AQAASgAAAHUBAACXAQAAFAAAAAQAAAClAAAAlwEAABQAAAAEAAAAmAEAAKUAAAAAThAAmQEAAKgAAAB0AQAAqQAAAHUBAAAAAAAADAAAAAQAAACqAAAAAAAAAAwAAAAEAAAAmgEAAKoAAAA8ThAAmwEAAK0AAAB0AQAArgAAAHUBAABEZWNvZGVyU3RhdGVJc0ZhaWxlZEV4cGVjdGVkSGVhZGVyT2ZQcmV2aW91c0Jsb2NrAAAAAAAAAAEAAAABAAAAnAEAAHN0ZXBzb3VyY2UAAAAAAAAEAAAABAAAALAAAABEZWNvbXByZXNzQmxvY2tFcnJvck1pc3NpbmdDb21wcmVzc2VkU2l6ZU1pc3NpbmdOdW1TdHJlYW1zAAAAAAAABAAAAAQAAACxAAAASHVmZm1hbkRlY29kZXJFcnJvclVuaW5pdGlhbGl6ZWRIdWZmbWFuVGFibGVNaXNzaW5nQnl0ZXNGb3JKdW1wSGVhZGVyTWlzc2luZ0J5dGVzRm9yTGl0ZXJhbHNuZWVkZWQAAAAAAAAEAAAABAAAAJ0BAABCaXRzdHJlYW1SZWFkTWlzbWF0Y2hyZWFkX3RpbERlY29kZWRMaXRlcmFsQ291bnRNaXNtYXRjaGRlY29kZWQAngEAABQAAAAEAAAAtAAAAJ4BAAAUAAAABAAAAJ8BAAC0AAAA2E8QAKABAAC3AAAAdAEAALgAAAB1AQAAAAAAAAwAAAAEAAAAuQAAAAAAAAAMAAAABAAAAKEBAAC5AAAAFFAQAEoAAAC7AAAAdAEAAEoAAAB1AQAAogEAABgAAAAEAAAAvQAAAKIBAAAYAAAABAAAAKMBAAC9AAAAUFAQAKQBAADAAAAAdAEAAMEAAAB1AQAAAAAAAAwAAAAEAAAAwgAAAAAAAAAMAAAABAAAAKUBAADCAAAAjFAQAMYAAADFAAAAdAEAAMYAAAB1AQAASWxsZWdhbExpdGVyYWxTZWN0aW9uVHlwZU5vdEVub3VnaEJ5dGVzbmVlZF9hdF9sZWFzdAMAAAADAAAACgAAAAgAAAAlQxAAKEMQACtDEAA1QxAAL1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9zdGQvc3JjL2lvL21vZC5ycwAAHFEQAGoAAACyAQAAMQAAAGFzc2VydGlvbiBmYWlsZWQ6IGZpbGxlZCA8PSBzZWxmLmJ1Zi5pbml0L1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9jb3JlL3NyYy9pby9ib3Jyb3dlZF9idWYucnMAAADBURAAdAAAAB0BAAAJAAAAL1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYnRyZWUvbmF2aWdhdGUucnNIUhAAgAAAAFgCAAAwAAAASW52YWxpZCBGcmFtZV9Db250ZW50X1NpemVfRmxhZzsgSXM6ICwgU2hvdWxkIGJlIG9uZSBvZjogMCwgMSwgMiwgMwDYUhAAJQAAAP1SEAAeAEG0psEAC8piwAMAAHdpbmRvd19zaXplIGJpZ2dlciB0aGFuIGFsbG93ZWQgbWF4aW11bS4gSXM6ICwgU2hvdWxkIGJlIGxvd2VyIHRoYW46IAAAADhTEAAtAAAAZVMQABgAAAAABAAAAAAAAHdpbmRvd19zaXplIHNtYWxsZXIgdGhhbiBhbGxvd2VkIG1pbmltdW0uIElzOiAsIFNob3VsZCBiZSBncmVhdGVyIHRoYW46IJhTEAAuAAAAxlMQABoAAAABAAAAAAAAAE5vdCBlbm91Z2ggYnl0ZXMgaW4gZGljdF9pZC4gSXM6ICwgU2hvdWxkIGJlOiAAAPhTEAAhAAAAGVQQAA0AAABmcmFtZV9jb250ZW50X3NpemUgZG9lcyBub3QgaGF2ZSB0aGUgcmlnaHQgbGVuZ3RoLiBJczogADhUEAA3AAAAGVQQAA0AAABmcmFtZV9jb250ZW50X3NpemUgd2FzIHplcm9JbnZhbGlkIGZyYW1lX2NvbnRlbnRfc2l6ZS4gSXM6ICwgU2hvdWxkIGJlIG9uZSBvZiAxLCAyLCA0LCA4IGJ5dGVzAACbVBAAIAAAALtUEAAjAAAARXJyb3Igd2hpbGUgcmVhZGluZyBtYWdpYyBudW1iZXI6IAAA8FQQACIAAABSZWFkIHdyb25nIG1hZ2ljIG51bWJlcjogMHgAHFUQABsAAABFcnJvciB3aGlsZSByZWFkaW5nIGZyYW1lIGRlc2NyaXB0b3I6IAAAQFUQACYAAABFcnJvciB3aGlsZSByZWFkaW5nIHdpbmRvdyBkZXNjcmlwdG9yOiAAcFUQACcAAABFcnJvciB3aGlsZSByZWFkaW5nIGRpY3Rpb25hcnkgaWQ6IACgVRAAIwAAAEVycm9yIHdoaWxlIHJlYWRpbmcgZnJhbWUgY29udGVudCBzaXplOiDMVRAAKAAAAFNraXBwYWJsZUZyYW1lIGVuY291bnRlcmVkIHdpdGggTWFnaWNOdW1iZXIgMHggYW5kIGxlbmd0aCAgYnl0ZXP8VRAALgAAACpWEAAMAAAANlYQAAYAAABFcnJvciB3aGlsZSByZWFkaW5nIHRoZSBibG9jayBoZWFkZXJSZXNlcnZlZCBibG9jayBvY2N1cmVkLiBUaGlzIGlzIGNvbnNpZGVyZWQgY29ycnVwdGlvbiBieSB0aGUgZG9jdW1lbnRhdGlvbkVycm9yIGdldHRpbmcgYmxvY2sgdHlwZTogwlYQABoAAABFcnJvciBnZXR0aW5nIGJsb2NrIGNvbnRlbnQgc2l6ZTogAADkVhAAIgAAAEludmFsaWQgQmxvY2t0eXBlIG51bWJlci4gSXM6ICBTaG91bGQgYmUgb25lIG9mOiAwLCAxLCAyLCAzICgzIGlzIHJlc2VydmVkIHRob3VnaAAAABBXEAAeAAAALlcQADMAAAAAAAIAQmxvY2tzaXplIHdhcyBiaWdnZXIgdGhhbiB0aGUgYWJzb2x1dGUgbWF4aW11bSAgKDEyOGtiKS4gSXM6IAAAAHhXEAAvAAAAp1cQAA4AAABFcnJvciB3aGlsZSByZWFkaW5nIHRoZSBibG9jayBjb250ZW50OiAAyFcQACcAAABNYWxmb3JtZWQgc2VjdGlvbiBoZWFkZXIuIFNheXMgbGl0ZXJhbHMgd291bGQgYmUgdGhpcyBsb25nOiAgYnV0IHRoZXJlIGFyZSBvbmx5ICBieXRlcyBsZWZ0APhXEAA8AAAANFgQABQAAABIWBAACwAAAENhbid0IGRlY29kZSBuZXh0IGJsb2NrIGlmIGZhaWxlZCBhbG9uZyB0aGUgd2F5LiBSZXN1bHRzIHdpbGwgYmUgbm9uc2Vuc2VDYW4ndCBkZWNvZGUgbmV4dCBibG9jayBib2R5LCB3aGlsZSBleHBlY3RpbmcgdG8gZGVjb2RlIHRoZSBoZWFkZXIgb2YgdGhlIHByZXZpb3VzIGJsb2NrLiBSZXN1bHRzIHdpbGwgYmUgbm9uc2Vuc2VFcnJvciB3aGlsZSByZWFkaW5nIGJ5dGVzIGZvciA6IAAnWRAAHgAAAEVZEAACAAAATmVlZCAgYnl0ZXMgZnJvbSB0aGUgZGljdGlvbmFyeSBidXQgaXQgaXMgb25seSAgYnl0ZXMgbG9uZwAAWFkQAAUAAABdWRAAKgAAAIdZEAALAAAAb2Zmc2V0OiAgYmlnZ2VyIHRoYW4gYnVmZmVyOiAAAACsWRAACAAAALRZEAAVAAAAQmFkIG1hZ2ljX251bSBhdCBzdGFydCBvZiB0aGUgZGljdGlvbmFyeTsgR290OiAsIEV4cGVjdGVkOiAA3FkQAC8AAAALWhAADAAAADekMOxTcGVjaWZpZWQgd2luZG93X3NpemUgaXMgdG9vIGJpZzsgUmVxdWVzdGVkOiAsIE1heDogLFoQAC0AAABZWhAABwAAAEZhaWxlZCB0byBwYXJzZS9kZWNvZGUgYmxvY2sgYm9keTogAHBaEAAjAAAARmFpbGVkIHRvIHBhcnNlIGJsb2NrIGhlYWRlcjogAACcWhAAHgAAAEZhaWxlZCB0byByZWFkIGNoZWNrc3VtOiAAAADEWhAAGQAAAERlY29kZXIgbXVzdCBpbml0aWFsaXplZCBvciByZXNldCBiZWZvcmUgdXNpbmcgaXREZWNvZGVyIGVuY291bnRlcmVkIGVycm9yIHdoaWxlIGluaXRpYWxpemluZzogABlbEAAuAAAARGVjb2RlciBlbmNvdW50ZXJlZCBlcnJvciB3aGlsZSBkcmFpbmluZyB0aGUgZGVjb2RlYnVmZmVyOiAAUFsQADsAAABGYWlsZWQgdG8gc2tpcCBieXRlcyBmb3IgdGhlIGxlbmd0aCBnaXZlbiBpbiB0aGUgZnJhbWUgaGVhZGVyVGFyZ2V0IG11c3QgaGF2ZSBhdCBsZWFzdCBhcyBtYW55IGJ5dGVzIGFzIHRoZSBjb250ZW50c2l6ZSBvZiB0aGUgZnJhbWUgcmVwb3J0c0ZyYW1lIGhlYWRlciBzcGVjaWZpZWQgZGljdGlvbmFyeSBpZCAweCB0aGF0IHdhc250IHByb3ZpZGVkIGJ5IGFkZF9kaWN0KCkgb3IgcmVzZXRfd2l0aF9kaWN0KCkAACBcEAAnAAAAR1wQADcAAABjb21wcmVzc2VkIHNpemUgd2FzIG5vbmUgZXZlbiB0aG91Z2ggaXQgbXVzdCBiZSBzZXQgdG8gc29tZXRoaW5nIGZvciBjb21wcmVzc2VkIGxpdGVyYWxzbnVtX3N0cmVhbXMgd2FzIG5vbmUgZXZlbiB0aG91Z2ggaXQgbXVzdCBiZSBzZXQgdG8gc29tZXRoaW5nICgxIG9yIDQpIGZvciBjb21wcmVzc2VkIGxpdGVyYWxzVHJpZWQgdG8gcmV1c2UgaHVmZm1hbiB0YWJsZSBidXQgaXQgd2FzIG5ldmVyIGluaXRpYWxpemVkTmVlZCA2IGJ5dGVzIHRvIGRlY29kZSBqdW1wIGhlYWRlciwgZ290IAAAfl0QACgAAAA2VhAABgAAAE5lZWQgYXQgbGVhc3QgIGJ5dGVzIHRvIGRlY29kZSBsaXRlcmFscy4gSGF2ZTogALhdEAAOAAAAxl0QACEAAAA2VhAABgAAAFBhZGRpbmcgYXQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2Vfc2VjdGlvbiB3YXMgbW9yZSB0aGFuIGEgYnl0ZSBsb25nOiAgYml0cy4gUHJvYmFibHkgY2F1c2VkIGJ5IGRhdGEgY29ycnVwdGlvbgAAXhAARgAAAEZeEAApAAAAQml0c3RyZWFtIHdhcyByZWFkIHRpbGw6ICwgc2hvdWxkIGhhdmUgYmVlbjogAAAAgF4QABkAAACZXhAAFAAAAERpZCBub3QgZGVjb2RlIGVub3VnaCBsaXRlcmFsczogLCBTaG91bGQgaGF2ZSBiZWVuOiDAXhAAIAAAAOBeEAAUAAAAU2VxdWVuY2Ugd2FudHMgdG8gY29weSB1cCB0byBieXRlIC4gQnl0ZXMgaW4gbGl0ZXJhbHNidWZmZXI6IAAAAARfEAAiAAAAJl8QABsAAABJbGxlZ2FsIG9mZnNldDogMCBmb3VuZERvIG5vdCBzdXBwb3J0IG9mZnNldHMgYmlnZ2VyIHRoYW4gMTw8MzI7IGdvdDogAABrXxAALwAAAFJlYWQgYW4gb2Zmc2V0ID09IDAuIFRoYXQgaXMgYW4gaWxsZWdhbCB2YWx1ZSBmb3Igb2Zmc2V0c0J5dGVzdHJlYW0gZGlkIG5vdCBjb250YWluIGVub3VnaCBieXRlcyB0byBkZWNvZGUgbnVtX3NlcXVlbmNlc2NvbXByZXNzaW9uIG1vZGVzIGFyZSBub25lIGJ1dCB0aGV5IG11c3QgYmUgc2V0IHRvIHNvbWV0aGluZ05lZWQgYSBieXRlIHRvIHJlYWQgZm9yIFJMRSBsbCB0YWJsZU5lZWQgYSBieXRlIHRvIHJlYWQgZm9yIFJMRSBvZiB0YWJsZU5lZWQgYSBieXRlIHRvIHJlYWQgZm9yIFJMRSBtbCB0YWJsZUlsbGVnYWwgbGl0ZXJhbHNzZWN0aW9udHlwZS4gSXM6ICwgbXVzdCBiZSBpbjogMCwgMSwgMiwgMwAAAMRgEAAhAAAA5WAQABgAAABOb3QgZW5vdWdoIGJ5dGUgdG8gcGFyc2UgdGhlIGxpdGVyYWxzIHNlY3Rpb24gaGVhZGVyLiBIYXZlOiAsIE5lZWQ6IBBhEAA8AAAATGEQAAgAAABzb3VyY2UgbXVzdCBoYXZlIGF0IGxlYXN0ICBieXRlcyB0byBwYXJzZSBoZWFkZXI7IGdvdCAAAGRhEAAaAAAAfmEQABwAAAA2VhAABgAAAEFjY2xvZyBtdXN0IGJlIGF0IGxlYXN0IDFGb3VuZCBGU0UgYWNjX2xvZzogIGJpZ2dlciB0aGFuIGFsbG93ZWQgbWF4aW11bSBpbiB0aGlzIGNhc2U6IADNYRAAEwAAAOBhEAArAAAAVGhlIGNvdW50ZXIgKCkgZXhjZWVkZWQgdGhlIGV4cGVjdGVkIHN1bTogLiBUaGlzIG1lYW5zIGFuIGVycm9yIG9yIGNvcnJ1cHRlZCBkYXRhIAogHGIQAA0AAAApYhAAHQAAAEZiEAAqAAAAVGhlcmUgYXJlIHRvbyBtYW55IHN5bWJvbHMgaW4gdGhpcyBkaXN0cmlidXRpb246IC4gTWF4OiAyNTYAiGIQADEAAAC5YhAACgAAAFRyaWVkIHRvIHVzZSBhbiB1bmluaXRpYWxpemVkIHRhYmxlIVNvdXJjZSBuZWVkcyB0byBoYXZlIGF0IGxlYXN0IG9uZSBieXRlSGVhZGVyIHNheXMgdGhlcmUgc2hvdWxkIGJlICBieXRlcyBmb3IgdGhlIHdlaWdodHMgYnV0IHRoZXJlIGFyZSBvbmx5ICBieXRlcyBpbiB0aGUgc3RyZWFtHmMQABwAAAA6YxAAKgAAAGRjEAAUAAAATW9yZSB0aGFuIDI1NSB3ZWlnaHRzIGRlY29kZWQgKGdvdCAgd2VpZ2h0cykuIFN0cmVhbSBpcyBwcm9iYWJseSBjb3JydXB0ZWQAAJBjEAAjAAAAs2MQACcAAABDYW4ndCBidWlsZCBodWZmbWFuIHRhYmxlIHdpdGhvdXQgYW55IHdlaWdodHNMZWZ0b3ZlciBtdXN0IGJlIHBvd2VyIG9mIHR3byBidXQgaXM6IAAZZBAAJgAAAE5vdCBlbm91Z2ggYnl0ZXMgaW4gc3RyZWFtIHRvIGRlY29tcHJlc3Mgd2VpZ2h0cy4gSXM6IAAASGQQADYAAAAZVBAADQAAAEZTRSB0YWJsZSB1c2VkIG1vcmUgYnl0ZXM6ICB0aGFuIHdlcmUgbWVhbnQgdG8gYmUgdXNlZCBmb3IgdGhlIHdob2xlIHN0cmVhbSBvZiBodWZmbWFuIHdlaWdodHMgKCkAAACQZBAAGwAAAKtkEABFAAAA8GQQAAEAAABTb3VyY2UgbmVlZHMgdG8gaGF2ZSBhdCBsZWFzdCAgYnl0ZXMsIGdvdDogAAxlEAAeAAAAKmUQAA0AAAALQ2FudCBoYXZlIHdlaWdodDogIGJpZ2dlciB0aGFuIG1heF9udW1fYml0czogAABJZRAAEgAAAFtlEAAbAAAAbWF4X2JpdHMgZGVyaXZlZCBmcm9tIHdlaWdodHMgaXM6ICBzaG91bGQgYmUgbG93ZXIgdGhhbjogAAAAiGUQACIAAACqZRAAFwAAAENhbnQgc2VydmUgdGhpcyByZXF1ZXN0LiBUaGUgcmVhZGVyIGlzIGxpbWl0ZWQgdG8gIGJpdHMsIHJlcXVlc3RlZCAgYml0c9RlEAAyAAAABmYQABEAAAAXZhAABQAAAENhbid0IHJlYWQgIGJpdHMsIG9ubHkgaGF2ZSAgYml0cyBsZWZ0AAA0ZhAACwAAAD9mEAARAAAAUGYQAAoAAAAAAAAABAAAAAQAAADJAQAAAAAAAAQAAAAEAAAAygEAAFRvb01hbnlCaXRzbnVtX3JlcXVlc3RlZF9iaXRzbGltaXQAAAAAAAAEAAAABAAAAMsBAABOb3RFbm91Z2hSZW1haW5pbmdCaXRzcmVxdWVzdGVkcmVtYWluaW5nSW52YWxpZEZyYW1lQ29udGVudFNpemVGbGFnZ290AAAAAAAABAAAAAQAAADMAQAAV2luZG93VG9vQmlnV2luZG93VG9vU21hbGwAAAAAAAAEAAAABAAAAK4BAABGcmFtZURlc2NyaXB0b3JFcnJvckRpY3RJZFRvb1NtYWxsZXhwZWN0ZWRNaXNtYXRjaGVkRnJhbWVTaXplRnJhbWVTaXplSXNaZXJvSW52YWxpZEZyYW1lU2l6ZQAAAAAEAAAABAAAAM0BAABNYWdpY051bWJlclJlYWRFcnJvcgAAAAAEAAAABAAAAM4BAABCYWRNYWdpY051bWJlckZyYW1lRGVzY3JpcHRvclJlYWRFcnJvckludmFsaWRGcmFtZURlc2NyaXB0b3JXaW5kb3dEZXNjcmlwdG9yUmVhZEVycm9yRGljdGlvbmFyeUlkUmVhZEVycm9yRnJhbWVDb250ZW50U2l6ZVJlYWRFcnJvcgAAAAAABAAAAAQAAADPAQAAU2tpcEZyYW1lbWFnaWNfbnVtYmVybGVuZ3RoQmxvY2tDb250ZW50UmVhZEVycm9yTWFsZm9ybWVkU2VjdGlvbkhlYWRlcmV4cGVjdGVkX2xlbnJlbWFpbmluZ19ieXRlcwAAAAAAAAAEAAAABAAAALIBAABEZWNvbXByZXNzTGl0ZXJhbHNFcnJvcgAAAAAABAAAAAQAAACzAQAATGl0ZXJhbHNTZWN0aW9uUGFyc2VFcnJvcgAAAAAAAAAEAAAABAAAALQBAABTZXF1ZW5jZXNIZWFkZXJQYXJzZUVycm9yAAAAAAAAAAQAAAAEAAAAtQEAAERlY29kZVNlcXVlbmNlRXJyb3IAAAAAAAQAAAAEAAAAtgEAAEV4ZWN1dGVTZXF1ZW5jZXNFcnJvck5vdEVub3VnaEJ5dGVzSW5EaWN0aW9uYXJ5bmVlZE9mZnNldFRvb0JpZ29mZnNldGJ1Zl9sZW4AAAAABAAAAAQAAAC4AQAAQmFkTWFnaWNOdW0AAAAAAAQAAAAEAAAAuQEAAEZTRVRhYmxlRXJyb3IAAAAAAAAABAAAAAQAAAC6AQAASHVmZm1hblRhYmxlRXJyb3JNaXNzaW5nQ29tcHJlc3NlZFNpemVNaXNzaW5nTnVtU3RyZWFtcwAAAAAABAAAAAQAAADBAQAAR2V0Qml0c0Vycm9yAAAAAAQAAAAEAAAAwgEAAEh1ZmZtYW5EZWNvZGVyRXJyb3JVbmluaXRpYWxpemVkSHVmZm1hblRhYmxlTWlzc2luZ0J5dGVzRm9ySnVtcEhlYWRlck1pc3NpbmdCeXRlc0ZvckxpdGVyYWxzbmVlZGVkAAAAAAAABAAAAAQAAADQAQAARXh0cmFQYWRkaW5nc2tpcHBlZF9iaXRzAAAAAAQAAAAEAAAA0QEAAAAAAAAEAAAABAAAANIBAABCaXRzdHJlYW1SZWFkTWlzbWF0Y2hyZWFkX3RpbERlY29kZWRMaXRlcmFsQ291bnRNaXNtYXRjaGRlY29kZWQAAAAAAAQAAAAEAAAAxQEAAERlY29kZWJ1ZmZlckVycm9yTm90RW5vdWdoQnl0ZXNGb3JTZXF1ZW5jZXdhbnRlZGhhdmVaZXJvT2Zmc2V0AAAAAAAABAAAAAQAAADGAQAARlNFRGVjb2RlckVycm9yVW5zdXBwb3J0ZWRPZmZzZXRvZmZzZXRfY29kZU5vdEVub3VnaEJ5dGVzRm9yTnVtU2VxdWVuY2VzRXh0cmFCaXRzYml0c19yZW1haW5pbmdNaXNzaW5nQ29tcHJlc3Npb25Nb2RlTWlzc2luZ0J5dGVGb3JSbGVMbFRhYmxlTWlzc2luZ0J5dGVGb3JSbGVPZlRhYmxlTWlzc2luZ0J5dGVGb3JSbGVNbFRhYmxlSWxsZWdhbExpdGVyYWxTZWN0aW9uVHlwZU5vdEVub3VnaEJ5dGVzAAAAAAEAAAABAAAA0wEAAG5lZWRfYXRfbGVhc3RBY2NMb2dJc1plcm9BY2NMb2dUb29CaWdtYXgAAAAABAAAAAQAAADHAQAAUHJvYmFiaWxpdHlDb3VudGVyTWlzbWF0Y2hleHBlY3RlZF9zdW1zeW1ib2xfcHJvYmFiaWxpdGllc1Rvb01hbnlTeW1ib2xzVGFibGVJc1VuaW5pdGlhbGl6ZWRTb3VyY2VJc0VtcHR5Tm90RW5vdWdoQnl0ZXNGb3JXZWlnaHRzZ290X2J5dGVzZXhwZWN0ZWRfYnl0ZXNUb29NYW55V2VpZ2h0c01pc3NpbmdXZWlnaHRzTGVmdG92ZXJJc05vdEFQb3dlck9mMk5vdEVub3VnaEJ5dGVzVG9EZWNvbXByZXNzV2VpZ2h0c0ZTRVRhYmxlVXNlZFRvb01hbnlCeXRlc3VzZWRhdmFpbGFibGVfYnl0ZXNOb3RFbm91Z2hCeXRlc0luU291cmNlV2VpZ2h0QmlnZ2VyVGhhbk1heE51bUJpdHNNYXhCaXRzVG9vSGlnaC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnMAAABQbhAAbQAAACoCAAARAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcnV6c3RkLTAuOC4wL3NyYy9kZWNvZGluZy9iaXRfcmVhZGVyX3JldmVyc2UucnMAAADQbhAAcQAAADcAAABFAAAA0G4QAHEAAAA3AAAALwAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGXQbhAAcQAAAEYAAAANAAAA0G4QAHEAAABKAAAAHgAAAFRoaXMgaXMgYSBidWcgaW4gdGhlIHByb2dyYW0uIFRoZXJlIHNob3VsZCBvbmx5IGJlIHZhbHVlcyBiZXR3ZWVuIDAuLjMvVXNlcnMvZHlsYW4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9ydXpzdGQtMC44LjAvc3JjL2Jsb2Nrcy9saXRlcmFsc19zZWN0aW9uLnJzAPJvEABtAAAAewAAADQAAADybxAAbQAAAJAAAABXAAAA8m8QAG0AAACXAAAAKgAAAPJvEABtAAAAmAAAACoAAADybxAAbQAAAJsAAAAaAAAA8m8QAG0AAACoAAAAGgAAAPJvEABtAAAAtAAAAEQAAADybxAAbQAAALgAAABGAAAA8m8QAG0AAADAAAAAKgAAAPJvEABtAAAAwQAAACsAAADybxAAbQAAAMUAAABIAAAA8m8QAG0AAADNAAAAKgAAAPJvEABtAAAAzgAAACsAAADybxAAbQAAANMAAAAuAAAA8m8QAG0AAADUAAAALgAAAENhbnQgcmV0dXJuIHRoaXMgbWFueSBiaXRzL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcnV6c3RkLTAuOC4wL3NyYy9kZWNvZGluZy9iaXRfcmVhZGVyLnJzAGpxEABpAAAANgAAAA0AAABqcRAAaQAAAE8AAAAjAAAAYXNzZXJ0aW9uIGZhaWxlZDogbiAtIGJpdF9zaGlmdCA9PSBiaXRzX2luX2xhc3RfYnl0ZV9uZWVkZWQAanEQAGkAAABtAAAADQAAAGpxEABpAAAAcQAAAB8AAABqcRAAaQAAAGgAAAAkAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5pZHggJSA4ID09IDAAanEQAGkAAABkAAAADQAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaWR4ID09IG9sZF9pZHggKyBuAAAAanEQAGkAAAB3AAAACQAAAFNlcV9zdW06ICBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZGlmZmVyZW5jZSBpbiBidWZmZXJzaXplOiAAANByEAAJAAAA2XIQADEAAAAvVXNlcnMvZHlsYW4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9ydXpzdGQtMC44LjAvc3JjL2RlY29kaW5nL3NlcXVlbmNlX2V4ZWN1dGlvbi5ycwAAABxzEABxAAAALwAAAAUAAAAccxAAcQAAAAsAAAAkAAAAHHMQAHEAAAAVAAAANAAAAEFsbG9jYXRpbmcgbmV3IHNwYWNlIGZvciB0aGUgcmluZ2J1ZmZlciBmYWlsZWQvVXNlcnMvZHlsYW4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9ydXpzdGQtMC44LjAvc3JjL2RlY29kaW5nL3JpbmdidWZmZXIucnMA7nMQAGkAAABhAAAAIwAAAENvdWxkIG5vdCBjcmVhdGUgbGF5b3V0IGZvciB1OCBhcnJheSBvZiBzaXplIAAAAGh0EAAtAAAA7nMQAGkAAABaAAAAIQAAAO5zEABpAAAAtAAAABUAAADucxAAaQAAAL4AAAAVAAAA7nMQAGkAAAB3AQAAHQAAAO5zEABpAAAAzgEAABUAAAAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwDwdBAAawAAAKIAAAAZAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcnV6c3RkLTAuOC4wL3NyYy9kZWNvZGluZy9saXRlcmFsc19zZWN0aW9uX2RlY29kZXIucnMAbHUQAHcAAAAUAAAAIgAAAGx1EAB3AAAAGAAAAE0AAABsdRAAdwAAADQAAAAZAAAAbHUQAHcAAAByAAAAGAAAAGx1EAB3AAAAkQAAABQAAABhc3NlcnRpb24gZmFpbGVkOiBudW1fc3RyZWFtcyA9PSAxAABsdRAAdwAAAIAAAAAJAAAAbHUQAHcAAABFAAAAGQAAAC9Vc2Vycy9keWxhbi8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3J1enN0ZC0wLjguMC9zcmMvZGVjb2Rpbmcvc2VxdWVuY2Vfc2VjdGlvbl9kZWNvZGVyLnJzAHh2EAB3AAAAGAAAAB0AAAB4dhAAdwAAAHUAAAAQAAAAeHYQAHcAAADAAAAAEAAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGU6IElsbGVnYWwgbGl0ZXJhbCBsZW5ndGggY29kZSB3YXM6IAAgdxAASwAAAHh2EAB3AAAA+gAAAA4AAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlOiBJbGxlZ2FsIG1hdGNoIGxlbmd0aCBjb2RlIHdhczogAAAAhHcQAEkAAAB4dhAAdwAAABoBAAAOAAAABAAAAAMAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAEAAAABAAAAAQAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAMAAAACAAAAAQAAAAEAAAABAAAAAQAAAAEAAAD/////////////////////AQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAA//////////////////////////8BAAAABAAAAAMAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAA/////////////////////////////////////3h2EAB3AAAAdgEAABwAAAB4dhAAdwAAAFMBAAAcAAAAAQEBAQICAwMEBgcICQoLDA0ODxAQAAAAEgAAABQAAAAWAAAAGAAAABwAAAAgAAAAKAAAADAAAABAAAAAgAAAAAABAAAAAgAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAAABAAEBAQECAgMDBAQFBwgJCgsMDQ4PEAAAACMAAAAlAAAAJwAAACkAAAArAAAALwAAADMAAAA7AAAAQwAAAFMAAABjAAAAgwAAAAMBAAADAgAAAwQAAAMIAAADEAAAAyAAAANAAAADgAAAAwABAC9Vc2Vycy9keWxhbi8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3R3b3gtaGFzaC0yLjEuMC9zcmMveHhoYXNoNjQucnMAAACwehAAYQAAAFQAAAAfAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcnV6c3RkLTAuOC4wL3NyYy9kZWNvZGluZy9kZWNvZGVidWZmZXIucnMAJHsQAGsAAAAaAAAAHgAAACR7EABrAAAAnQAAADQAAAAkexAAawAAAOoAAAAeAAAAUmF3UkxFQ29tcHJlc3NlZFJlc2VydmVyZAAAAAAAAAAEAAAABAAAAMoBAAAAAAAABAAAAAQAAADQAQAAYXNzZXJ0aW9uIGZhaWxlZDogeCA+IDAvVXNlcnMvZHlsYW4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9ydXpzdGQtMC44LjAvc3JjL2h1ZmYwL2h1ZmYwX2RlY29kZXIucnMTfBAAaQAAADEAAAAFAAAAE3wQAGkAAAA+AAAAGgAAABN8EABpAAAAUAAAACkAAAATfBAAaQAAAGgAAAAWAAAAE3wQAGkAAABqAAAAEwAAABN8EABpAAAAawAAABgAAAATfBAAaQAAAGwAAAAbAAAAE3wQAGkAAAAdAQAANgAAABN8EABpAAAAHQEAACUAAAATfBAAaQAAAB8BAAA2AAAAE3wQAGkAAAAfAQAAJQAAABN8EABpAAAA6AAAACIAAAATfBAAaQAAAPIAAAAiAAAAE3wQAGkAAAD3AAAAJgAAABN8EABpAAAA7QAAACYAAAATfBAAaQAAAFcBAAASAAAAE3wQAGkAAABfAQAAGAAAABN8EABpAAAAZQEAABUAAAATfBAAaQAAAG8BAAAbAAAAE3wQAGkAAABxAQAAGgAAABN8EABpAAAAeAEAAB4AAAByYW5rX2lkeFswXTogIHNob3VsZCBiZTogAAAAzH0QAA0AAADZfRAADAAAABN8EABpAAAAdwEAAAkAAAATfBAAaQAAAH8BAAAsAAAAE3wQAGkAAACEAQAAMQAAABN8EABpAAAAiAEAACAAAAATfBAAaQAAAIkBAAAgAAAAE3wQAGkAAABzAQAARQAAABN8EABpAAAAdAEAACEAAAATfBAAaQAAAHMBAAAeAAAAE3wQAGkAAABhAQAAGwAAABN8EABpAAAATwEAACcAAAATfBAAaQAAAFQBAAAWAAAAL1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAqH4QAGsAAACiAAAAGQAAAC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzACR/EABrAAAAogAAABkAAABhc3NlcnRpb24gZmFpbGVkOiB4ID4gMC9Vc2Vycy9keWxhbi8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3J1enN0ZC0wLjguMC9zcmMvZnNlL2ZzZV9kZWNvZGVyLnJzt38QAGUAAAA9AAAABQAAALd/EABlAAAAWgAAACcAAAC3fxAAZQAAAGUAAAAnAAAAt38QAGUAAABwAAAAIwAAALd/EABlAAAAcQAAAB0AAAC3fxAAZQAAAOIAAAApAAAAt38QAGUAAADkAAAAMQAAALd/EABlAAAA5gAAADMAAABhc3NlcnRpb24gZmFpbGVkOiBuYiA8PSBzZWxmLmFjY3VyYWN5X2xvZwAAALd/EABlAAAA6wAAAA0AAAC3fxAAZQAAANIAAAAtAAAAt38QAGUAAADAAAAALQAAALd/EABlAAAAOQEAAEEAAAC3fxAAZQAAAB4BAAAnAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHJvYiA9PSAtMbd/EABlAAAAJAEAABUAAAAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy92ZWMvbW9kLnJzAAAARIEQAG0AAAA9CgAAJAAAAAAAAAAQAAAABAAAANQBAADVAQAA1gEAACAgICA6IAAAAQAAAAAAAADggRAAAgAAACAgICAgICAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2NvcmUvc3JjL3B0ci9tb2QucnMA+4EQAGwAAAALAgAAAQAAAC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvY29yZS9zcmMvc2xpY2UvaW5kZXgucnN4ghAAcAAAAEwDAAA0AAAAeIIQAHAAAABTAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAMoMQAGwAAAD7BwAAHQAAADKDEABsAAAAAwgAAB0AAAAygxAAbAAAAI0FAAAbAAAAL1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5ycwAAANCDEABtAAAAKgIAABEAAADXAQAADAAAAAQAAADYAQAA2QEAANoBAADdAQAADAAAAAQAAADeAQAA3wEAANoBAEGIicIAC4UJAQAAAOABAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5L1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAMeEEABsAAAA3woAAA4AAABFcnJvcgAAAMeEEABsAAAAjQUAABsAAABhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbinHhBAAbAAAAMAFAAANAAAAAAAAABAAAAAEAAAA1AEAANUBAADWAQAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYW55aG93LTEuMC45OC9zcmMvZXJyb3IucnPMhRAAXAAAAGcEAAAOAAAAAQAAAAAAAAA6IAAAQIYQAAIAAAAKCkNhdXNlZCBieToKCgpzdGFjayBiYWNrdHJhY2U6U3RhY2sgYmFja3RyYWNlOgprhhAAEQAAAFMvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2NvcmUvc3JjL2l0ZXIvdHJhaXRzL2l0ZXJhdG9yLnJzAACFhhAAeQAAALMHAAAJAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvanMtc3lzLTAuMy43Ny9zcmMvbGliLnJzAAAQhxAAWgAAAPsYAAABAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvd2FzbS1iaW5kZ2VuLTAuMi4xMDAvc3JjL2NvbnZlcnQvc2xpY2VzLnJzfIcQAGwAAAAkAQAADgAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkSnNWYWx1ZSgpACqIEAAIAAAAMogQAAEAAABMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAESIEAAqAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvb25jZV9jZWxsLTEuMjEuMy9zcmMvbGliLnJzAAAAeIgQAF0AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AADoiBAADgAAAHiIEABdAAAAegIAAA0AQZiSwgALlSMEAAAABAAAAPYBAAAvcnVzdGMvMDVmOTg0NmY4OTNiMDlhMWJlMWZjODU2MGUzM2ZjM2M4MTVjZmVjYi9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAJIkQAEoAAACiAAAAGQAAAC9ydXN0Yy8wNWY5ODQ2Zjg5M2IwOWExYmUxZmM4NTYwZTMzZmMzYzgxNWNmZWNiL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwCAiRAASwAAAI0FAAAbAAAAL3J1c3RjLzA1Zjk4NDZmODkzYjA5YTFiZTFmYzg1NjBlMzNmYzNjODE1Y2ZlY2IvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc9yJEABMAAAAKgIAABEAAAA6AAAA9wEAAAwAAAAEAAAA+AEAAPkBAAD6AQAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNy9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAFSKEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAABUihAAKQAAAK4EAAANAAAAQWNjZXNzRXJyb3JjYW5ub3QgYWNjZXNzIGEgVGhyZWFkIExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uOiAAB4sQAEgAAABsaWJyYXJ5L3N0ZC9zcmMvYmFja3RyYWNlLnJzb3BlcmF0aW9uIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBwbGF0Zm9ybXSLEAAoAAAAJAAAAAIAAACcixAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAFiLEAAcAAAAigEAAB0AAAD7AQAAEAAAAAQAAAD8AQAA/QEAAAEAAAAAAAAAZW50aXR5IG5vdCBmb3VuZHBlcm1pc3Npb24gZGVuaWVkY29ubmVjdGlvbiByZWZ1c2VkY29ubmVjdGlvbiByZXNldGhvc3QgdW5yZWFjaGFibGVuZXR3b3JrIHVucmVhY2hhYmxlY29ubmVjdGlvbiBhYm9ydGVkbm90IGNvbm5lY3RlZGFkZHJlc3MgaW4gdXNlYWRkcmVzcyBub3QgYXZhaWxhYmxlbmV0d29yayBkb3duYnJva2VuIHBpcGVlbnRpdHkgYWxyZWFkeSBleGlzdHNvcGVyYXRpb24gd291bGQgYmxvY2tub3QgYSBkaXJlY3RvcnlpcyBhIGRpcmVjdG9yeWRpcmVjdG9yeSBub3QgZW1wdHlyZWFkLW9ubHkgZmlsZXN5c3RlbSBvciBzdG9yYWdlIG1lZGl1bWZpbGVzeXN0ZW0gbG9vcCBvciBpbmRpcmVjdGlvbiBsaW1pdCAoZS5nLiBzeW1saW5rIGxvb3Apc3RhbGUgbmV0d29yayBmaWxlIGhhbmRsZWludmFsaWQgaW5wdXQgcGFyYW1ldGVyaW52YWxpZCBkYXRhdGltZWQgb3V0d3JpdGUgemVyb25vIHN0b3JhZ2Ugc3BhY2VzZWVrIG9uIHVuc2Vla2FibGUgZmlsZXF1b3RhIGV4Y2VlZGVkZmlsZSB0b28gbGFyZ2VyZXNvdXJjZSBidXN5ZXhlY3V0YWJsZSBmaWxlIGJ1c3lkZWFkbG9ja2Nyb3NzLWRldmljZSBsaW5rIG9yIHJlbmFtZXRvbyBtYW55IGxpbmtzaW52YWxpZCBmaWxlbmFtZWFyZ3VtZW50IGxpc3QgdG9vIGxvbmdvcGVyYXRpb24gaW50ZXJydXB0ZWR1bnN1cHBvcnRlZHVuZXhwZWN0ZWQgZW5kIG9mIGZpbGVvdXQgb2YgbWVtb3J5aW4gcHJvZ3Jlc3NvdGhlciBlcnJvcnVuY2F0ZWdvcml6ZWQgZXJyb3JPcwAAAAAABAAAAAQAAAD+AQAAY29kZQAAAAABAAAAAQAAAP8BAABraW5k9wEAAAwAAAAEAAAAAAIAAG1lc3NhZ2VLaW5kRXJyb3IAAAAACAAAAAQAAAABAgAAAAAAAAQAAAAEAAAAAgIAAEN1c3RvbWVycm9yIChvcyBlcnJvciApAAEAAAAAAAAAZ48QAAsAAAByjxAAAQAAADogY2Fubm90IHJlY3Vyc2l2ZWx5IGFjcXVpcmUgbXV0ZXgAAI6PEAAgAAAAbGlicmFyeS9zdGQvc3JjL3N5cy9zeW5jL211dGV4L25vX3RocmVhZHMucnO4jxAALAAAABMAAAAJAAAAbGlicmFyeS9zdGQvc3JjL3N5bmMvcG9pc29uL29uY2UucnMA9I8QACMAAACbAAAAMgAAAGxpYnJhcnkvc3RkL3NyYy9zeW5jL2xhenlfbG9jay5ycwAAACiQEAAhAAAA0QAAABMAAAA8dW5rbm93bj7vv71tZW1vcnkgYWxsb2NhdGlvbiBvZiAgYnl0ZXMgZmFpbGVkAABokBAAFQAAAH2QEAANAAAAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJznJAQABgAAABjAQAACQAAAAoAAAD3AQAADAAAAAQAAAADAgAAAAAAAAgAAAAEAAAABAIAAAAAAAAIAAAABAAAAAUCAAAGAgAABwIAAAgCAAAJAgAAEAAAAAQAAAAKAgAACwIAAAwCAAANAgAAbGlicmFyeS9zdGQvc3JjLy4uLy4uL2JhY2t0cmFjZS9zcmMvc3ltYm9saXplL21vZC5ycyCREAA0AAAAZwEAADAAAAABAAAAAAAAAIyPEAACAAAAIC0gAAEAAAAAAAAAdJEQAAMAAAAgICAgICAgICAgICAgICAgICAgYXQgAAA4ihAAAQAAAE5vdEZvdW5kUGVybWlzc2lvbkRlbmllZENvbm5lY3Rpb25SZWZ1c2VkQ29ubmVjdGlvblJlc2V0SG9zdFVucmVhY2hhYmxlTmV0d29ya1VucmVhY2hhYmxlQ29ubmVjdGlvbkFib3J0ZWROb3RDb25uZWN0ZWRBZGRySW5Vc2VBZGRyTm90QXZhaWxhYmxlTmV0d29ya0Rvd25Ccm9rZW5QaXBlQWxyZWFkeUV4aXN0c1dvdWxkQmxvY2tOb3RBRGlyZWN0b3J5SXNBRGlyZWN0b3J5RGlyZWN0b3J5Tm90RW1wdHlSZWFkT25seUZpbGVzeXN0ZW1GaWxlc3lzdGVtTG9vcFN0YWxlTmV0d29ya0ZpbGVIYW5kbGVJbnZhbGlkSW5wdXRJbnZhbGlkRGF0YVRpbWVkT3V0V3JpdGVaZXJvU3RvcmFnZUZ1bGxOb3RTZWVrYWJsZVF1b3RhRXhjZWVkZWRGaWxlVG9vTGFyZ2VSZXNvdXJjZUJ1c3lFeGVjdXRhYmxlRmlsZUJ1c3lEZWFkbG9ja0Nyb3NzZXNEZXZpY2VzVG9vTWFueUxpbmtzSW52YWxpZEZpbGVuYW1lQXJndW1lbnRMaXN0VG9vTG9uZ0ludGVycnVwdGVkVW5zdXBwb3J0ZWRVbmV4cGVjdGVkRW9mT3V0T2ZNZW1vcnlJblByb2dyZXNzT3RoZXJVbmNhdGVnb3JpemVkb3BlcmF0aW9uIHN1Y2Nlc3NmdWxPbmNlIGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWTakxAAKgAAAG9uZS10aW1lIGluaXRpYWxpemF0aW9uIG1heSBub3QgYmUgcGVyZm9ybWVkIHJlY3Vyc2l2ZWx5DJQQADgAAAAQAAAAEQAA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", import.meta.url));
  const A = Xt();
  (typeof g == "string" || typeof Request == "function" && g instanceof Request || typeof URL == "function" && g instanceof URL) && (g = fetch(g));
  const { instance: I, module: B } = await Tt(await g, A);
  return zt(I, B);
}
const HA = -9, jt = 9, TA = (jt - HA) / 254, Ot = 11, Pt = 11, X = 1 << Ot, WA = 1 << Pt, eB = 1;
function ig(g) {
  return g === "bool" || g === "bvec2" || g === "bvec3" || g === "bvec4";
}
function sg(g) {
  return g === "int" || g === "uint" || g === "float";
}
function wA(g) {
  return g === "int" || g === "ivec2" || g === "ivec3" || g === "ivec4";
}
function DA(g) {
  return g === "uint" || g === "uvec2" || g === "uvec3" || g === "uvec4";
}
function Yg(g) {
  return g === "float" || g === "vec2" || g === "vec3" || g === "vec4";
}
function aB(g) {
  return g === "mat2" || g === "mat2x2" || g === "mat2x3" || g === "mat2x4" || g === "mat3" || g === "mat3x2" || g === "mat3x3" || g === "mat3x4" || g === "mat4" || g === "mat4x2" || g === "mat4x3" || g === "mat4x4";
}
function $A(g) {
  return Yg(g) || aB(g);
}
function ug(g) {
  return g === "vec2" || g === "ivec2" || g === "uvec2";
}
function dg(g) {
  return g === "vec3" || g === "ivec3" || g === "uvec3";
}
function Ug(g) {
  return g === "vec4" || g === "ivec4" || g === "uvec4";
}
function _t(g) {
  return ug(g) || dg(g) || Ug(g);
}
function Ig(g) {
  return g === "mat2" || g === "mat2x2";
}
function Bg(g) {
  return g === "mat3" || g === "mat3x3";
}
function Qg(g) {
  return g === "mat4" || g === "mat4x4";
}
function nB(g) {
  switch (g) {
    case "vec2":
      return "float";
    case "vec3":
      return "float";
    case "vec4":
      return "float";
    case "ivec2":
      return "int";
    case "ivec3":
      return "int";
    case "ivec4":
      return "int";
    case "uvec2":
      return "uint";
    case "uvec3":
      return "uint";
    case "uvec4":
      return "uint";
    default:
      throw new Error(`Invalid vector type: ${g}`);
  }
}
function oB(g) {
  switch (g) {
    case "vec2":
    case "ivec2":
    case "uvec2":
      return 2;
    case "vec3":
    case "ivec3":
    case "uvec3":
      return 3;
    case "vec4":
    case "ivec4":
    case "uvec4":
      return 4;
    default:
      throw new Error(`Invalid vector type: ${g}`);
  }
}
function $t(g) {
  if (sg(g))
    return "float";
  if (ug(g))
    return "vec2";
  if (dg(g))
    return "vec3";
  if (Ug(g))
    return "vec4";
  throw new Error(`Invalid vector type: ${g}`);
}
function rB(g) {
  if (sg(g))
    return "uint";
  if (ug(g))
    return "uvec2";
  if (dg(g))
    return "uvec3";
  if (Ug(g))
    return "uvec4";
  throw new Error(`Invalid vector type: ${g}`);
}
function Ai(g) {
  if (sg(g))
    return "int";
  if (ug(g))
    return "ivec2";
  if (dg(g))
    return "ivec3";
  if (Ug(g))
    return "ivec4";
  throw new Error(`Invalid vector type: ${g}`);
}
function cB(g) {
  if (typeof g == "string")
    return g;
  if (typeof g == "object" && g.type)
    return g.type;
  throw new Error(`Invalid DynoType: ${String(g)}`);
}
function CA(g) {
  return Math.trunc(g).toString();
}
function EA(g) {
  return `${Math.max(0, Math.trunc(g)).toString()}u`;
}
function q(g) {
  return g === Number.POSITIVE_INFINITY ? "INFINITY" : g === Number.NEGATIVE_INFINITY ? "-INFINITY" : Number.isInteger(g) ? g.toFixed(1) : g.toString();
}
function v(g) {
  return g instanceof _A ? g.type : g.dynoOut().type;
}
class _A {
  constructor(A) {
    this.__isDynoValue = !0, this.type = A;
  }
}
class W extends _A {
  constructor(A, I) {
    super(A.outTypes[I]), this.dyno = A, this.key = I;
  }
}
class Dg extends _A {
  constructor(A, I) {
    super(A), this.literal = I;
  }
  getLiteral() {
    return this.literal;
  }
}
function _g(g, A) {
  return new Dg(g, A);
}
class hB extends Dg {
  constructor(A, I) {
    super(A, ""), this.value = I;
  }
  getLiteral() {
    const { type: A, value: I } = this;
    switch (A) {
      case "bool":
        return I ? "true" : "false";
      case "uint":
        return EA(I);
      case "int":
        return CA(I);
      case "float":
        return q(I);
      case "bvec2": {
        const B = I;
        return `bvec2(${B[0]}, ${B[1]})`;
      }
      case "uvec2": {
        if (I instanceof a.Vector2)
          return `uvec2(${EA(I.x)}, ${EA(I.y)})`;
        const B = I;
        return `uvec2(${EA(B[0])}, ${EA(B[1])})`;
      }
      case "ivec2": {
        if (I instanceof a.Vector2)
          return `ivec2(${CA(I.x)}, ${CA(I.y)})`;
        const B = I;
        return `ivec2(${CA(B[0])}, ${CA(B[1])})`;
      }
      case "vec2": {
        if (I instanceof a.Vector2)
          return `vec2(${q(I.x)}, ${q(I.y)})`;
        const B = I;
        return `vec2(${q(B[0])}, ${q(B[1])})`;
      }
      case "bvec3": {
        const B = I;
        return `bvec3(${B[0]}, ${B[1]}, ${B[2]})`;
      }
      case "uvec3": {
        if (I instanceof a.Vector3)
          return `uvec3(${EA(I.x)}, ${EA(I.y)}, ${EA(I.z)})`;
        const B = I;
        return `uvec3(${EA(B[0])}, ${EA(B[1])}, ${EA(B[2])})`;
      }
      case "ivec3": {
        if (I instanceof a.Vector3)
          return `ivec3(${CA(I.x)}, ${CA(I.y)}, ${CA(I.z)})`;
        const B = I;
        return `ivec3(${CA(B[0])}, ${CA(B[1])}, ${CA(B[2])})`;
      }
      case "vec3": {
        if (I instanceof a.Vector3)
          return `vec3(${q(I.x)}, ${q(I.y)}, ${q(I.z)})`;
        const B = I;
        return `vec3(${q(B[0])}, ${q(B[1])}, ${q(B[2])})`;
      }
      case "bvec4": {
        const B = I;
        return `bvec4(${B[0]}, ${B[1]}, ${B[2]}, ${B[3]})`;
      }
      case "uvec4": {
        if (I instanceof a.Vector4)
          return `uvec4(${EA(I.x)}, ${EA(I.y)}, ${EA(I.z)}, ${EA(I.w)})`;
        const B = I;
        return `uvec4(${EA(B[0])}, ${EA(B[1])}, ${EA(B[2])}, ${EA(B[3])})`;
      }
      case "ivec4": {
        if (I instanceof a.Vector4)
          return `ivec4(${CA(I.x)}, ${CA(I.y)}, ${CA(I.z)}, ${CA(I.w)})`;
        const B = I;
        return `ivec4(${CA(B[0])}, ${CA(B[1])}, ${CA(B[2])}, ${CA(B[3])})`;
      }
      case "vec4": {
        if (I instanceof a.Vector4)
          return `vec4(${q(I.x)}, ${q(I.y)}, ${q(I.z)}, ${q(I.w)})`;
        if (I instanceof a.Quaternion)
          return `vec4(${q(I.x)}, ${q(I.y)}, ${q(I.z)}, ${q(I.w)})`;
        const B = I;
        return `vec4(${q(B[0])}, ${q(B[1])}, ${q(B[2])}, ${q(B[3])})`;
      }
      case "mat2":
      case "mat2x2": {
        const B = I, Q = B instanceof a.Matrix2 ? B.elements : I, C = new Array(4).fill(0).map((E, t) => q(Q[t]));
        return `${A}(${C.join(", ")})`;
      }
      case "mat2x3": {
        const B = I, Q = new Array(6).fill(0).map((C, E) => q(B[E]));
        return `${A}(${Q.join(", ")})`;
      }
      case "mat2x4": {
        const B = I, Q = new Array(8).fill(0).map((C, E) => q(B[E]));
        return `${A}(${Q.join(", ")})`;
      }
      case "mat3":
      case "mat3x3": {
        const B = I, Q = B instanceof a.Matrix3 ? B.elements : I, C = new Array(9).fill(0).map((E, t) => q(Q[t]));
        return `${A}(${C.join(", ")})`;
      }
      case "mat3x2": {
        const B = I, Q = new Array(6).fill(0).map((C, E) => q(B[E]));
        return `${A}(${Q.join(", ")})`;
      }
      case "mat3x4": {
        const B = I, Q = new Array(12).fill(0).map((C, E) => q(B[E]));
        return `${A}(${Q.join(", ")})`;
      }
      case "mat4":
      case "mat4x4": {
        const B = I, Q = B instanceof a.Matrix4 ? B.elements : I, C = new Array(16).fill(0).map((E, t) => q(Q[t]));
        return `${A}(${C.join(", ")})`;
      }
      case "mat4x2": {
        const B = I, Q = new Array(8).fill(0).map((C, E) => q(B[E]));
        return `${A}(${Q.join(", ")})`;
      }
      case "mat4x3": {
        const B = I, Q = new Array(12).fill(0).map((C, E) => q(B[E]));
        return `${A}(${Q.join(", ")})`;
      }
      default:
        throw new Error(`Type not implemented: ${String(A)}`);
    }
  }
}
function gA(g, A) {
  return new hB(g, A);
}
function Ng(g) {
  const A = String(g);
  if (ig(g))
    return `${A}(false)`;
  if ($A(g))
    return `${A}(0.0)`;
  if (wA(g))
    return `${A}(0)`;
  if (DA(g))
    return `${A}(0u)`;
  throw new Error(`Type not implemented: ${A}`);
}
function gi(g) {
  const A = String(g);
  if (ig(g))
    return `${A}(true)`;
  if ($A(g))
    return `${A}(1.0)`;
  if (wA(g))
    return `${A}(1)`;
  if (DA(g))
    return `${A}(1u)`;
  throw new Error(`Type not implemented: ${A}`);
}
function Ii(g) {
  const A = String(g);
  if (ig(g))
    return `${A}(true)`;
  if ($A(g))
    return `${A}(-1.0)`;
  if (wA(g))
    return `${A}(-1)`;
  if (DA(g))
    return `${A}(0xFFFFFFFFu)`;
  throw new Error(`Type not implemented: ${A}`);
}
const AB = "    ";
class wB {
  constructor({ indent: A } = {}) {
    this.globals = /* @__PURE__ */ new Set(), this.statements = [], this.uniforms = {}, this.declares = /* @__PURE__ */ new Set(), this.updaters = [], this.sequence = 0, this.indent = AB, this.indent = A ?? AB;
  }
  nextSequence() {
    return this.sequence++;
  }
}
class T {
  constructor({
    inTypes: A,
    outTypes: I,
    inputs: B,
    update: Q,
    globals: C,
    statements: E,
    generate: t
  }) {
    this.inTypes = A ?? {}, this.outTypes = I ?? {}, this.inputs = B ?? {}, this.update = Q, this.globals = C, this.statements = E, this.generate = t ?? (({ inputs: i, outputs: e, compile: n }) => {
      var s, o;
      return {
        globals: (s = this.globals) == null ? void 0 : s.call(this, { inputs: i, outputs: e, compile: n }),
        statements: (o = this.statements) == null ? void 0 : o.call(this, { inputs: i, outputs: e, compile: n })
      };
    });
  }
  get outputs() {
    const A = {};
    for (const I in this.outTypes)
      A[I] = new W(this, I);
    return A;
  }
  apply(A) {
    return Object.assign(this.inputs, A), this.outputs;
  }
  compile({
    inputs: A,
    outputs: I,
    compile: B
  }) {
    const Q = [
      `// ${this.constructor.name}(${Object.values(A).join(", ")}) => (${Object.values(I).join(", ")})`
    ], C = [];
    for (const e in I) {
      const n = I[e];
      n && !B.declares.has(n) && (B.declares.add(n), C.push(e));
    }
    const { globals: E, statements: t, uniforms: i } = this.generate({
      inputs: A,
      outputs: I,
      compile: B
    });
    for (const e of E ?? [])
      B.globals.add(e);
    for (const e in i)
      B.uniforms[e] = i[e];
    this.update && B.updaters.push(this.update);
    for (const e of C) {
      const n = I[e];
      n && (B.uniforms[n] || Q.push(`${ZI(n, this.outTypes[e])};`));
    }
    return t != null && t.length && (Q.push("{"), Q.push(...t.map((e) => B.indent + e)), Q.push("}")), Q;
  }
}
class qA extends T {
  constructor({
    inTypes: A,
    outTypes: I,
    inputs: B,
    update: Q,
    globals: C,
    construct: E
  }) {
    super({
      inTypes: A,
      outTypes: I,
      inputs: B,
      update: Q,
      globals: C,
      generate: (t) => this.generateBlock(t)
    }), this.construct = E;
  }
  generateBlock({
    inputs: A,
    outputs: I,
    compile: B
  }) {
    var c, h;
    const Q = {}, C = {};
    for (const w in A)
      A[w] != null && (Q[w] = new Dg(this.inTypes[w], A[w]));
    for (const w in I)
      I[w] != null && (C[w] = new _A(this.outTypes[w]));
    const E = { roots: [] }, t = this.construct(Q, C, E);
    for (const w of ((c = this.globals) == null ? void 0 : c.call(this, { inputs: A, outputs: I, compile: B })) ?? [])
      B.globals.add(w);
    const i = [], e = /* @__PURE__ */ new Map();
    function n(w, D, y) {
      let l = e.get(w);
      if (!l) {
        l = {
          sequence: B.nextSequence(),
          outNames: /* @__PURE__ */ new Map(),
          newOuts: /* @__PURE__ */ new Set()
        }, e.set(w, l);
        for (const d in w.inputs) {
          let u = w.inputs[d];
          for (; u; ) {
            if (u instanceof _A) {
              u instanceof W && n(u.dyno, u.key);
              break;
            }
            u = u.dynoOut();
          }
        }
        i.push(w);
      }
      D && (y || l.newOuts.add(D), l.outNames.set(D, y ?? `${D}_${l.sequence}`));
    }
    for (const w of E.roots)
      n(w);
    for (const w in C) {
      let D = (t == null ? void 0 : t[w]) ?? C[w];
      for (; D; ) {
        if (D instanceof _A) {
          D instanceof W && n(D.dyno, D.key, I[w]);
          break;
        }
        D = D.dynoOut();
      }
      C[w] = D;
    }
    const s = [];
    for (const w of i) {
      const D = {}, y = {};
      for (const u in w.inputs) {
        let p = w.inputs[u];
        for (; p; ) {
          if (p instanceof _A) {
            if (p instanceof Dg)
              D[u] = p.getLiteral();
            else if (p instanceof W) {
              const m = (h = e.get(p.dyno)) == null ? void 0 : h.outNames.get(p.key);
              if (!m)
                throw new Error(
                  `Source not found for ${p.dyno.constructor.name}.${p.key}`
                );
              D[u] = m;
            }
            break;
          }
          p = p.dynoOut();
        }
      }
      const l = e.get(w) ?? { outNames: /* @__PURE__ */ new Map() };
      for (const [u, p] of l.outNames.entries())
        y[u] = p;
      const d = w.compile({ inputs: D, outputs: y, compile: B });
      s.push(d);
    }
    const o = [];
    for (const w in I)
      C[w] instanceof Dg && o.push(
        `${I[w]} = ${C[w].getLiteral()};`
      );
    return o.length > 0 && s.push(o), { statements: s.flatMap((w, D) => D === 0 ? w : ["", ...w]) };
  }
}
function YA(g, A, I, { update: B, globals: Q } = {}) {
  return new qA({ inTypes: g, outTypes: A, construct: I, update: B, globals: Q });
}
function xg({
  inTypes: g,
  outTypes: A,
  inputs: I,
  update: B,
  globals: Q,
  statements: C,
  generate: E
}) {
  return new T({
    inTypes: g,
    outTypes: A,
    inputs: I,
    update: B,
    globals: Q,
    statements: C,
    generate: E
  });
}
function ZI(g, A, I) {
  const B = typeof A == "string" ? A : A.type;
  if (!B)
    throw new Error(`Invalid DynoType: ${String(A)}`);
  return `${B} ${g}${I != null ? `[${I}]` : ""}`;
}
function mA(g) {
  var C;
  let A = !1;
  const I = g.split(`
`).map((E) => {
    const t = E.trimEnd();
    return A ? t : t.length > 0 ? (A = !0, t) : null;
  }).filter((E) => E != null);
  for (; I.length > 0 && I[I.length - 1].length === 0; )
    I.pop();
  if (I.length === 0)
    return [];
  const B = (C = I[0].match(/^\s*/)) == null ? void 0 : C[0];
  if (!B)
    return I;
  const Q = new RegExp(`^${B}`);
  return I.map((E) => E.replace(Q, ""));
}
function aA(g) {
  return mA(g).join(`
`);
}
class R extends T {
  constructor({
    a: A,
    outKey: I,
    outTypeFunc: B
  }) {
    const Q = { a: v(A) }, C = B(v(A)), E = { [I]: C };
    super({ inTypes: Q, outTypes: E, inputs: { a: A } }), this.outKey = I;
  }
  dynoOut() {
    return new W(this, this.outKey);
  }
}
class O extends T {
  constructor({
    a: A,
    b: I,
    outKey: B,
    outTypeFunc: Q
  }) {
    const C = { a: v(A), b: v(I) }, E = Q(v(A), v(I)), t = { [B]: E };
    super({ inTypes: C, outTypes: t, inputs: { a: A, b: I } }), this.outKey = B;
  }
  dynoOut() {
    return new W(this, this.outKey);
  }
}
class eg extends T {
  constructor({
    a: A,
    b: I,
    c: B,
    outKey: Q,
    outTypeFunc: C
  }) {
    const E = { a: v(A), b: v(I), c: v(B) }, t = C(v(A), v(I), v(B)), i = { [Q]: t };
    super({ inTypes: E, outTypes: i, inputs: { a: A, b: I, c: B } }), this.outKey = Q;
  }
  dynoOut() {
    return new W(this, this.outKey);
  }
}
const BA = { type: "Gsplat" }, Lg = { type: "PackedSplats" }, Bi = (g) => new lB({ packedSplats: g }), mg = (g, A) => new uB({ packedSplats: g, index: A }), DB = (g, A, I, B) => new dB({ packedSplats: g, index: A, base: I, count: B }), pg = (g) => new GB({ gsplat: g }), lg = ({
  gsplat: g,
  flags: A,
  index: I,
  center: B,
  scales: Q,
  quaternion: C,
  rgba: E,
  rgb: t,
  opacity: i,
  x: e,
  y: n,
  z: s,
  r: o,
  g: r,
  b: c
}) => new MB({
  gsplat: g,
  flags: A,
  index: I,
  center: B,
  scales: Q,
  quaternion: C,
  rgba: E,
  rgb: t,
  opacity: i,
  x: e,
  y: n,
  z: s,
  r: o,
  g: r,
  b: c
}), Qi = (g) => new pB({ gsplat: g }), qI = (g, {
  scale: A,
  rotate: I,
  translate: B,
  recolor: Q
}) => new kB({ gsplat: g, scale: A, rotate: I, translate: B, recolor: Q }), pA = aA(`
  struct Gsplat {
    vec3 center;
    uint flags;
    vec3 scales;
    int index;
    vec4 quaternion;
    vec4 rgba;
  };
  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;

  bool isGsplatActive(uint flags) {
    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;
  }
`), sI = aA(`
  struct PackedSplats {
    usampler2DArray texture;
    int numSplats;
  };
`);
class lB extends R {
  constructor({
    packedSplats: A
  }) {
    super({ a: A, outKey: "numSplats", outTypeFunc: () => "int" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.numSplats} = ${I.a}.numSplats;`
    ];
  }
}
const yB = aA(`
  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {
    if ((index >= 0) && (index < numSplats)) {
      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);
      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);
      return true;
    } else {
      return false;
    }
  }
`);
class uB extends T {
  constructor({
    packedSplats: A,
    index: I
  }) {
    super({
      inTypes: { packedSplats: Lg, index: "int" },
      outTypes: { gsplat: BA },
      inputs: { packedSplats: A, index: I },
      globals: () => [pA, sI, yB],
      statements: ({ inputs: B, outputs: Q }) => {
        const { gsplat: C } = Q;
        if (!C)
          return [];
        const { packedSplats: E, index: t } = B;
        let i;
        return E && t ? i = mA(`
            if (readPackedSplat(${E}.texture, ${E}.numSplats, ${t}, ${C})) {
              bool zeroSize = all(equal(${C}.scales, vec3(0.0, 0.0, 0.0)));
              ${C}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
            } else {
              ${C}.flags = 0u;
            }
          `) : i = [`${C}.flags = 0u;`], i.push(`${C}.index = ${t ?? "0"};`), i;
      }
    });
  }
  dynoOut() {
    return new W(this, "gsplat");
  }
}
class dB extends T {
  constructor({
    packedSplats: A,
    index: I,
    base: B,
    count: Q
  }) {
    super({
      inTypes: {
        packedSplats: Lg,
        index: "int",
        base: "int",
        count: "int"
      },
      outTypes: { gsplat: BA },
      inputs: { packedSplats: A, index: I, base: B, count: Q },
      globals: () => [pA, sI, yB],
      statements: ({ inputs: C, outputs: E }) => {
        const { gsplat: t } = E;
        if (!t)
          return [];
        const { packedSplats: i, index: e, base: n, count: s } = C;
        let o;
        return i && e && n && s ? o = mA(`
            ${t}.flags = 0u;
            if ((${e} >= ${n}) && (${e} < (${n} + ${s}))) {
              if (readPackedSplat(${i}.texture, ${i}.numSplats, ${e}, ${t})) {
                bool zeroSize = all(equal(${t}.scales, vec3(0.0, 0.0, 0.0)));
                ${t}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
              }
            }
          `) : o = [`${t}.flags = 0u;`], o.push(`${t}.index = ${e ?? "0"};`), o;
      }
    });
  }
  dynoOut() {
    return new W(this, "gsplat");
  }
}
class GB extends T {
  constructor({ gsplat: A }) {
    super({
      inTypes: { gsplat: BA },
      outTypes: {
        flags: "uint",
        active: "bool",
        index: "int",
        center: "vec3",
        scales: "vec3",
        quaternion: "vec4",
        rgba: "vec4",
        rgb: "vec3",
        opacity: "float",
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      },
      inputs: { gsplat: A },
      globals: () => [pA],
      statements: ({ inputs: I, outputs: B }) => {
        const { gsplat: Q } = I, {
          flags: C,
          active: E,
          index: t,
          center: i,
          scales: e,
          quaternion: n,
          rgba: s,
          rgb: o,
          opacity: r,
          x: c,
          y: h,
          z: w,
          r: D,
          g: y,
          b: l
        } = B;
        return [
          C ? `${C} = ${Q ? `${Q}.flags` : "0u"};` : null,
          E ? `${E} = isGsplatActive(${Q ? `${Q}.flags` : "0u"});` : null,
          t ? `${t} = ${Q ? `${Q}.index` : "0"};` : null,
          i ? `${i} = ${Q ? `${Q}.center` : "vec3(0.0, 0.0, 0.0)"};` : null,
          e ? `${e} = ${Q ? `${Q}.scales` : "vec3(0.0, 0.0, 0.0)"};` : null,
          n ? `${n} = ${Q ? `${Q}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)"};` : null,
          s ? `${s} = ${Q ? `${Q}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)"};` : null,
          o ? `${o} = ${Q ? `${Q}.rgba.rgb` : "vec3(0.0, 0.0, 0.0)"};` : null,
          r ? `${r} = ${Q ? `${Q}.rgba.a` : "0.0"};` : null,
          c ? `${c} = ${Q ? `${Q}.center.x` : "0.0"};` : null,
          h ? `${h} = ${Q ? `${Q}.center.y` : "0.0"};` : null,
          w ? `${w} = ${Q ? `${Q}.center.z` : "0.0"};` : null,
          D ? `${D} = ${Q ? `${Q}.rgba.r` : "0.0"};` : null,
          y ? `${y} = ${Q ? `${Q}.rgba.g` : "0.0"};` : null,
          l ? `${l} = ${Q ? `${Q}.rgba.b` : "0.0"};` : null
        ].filter(Boolean);
      }
    });
  }
}
class MB extends T {
  constructor({
    gsplat: A,
    flags: I,
    index: B,
    center: Q,
    scales: C,
    quaternion: E,
    rgba: t,
    rgb: i,
    opacity: e,
    x: n,
    y: s,
    z: o,
    r,
    g: c,
    b: h
  }) {
    super({
      inTypes: {
        gsplat: BA,
        flags: "uint",
        index: "int",
        center: "vec3",
        scales: "vec3",
        quaternion: "vec4",
        rgba: "vec4",
        rgb: "vec3",
        opacity: "float",
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      },
      outTypes: { gsplat: BA },
      inputs: {
        gsplat: A,
        flags: I,
        index: B,
        center: Q,
        scales: C,
        quaternion: E,
        rgba: t,
        rgb: i,
        opacity: e,
        x: n,
        y: s,
        z: o,
        r,
        g: c,
        b: h
      },
      globals: () => [pA],
      statements: ({ inputs: w, outputs: D }) => {
        const { gsplat: y } = D;
        if (!y)
          return [];
        const {
          gsplat: l,
          flags: d,
          index: u,
          center: p,
          scales: m,
          quaternion: M,
          rgba: G,
          rgb: J,
          opacity: k,
          x: N,
          y: Y,
          z: F,
          r: f,
          g: U,
          b: L
        } = w;
        return [
          `${y}.flags = ${d ?? (l ? `${l}.flags` : "0u")};`,
          `${y}.index = ${u ?? (l ? `${l}.index` : "0")};`,
          `${y}.center = ${p ?? (l ? `${l}.center` : "vec3(0.0, 0.0, 0.0)")};`,
          `${y}.scales = ${m ?? (l ? `${l}.scales` : "vec3(0.0, 0.0, 0.0)")};`,
          `${y}.quaternion = ${M ?? (l ? `${l}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)")};`,
          `${y}.rgba = ${G ?? (l ? `${l}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)")};`,
          J ? `${y}.rgba.rgb = ${J};` : null,
          k ? `${y}.rgba.a = ${k};` : null,
          N ? `${y}.center.x = ${N};` : null,
          Y ? `${y}.center.y = ${Y};` : null,
          F ? `${y}.center.z = ${F};` : null,
          f ? `${y}.rgba.r = ${f};` : null,
          U ? `${y}.rgba.g = ${U};` : null,
          L ? `${y}.rgba.b = ${L};` : null
        ].filter(Boolean);
      }
    });
  }
  dynoOut() {
    return new W(this, "gsplat");
  }
}
const NB = aA(`
  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {
    float minScale = min(scales.x, min(scales.y, scales.z));
    vec3 normal;
    if (scales.z == minScale) {
      normal = vec3(0.0, 0.0, 1.0);
    } else if (scales.y == minScale) {
      normal = vec3(0.0, 1.0, 0.0);
    } else {
      normal = vec3(1.0, 0.0, 0.0);
    }
    return quatVec(quaternion, normal);
  }
`);
class pB extends R {
  constructor({ gsplat: A }) {
    super({ a: A, outKey: "normal", outTypeFunc: () => "vec3" }), this.globals = () => [pA, NB], this.statements = ({ inputs: I, outputs: B }) => [
      `${B.normal} = gsplatNormal(${I.a}.scales, ${I.a}.quaternion);`
    ];
  }
}
class kB extends T {
  constructor({
    gsplat: A,
    scale: I,
    rotate: B,
    translate: Q,
    recolor: C
  }) {
    super({
      inTypes: {
        gsplat: BA,
        scale: "float",
        rotate: "vec4",
        translate: "vec3",
        recolor: "vec4"
      },
      outTypes: { gsplat: BA },
      inputs: { gsplat: A, scale: I, rotate: B, translate: Q, recolor: C },
      globals: () => [pA],
      statements: ({ inputs: E, outputs: t, compile: i }) => {
        const { gsplat: e } = t;
        if (!e || !E.gsplat)
          return [];
        const { scale: n, rotate: s, translate: o, recolor: r } = E, c = i.indent;
        return [
          `${e} = ${E.gsplat};`,
          `if (isGsplatActive(${e}.flags)) {`,
          n ? `${c}${e}.center *= ${n};` : null,
          s ? `${c}${e}.center = quatVec(${s}, ${e}.center);` : null,
          o ? `${c}${e}.center += ${o};` : null,
          n ? `${c}${e}.scales *= ${n};` : null,
          s ? `${c}${e}.quaternion = quatQuat(${s}, ${e}.quaternion);` : null,
          r ? `${c}${e}.rgba *= ${r};` : null,
          "}"
        ].filter(Boolean);
      }
    });
  }
  dynoOut() {
    return new W(this, "gsplat");
  }
}
const FB = (g) => new RB({ gsplat: g }), Ci = (g) => new vI({ rgba8: g });
class RB extends T {
  constructor({ gsplat: A }) {
    super({
      inTypes: { gsplat: BA },
      inputs: { gsplat: A },
      globals: () => [pA],
      statements: ({ inputs: I, outputs: B }) => {
        const { output: Q } = B;
        if (!Q)
          return [];
        const { gsplat: C } = I;
        return C ? mA(`
            if (isGsplatActive(${C}.flags)) {
              ${Q} = packSplat(${C}.center, ${C}.scales, ${C}.quaternion, ${C}.rgba);
            } else {
              ${Q} = uvec4(0u, 0u, 0u, 0u);
            }
          `) : [`${Q} = uvec4(0u, 0u, 0u, 0u);`];
      }
    });
  }
  dynoOut() {
    return new W(this, "output");
  }
}
class vI extends T {
  constructor({ rgba8: A }) {
    super({
      inTypes: { rgba8: "vec4" },
      inputs: { rgba8: A },
      statements: ({ inputs: I, outputs: B }) => [
        `target = ${I.rgba8 ?? "vec4(0.0, 0.0, 0.0, 0.0)"};`
      ]
    });
  }
  dynoOut() {
    return new W(this, "rgba8");
  }
}
const Ei = (g, A, I) => new S({ key: g, type: A, value: I }), ti = (g = !1, A) => new $g({ key: A, value: g }), ii = (g = 0, A) => new JB({ key: A, value: g }), si = (g = 0, A) => new fg({ key: A, value: g }), bA = (g = 0, A) => new Cg({ key: A, value: g }), ei = (g, A) => new mB({ key: A, value: g }), ai = (g, A) => new fB({ key: A, value: g }), ni = (g, A) => new SB({ key: A, value: g }), oi = (g, A) => new YB({ key: A, value: g }), ri = (g, A) => new UB({ key: A, value: g }), ci = (g, A) => new xB({ key: A, value: g }), hi = (g, A) => new LB({ key: A, value: g }), zA = (g, A) => new yg({ key: A, value: g }), wi = (g, A) => new bB({ key: A, value: g }), Di = (g, A) => new HB({ key: A, value: g }), li = (g, A) => new KB({ key: A, value: g }), yi = (g, A) => new bg({ key: A, value: g }), ui = (g, A) => new ZB({ key: A, value: g }), di = (g, A) => new qB({ key: A, value: g }), Gi = (g, A) => new vB({ key: A, value: g }), Mi = (g, A) => new WB({ key: A, value: g }), Ni = (g, A) => new VB({ key: A, value: g }), pi = (g, A) => new TB({ key: A, value: g }), ki = (g, A) => new XB({ key: A, value: g }), Fi = (g, A) => new zB({ key: A, value: g }), Ri = (g, A) => new jB({ key: A, value: g }), Ji = (g, A) => new OB({ key: A, value: g }), mi = (g, A) => new PB({ key: A, value: g }), fi = (g, A) => new _B({ key: A, value: g }), Si = (g, A) => new $B({ key: A, value: g }), Yi = (g, A) => new AQ({ key: A, value: g }), Ui = (g, A) => new gQ({ key: A, value: g }), xi = (g, A) => new kg({ key: A, value: g }), Li = (g, A) => new IQ({ key: g, value: A }), bi = (g, A) => new BQ({ key: A, value: g }), Hi = (g, A) => new QQ({ key: A, value: g }), Ki = (g, A) => new CQ({ key: A, value: g }), Zi = (g, A) => new EQ({ key: A, value: g }), qi = (g, A) => new tQ({ key: A, value: g }), vi = (g, A) => new iQ({ key: A, value: g }), Wi = (g, A) => new sQ({ key: A, value: g }), Vi = (g, A) => new eQ({ key: A, value: g }), Ti = (g, A) => new aQ({ key: A, value: g }), Xi = (g, A) => new nQ({ key: A, value: g });
class S extends T {
  constructor({
    key: A,
    type: I,
    count: B,
    value: Q,
    update: C,
    globals: E
  }) {
    A = A ?? "value", super({
      outTypes: { [A]: I },
      update: () => {
        if (C) {
          const t = C(this.value);
          t !== void 0 && (this.value = t);
        }
        this.uniform.value = this.value;
      },
      generate: ({ inputs: t, outputs: i }) => {
        const e = (E == null ? void 0 : E({ inputs: t, outputs: i })) ?? [], n = {}, s = i[A];
        return s && (e.push(`uniform ${ZI(s, I, B)};`), n[s] = this.uniform), { globals: e, uniforms: n };
      }
    }), this.type = I, this.count = B, this.value = Q, this.uniform = { value: Q }, this.outKey = A;
  }
  dynoOut() {
    return new W(this, this.outKey);
  }
}
class $g extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "bool", value: I, update: B });
  }
}
class JB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "uint", value: I, update: B });
  }
}
class fg extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "int", value: I, update: B });
  }
}
class Cg extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "float", value: I, update: B });
  }
}
class mB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "bvec2", value: I, update: B });
  }
}
class fB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "uvec2", value: I, update: B });
  }
}
class SB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "ivec2", value: I, update: B });
  }
}
class YB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "vec2", value: I, update: B });
  }
}
class UB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "bvec3", value: I, update: B });
  }
}
class xB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "uvec3", value: I, update: B });
  }
}
class LB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "ivec3", value: I, update: B });
  }
}
class yg extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "vec3", value: I, update: B });
  }
}
class bB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "bvec4", value: I, update: B });
  }
}
class HB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "uvec4", value: I, update: B });
  }
}
class KB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "ivec4", value: I, update: B });
  }
}
class bg extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "vec4", value: I, update: B });
  }
}
class ZB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "mat2", value: I, update: B });
  }
}
class qB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "mat2x2", value: I, update: B });
  }
}
class vB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "mat2x3", value: I, update: B });
  }
}
class WB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "mat2x4", value: I, update: B });
  }
}
class VB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "mat3", value: I, update: B });
  }
}
class TB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "mat3x2", value: I, update: B });
  }
}
class XB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "mat3x3", value: I, update: B });
  }
}
class zB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "mat3x4", value: I, update: B });
  }
}
class jB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "mat4", value: I, update: B });
  }
}
class OB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "mat4x2", value: I, update: B });
  }
}
class PB extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "mat4x3", value: I, update: B });
  }
}
class _B extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "mat4x4", value: I, update: B });
  }
}
class $B extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "usampler2D", value: I, update: B });
  }
}
class AQ extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "isampler2D", value: I, update: B });
  }
}
class gQ extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "sampler2D", value: I, update: B });
  }
}
class kg extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "usampler2DArray", value: I, update: B });
  }
}
class IQ extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "isampler2DArray", value: I, update: B });
  }
}
class BQ extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "sampler2DArray", value: I, update: B });
  }
}
class QQ extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "usampler3D", value: I, update: B });
  }
}
class CQ extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "isampler3D", value: I, update: B });
  }
}
class EQ extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "sampler3D", value: I, update: B });
  }
}
class tQ extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "usamplerCube", value: I, update: B });
  }
}
class iQ extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "isamplerCube", value: I, update: B });
  }
}
class sQ extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "samplerCube", value: I, update: B });
  }
}
class eQ extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "sampler2DShadow", value: I, update: B });
  }
}
class aQ extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "sampler2DArrayShadow", value: I, update: B });
  }
}
class nQ extends S {
  constructor({
    key: A,
    value: I,
    update: B
  }) {
    super({ key: A, type: "samplerCubeShadow", value: I, update: B });
  }
}
var cA = Uint8Array, cg = Uint16Array, zi = Int32Array, oQ = new cA([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), rQ = new cA([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), ji = new cA([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), cQ = function(g, A) {
  for (var I = new cg(31), B = 0; B < 31; ++B)
    I[B] = A += 1 << g[B - 1];
  for (var Q = new zi(I[30]), B = 1; B < 30; ++B)
    for (var C = I[B]; C < I[B + 1]; ++C)
      Q[C] = C - I[B] << 5 | B;
  return { b: I, r: Q };
}, hQ = cQ(oQ, 2), wQ = hQ.b, Oi = hQ.r;
wQ[28] = 258, Oi[258] = 28;
var Pi = cQ(rQ, 0), _i = Pi.b, RI = new cg(32768);
for (var IA = 0; IA < 32768; ++IA) {
  var XA = (IA & 43690) >> 1 | (IA & 21845) << 1;
  XA = (XA & 52428) >> 2 | (XA & 13107) << 2, XA = (XA & 61680) >> 4 | (XA & 3855) << 4, RI[IA] = ((XA & 65280) >> 8 | (XA & 255) << 8) >> 1;
}
var Fg = function(g, A, I) {
  for (var B = g.length, Q = 0, C = new cg(A); Q < B; ++Q)
    g[Q] && ++C[g[Q] - 1];
  var E = new cg(A);
  for (Q = 1; Q < A; ++Q)
    E[Q] = E[Q - 1] + C[Q - 1] << 1;
  var t;
  if (I) {
    t = new cg(1 << A);
    var i = 15 - A;
    for (Q = 0; Q < B; ++Q)
      if (g[Q])
        for (var e = Q << 4 | g[Q], n = A - g[Q], s = E[g[Q] - 1]++ << n, o = s | (1 << n) - 1; s <= o; ++s)
          t[RI[s] >> i] = e;
  } else
    for (t = new cg(B), Q = 0; Q < B; ++Q)
      g[Q] && (t[Q] = RI[E[g[Q] - 1]++] >> 15 - g[Q]);
  return t;
}, Hg = new cA(288);
for (var IA = 0; IA < 144; ++IA)
  Hg[IA] = 8;
for (var IA = 144; IA < 256; ++IA)
  Hg[IA] = 9;
for (var IA = 256; IA < 280; ++IA)
  Hg[IA] = 7;
for (var IA = 280; IA < 288; ++IA)
  Hg[IA] = 8;
var DQ = new cA(32);
for (var IA = 0; IA < 32; ++IA)
  DQ[IA] = 5;
var $i = /* @__PURE__ */ Fg(Hg, 9, 1), As = /* @__PURE__ */ Fg(DQ, 5, 1), dI = function(g) {
  for (var A = g[0], I = 1; I < g.length; ++I)
    g[I] > A && (A = g[I]);
  return A;
}, fA = function(g, A, I) {
  var B = A / 8 | 0;
  return (g[B] | g[B + 1] << 8) >> (A & 7) & I;
}, GI = function(g, A) {
  var I = A / 8 | 0;
  return (g[I] | g[I + 1] << 8 | g[I + 2] << 16) >> (A & 7);
}, lQ = function(g) {
  return (g + 7) / 8 | 0;
}, zg = function(g, A, I) {
  return (A == null || A < 0) && (A = 0), (I == null || I > g.length) && (I = g.length), new cA(g.subarray(A, I));
}, gs = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], FA = function(g, A, I) {
  var B = new Error(A || gs[g]);
  if (B.code = g, Error.captureStackTrace && Error.captureStackTrace(B, FA), !I)
    throw B;
  return B;
}, Is = function(g, A, I, B) {
  var Q = g.length, C = 0;
  if (!Q || A.f && !A.l)
    return I || new cA(0);
  var E = !I, t = E || A.i != 2, i = A.i;
  E && (I = new cA(Q * 3));
  var e = function(nA) {
    var oA = I.length;
    if (nA > oA) {
      var H = new cA(Math.max(oA * 2, nA));
      H.set(I), I = H;
    }
  }, n = A.f || 0, s = A.p || 0, o = A.b || 0, r = A.l, c = A.d, h = A.m, w = A.n, D = Q * 8;
  do {
    if (!r) {
      n = fA(g, s, 1);
      var y = fA(g, s + 1, 3);
      if (s += 3, y)
        if (y == 1)
          r = $i, c = As, h = 9, w = 5;
        else if (y == 2) {
          var p = fA(g, s, 31) + 257, m = fA(g, s + 10, 15) + 4, M = p + fA(g, s + 5, 31) + 1;
          s += 14;
          for (var G = new cA(M), J = new cA(19), k = 0; k < m; ++k)
            J[ji[k]] = fA(g, s + k * 3, 7);
          s += m * 3;
          for (var N = dI(J), Y = (1 << N) - 1, F = Fg(J, N, 1), k = 0; k < M; ) {
            var f = F[fA(g, s, Y)];
            s += f & 15;
            var l = f >> 4;
            if (l < 16)
              G[k++] = l;
            else {
              var U = 0, L = 0;
              for (l == 16 ? (L = 3 + fA(g, s, 3), s += 2, U = G[k - 1]) : l == 17 ? (L = 3 + fA(g, s, 7), s += 3) : l == 18 && (L = 11 + fA(g, s, 127), s += 7); L--; )
                G[k++] = U;
            }
          }
          var K = G.subarray(0, p), Z = G.subarray(p);
          h = dI(K), w = dI(Z), r = Fg(K, h, 1), c = Fg(Z, w, 1);
        } else
          FA(1);
      else {
        var l = lQ(s) + 4, d = g[l - 4] | g[l - 3] << 8, u = l + d;
        if (u > Q) {
          i && FA(0);
          break;
        }
        t && e(o + d), I.set(g.subarray(l, u), o), A.b = o += d, A.p = s = u * 8, A.f = n;
        continue;
      }
      if (s > D) {
        i && FA(0);
        break;
      }
    }
    t && e(o + 131072);
    for (var QA = (1 << h) - 1, z = (1 << w) - 1, AA = s; ; AA = s) {
      var U = r[GI(g, s) & QA], $ = U >> 4;
      if (s += U & 15, s > D) {
        i && FA(0);
        break;
      }
      if (U || FA(2), $ < 256)
        I[o++] = $;
      else if ($ == 256) {
        AA = s, r = null;
        break;
      } else {
        var P = $ - 254;
        if ($ > 264) {
          var k = $ - 257, j = oQ[k];
          P = fA(g, s, (1 << j) - 1) + wQ[k], s += j;
        }
        var V = c[GI(g, s) & z], x = V >> 4;
        V || FA(3), s += V & 15;
        var Z = _i[x];
        if (x > 3) {
          var j = rQ[x];
          Z += GI(g, s) & (1 << j) - 1, s += j;
        }
        if (s > D) {
          i && FA(0);
          break;
        }
        t && e(o + 131072);
        var uA = o + P;
        if (o < Z) {
          var iA = C - Z, b = Math.min(Z, uA);
          for (iA + o < 0 && FA(3); o < b; ++o)
            I[o] = B[iA + o];
        }
        for (; o < uA; ++o)
          I[o] = I[o - Z];
      }
    }
    A.l = r, A.p = AA, A.b = o, A.f = n, r && (n = 1, A.m = h, A.d = c, A.n = w);
  } while (!n);
  return o != I.length && E ? zg(I, 0, o) : I.subarray(0, o);
}, Bs = /* @__PURE__ */ new cA(0), Qs = function(g) {
  (g[0] != 31 || g[1] != 139 || g[2] != 8) && FA(6, "invalid gzip data");
  var A = g[3], I = 10;
  A & 4 && (I += (g[10] | g[11] << 8) + 2);
  for (var B = (A >> 3 & 1) + (A >> 4 & 1); B > 0; B -= !g[I++])
    ;
  return I + (A & 2);
}, MI = /* @__PURE__ */ function() {
  function g(A, I) {
    typeof A == "function" && (I = A, A = {}), this.ondata = I;
    var B = A && A.dictionary && A.dictionary.subarray(-32768);
    this.s = { i: 0, b: B ? B.length : 0 }, this.o = new cA(32768), this.p = new cA(0), B && this.o.set(B);
  }
  return g.prototype.e = function(A) {
    if (this.ondata || FA(5), this.d && FA(4), !this.p.length)
      this.p = A;
    else if (A.length) {
      var I = new cA(this.p.length + A.length);
      I.set(this.p), I.set(A, this.p.length), this.p = I;
    }
  }, g.prototype.c = function(A) {
    this.s.i = +(this.d = A || !1);
    var I = this.s.b, B = Is(this.p, this.s, this.o);
    this.ondata(zg(B, I, this.s.b), this.d), this.o = zg(B, this.s.b - 32768), this.s.b = this.o.length, this.p = zg(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  }, g.prototype.push = function(A, I) {
    this.e(A), this.c(I);
  }, g;
}(), yQ = /* @__PURE__ */ function() {
  function g(A, I) {
    this.v = 1, this.r = 0, MI.call(this, A, I);
  }
  return g.prototype.push = function(A, I) {
    if (MI.prototype.e.call(this, A), this.r += A.length, this.v) {
      var B = this.p.subarray(this.v - 1), Q = B.length > 3 ? Qs(B) : 4;
      if (Q > B.length) {
        if (!I)
          return;
      } else this.v > 1 && this.onmember && this.onmember(this.r - B.length);
      this.p = B.subarray(Q), this.v = 0;
    }
    MI.prototype.c.call(this, I), this.s.f && !this.s.l && !I && (this.v = lQ(this.s.p) + 9, this.s = { i: 0 }, this.o = new cA(0), this.push(new cA(0), I));
  }, g;
}(), Cs = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), Es = 0;
try {
  Cs.decode(Bs, { stream: !0 }), Es = 1;
} catch {
}
const Kg = new Float32Array(1), eI = new Uint32Array(Kg.buffer);
function ts(g) {
  return Kg[0] = g, eI[0];
}
function is(g) {
  return eI[0] = g, Kg[0];
}
function Eg(g) {
  Kg[0] = g;
  const A = eI[0], I = A >> 31 & 1, B = A >> 23 & 255, Q = A & 8388607, C = I << 15;
  if (B === 255)
    return Q !== 0 ? C | 32767 : C | 31744;
  const E = B - 127 + 15;
  if (E >= 31)
    return C | 31744;
  if (E <= 0) {
    if (E < -10)
      return C;
    const i = (Q | 8388608) >> 1 - E + 13;
    return C | i;
  }
  const t = Q >> 13;
  return C | E << 10 | t;
}
function MA(g) {
  const A = g >> 15 & 1, I = g >> 10 & 31, B = g & 1023;
  let Q;
  if (I === 0)
    if (B === 0)
      Q = A << 31;
    else {
      let C = B, E = -14;
      for (; (C & 1024) === 0; )
        C <<= 1, E--;
      C &= 1023;
      const t = E + 127, i = C << 13;
      Q = A << 31 | t << 23 | i;
    }
  else if (I === 31)
    B === 0 ? Q = A << 31 | 2139095040 : Q = A << 31 | 2143289344;
  else {
    const C = I - 15 + 127, E = B << 13;
    Q = A << 31 | C << 23 | E;
  }
  return eI[0] = Q, Kg[0];
}
function VA(g) {
  return Math.max(0, Math.min(255, Math.round(g * 255)));
}
function jg(g) {
  return Math.max(-127, Math.min(127, Math.round(g * 127)));
}
function ss(g) {
  return g / 255;
}
function es(g) {
  return g / 127;
}
class as {
  // Create a DataCache with a given function that fetches data not in the cache.
  constructor({
    asyncFetch: A,
    maxItems: I = 5
  }) {
    this.asyncFetch = A, this.maxItems = I, this.items = [];
  }
  // Fetch data for the key, returning cached data if available.
  async getFetch(A) {
    const I = this.items.findIndex((Q) => Q.key === A);
    if (I >= 0) {
      const Q = this.items.splice(I, 1)[0];
      return this.items.push(Q), Q.data;
    }
    const B = await this.asyncFetch(A);
    for (this.items.push({ key: A, data: B }); this.items.length > this.maxItems; )
      this.items.shift();
    return B;
  }
}
function ns(g, A) {
  const I = Object.entries(g).map(([B, Q]) => [
    B,
    A(Q, B)
  ]);
  return Object.fromEntries(I);
}
function os(g, A) {
  const I = Object.entries(g).map(([B, Q]) => [B, A(Q, B)]).filter(([B, Q]) => Q !== void 0);
  return Object.fromEntries(I);
}
function uQ(g) {
  const A = [], I = /* @__PURE__ */ new Set();
  function B(Q) {
    Q && typeof Q == "object" && !I.has(Q) && (I.add(Q), Q instanceof ArrayBuffer ? A.push(Q) : ArrayBuffer.isView(Q) ? A.push(Q.buffer) : Array.isArray(Q) ? Q.forEach(B) : Object.values(Q).forEach(B));
  }
  return B(g), A;
}
function rs(g, A) {
  return new Array(g).fill(null).map((I, B) => A(B));
}
class dQ {
  constructor({
    // Allocate a new item with the given args
    allocate: A,
    // Dispose of an item (optional, if GC is enough)
    dispose: I,
    // Check if an existing item in the list is valid for the given args,
    // allowing you to store heterogeneous items in the list.
    valid: B
  }) {
    this.items = [], this.allocate = A, this.dispose = I, this.valid = B;
  }
  // Allocate a new item from the free list, first checking if a existing item
  // on the freelist is valid for the given args.
  alloc(A) {
    for (; ; ) {
      const I = this.items.pop();
      if (!I)
        break;
      if (this.valid(I, A))
        return I;
      this.dispose && this.dispose(I);
    }
    return this.allocate(A);
  }
  free(A) {
    this.items.push(A);
  }
  disposeAll() {
    let A;
    for (A = this.items.pop(); A; )
      this.dispose && this.dispose(A), A = this.items.pop();
  }
}
function JI(g, A, I, B, Q, C, E, t, i, e, n, s, o, r, c, h) {
  const w = VA(r), D = VA(c), y = VA(h), l = VA(o), d = WI(
    new a.Quaternion(i, e, n, s)
  ), u = d & 255, p = d >>> 8 & 255, m = d >>> 16 & 255, M = C === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(C) - HA) / TA) + 1
    )
  ), G = E === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(E) - HA) / TA) + 1
    )
  ), J = t === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(t) - HA) / TA) + 1
    )
  ), k = Eg(I), N = Eg(B), Y = Eg(Q), F = A * 4;
  g[F] = w | D << 8 | y << 16 | l << 24, g[F + 1] = k | N << 16, g[F + 2] = Y | u << 16 | p << 24, g[F + 3] = M | G << 8 | J << 16 | m << 24;
}
function cs(g, A, I, B, Q) {
  const C = Eg(I), E = Eg(B), t = Eg(Q), i = A * 4;
  g[i + 1] = C | E << 16, g[i + 2] = t | g[i + 2] & 4294901760;
}
function hs(g, A, I, B, Q) {
  const C = I === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(I) - HA) / TA) + 1
    )
  ), E = B === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(B) - HA) / TA) + 1
    )
  ), t = Q === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(Q) - HA) / TA) + 1
    )
  ), i = A * 4;
  g[i + 3] = C | E << 8 | t << 16 | g[i + 3] & 4278190080;
}
function ws(g, A, I, B, Q, C) {
  const E = WI(
    new a.Quaternion(I, B, Q, C)
  ), t = E & 255, i = E >>> 8 & 255, e = E >>> 16 & 255, n = A * 4;
  g[n + 2] = g[n + 2] & 65535 | t << 16 | i << 24, g[n + 3] = g[n + 3] & 16777215 | e << 24;
}
function Ds(g, A, I, B, Q) {
  const C = VA(I), E = VA(B), t = VA(Q), i = A * 4;
  g[i] = C | E << 8 | t << 16 | g[i] & 4278190080;
}
function ls(g, A, I) {
  const B = VA(I), Q = A * 4;
  g[Q] = g[Q] & 16777215 | B << 24;
}
const ys = new a.Vector3(), us = new a.Vector3(), ds = new a.Quaternion(), Gs = new a.Color(), Ms = {
  center: ys,
  scales: us,
  quaternion: ds,
  color: Gs,
  opacity: 0
};
function AI(g, A) {
  const I = Ms, B = A * 4, Q = g[B], C = g[B + 1], E = g[B + 2], t = g[B + 3];
  I.color.set(
    (Q & 255) / 255,
    (Q >>> 8 & 255) / 255,
    (Q >>> 16 & 255) / 255
  ), I.opacity = (Q >>> 24 & 255) / 255, I.center.set(
    MA(C & 65535),
    MA(C >>> 16 & 65535),
    MA(E & 65535)
  );
  const i = t & 255;
  I.scales.x = i === 0 ? 0 : Math.exp(HA + (i - 1) * TA);
  const e = t >>> 8 & 255;
  I.scales.y = e === 0 ? 0 : Math.exp(HA + (e - 1) * TA);
  const n = t >>> 16 & 255;
  I.scales.z = n === 0 ? 0 : Math.exp(HA + (n - 1) * TA);
  const s = E >>> 16 & 65535 | t >>> 8 & 16711680;
  return RQ(s, I.quaternion), I;
}
function dA(g) {
  const A = X, I = Math.max(
    eB,
    Math.min(WA, Math.ceil(g / A))
  ), B = Math.ceil(g / (A * I)), Q = A * I * B;
  return { width: A, height: I, depth: B, maxSplats: Q };
}
function Ns(g) {
  const A = X, I = Math.max(
    eB,
    Math.min(WA, Math.ceil(g / A))
  ), B = Math.ceil(g / (A * I));
  return A * I * B;
}
function ps() {
  return navigator.maxTouchPoints > 0 ? !0 : /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile/.test(
    navigator.userAgent
  );
}
function ks() {
  return /Android/.test(navigator.userAgent);
}
function Fs() {
  return /Oculus/.test(navigator.userAgent);
}
function Rs(g, A, I) {
  const B = new Uint8Array(A * 4);
  for (let Q = 0; Q < I / 2; Q++) {
    const C = Q * A * 4, E = (I - 1 - Q) * A * 4;
    B.set(g.subarray(C, C + A * 4)), g.set(
      g.subarray(E, E + A * 4),
      C
    ), g.set(B, E);
  }
  return g;
}
function Js(g, A, I) {
  const B = document.createElement("canvas");
  B.width = A, B.height = I;
  const Q = B.getContext("2d");
  if (!Q)
    throw new Error("Can't get 2d context");
  const C = Q.createImageData(A, I);
  return C.data.set(g), Q.putImageData(C, 0, 0), B.toDataURL("image/png");
}
function GQ(g) {
  const A = new a.Clock(g.autoStart);
  return A.startTime = g.startTime, A.oldTime = g.oldTime, A.elapsedTime = g.elapsedTime, A.running = g.running, A;
}
function ms(g) {
  return Object.fromEntries(
    Object.entries(g).filter(([A, I]) => I !== void 0)
  );
}
const MQ = aA(`
  precision highp float;

  in vec3 position;

  void main() {
    gl_Position = vec4(position.xy, 0.0, 1.0);
  }
`);
function NQ(g) {
  const A = new a.Vector3();
  for (const I of g)
    A.add(I);
  return A.divideScalar(g.length);
}
function pQ(g) {
  if (g.length === 0)
    return new a.Quaternion();
  const A = g[0].clone();
  for (let I = 1; I < g.length; I++)
    g[I].dot(g[0]) < 0 ? (A.x -= g[I].x, A.y -= g[I].y, A.z -= g[I].z, A.w -= g[I].w) : (A.x += g[I].x, A.y += g[I].y, A.z += g[I].z, A.w += g[I].w);
  return A.normalize();
}
function kQ(g, A) {
  const I = new a.Vector3(0, 0, 0).applyMatrix4(g), B = new a.Vector3(0, 0, 0).applyMatrix4(A), Q = new a.Vector3(0, 0, -1).applyMatrix4(g).sub(I).normalize(), C = new a.Vector3(0, 0, -1).applyMatrix4(A).sub(B).normalize(), E = I.distanceTo(B), t = Q.dot(C);
  return { distance: E, coincidence: t };
}
function fs({
  matrix1: g,
  matrix2: A,
  maxDistance: I
}) {
  const B = new a.Vector3(0, 0, 0).applyMatrix4(g), Q = new a.Vector3(0, 0, 0).applyMatrix4(A);
  return B.distanceTo(Q) <= I;
}
function Ss({
  matrix1: g,
  matrix2: A,
  maxDistance: I,
  minCoincidence: B
}) {
  const { distance: Q, coincidence: C } = kQ(g, A);
  return Q <= I && (B == null || C >= B);
}
function FQ(g, A) {
  const [I, B] = [new a.Vector3(), new a.Quaternion()], [Q, C] = [new a.Vector3(), new a.Quaternion()];
  g.decompose(I, B, new a.Vector3()), A.decompose(Q, C, new a.Vector3());
  const E = I.distanceTo(Q), t = Math.abs(B.dot(C));
  return { distance: E, coorient: t };
}
function gI({
  matrix1: g,
  matrix2: A,
  maxDistance: I,
  minCoorient: B
}) {
  const { distance: Q, coorient: C } = FQ(g, A);
  return Q <= I && (B == null || C >= B);
}
function Ys(g, A = 1e-3) {
  return Math.abs(g) < A ? 0 : Math.sign(g);
}
function Us(g) {
  const A = g.w < 0, I = jg(A ? -g.x : g.x), B = jg(A ? -g.y : g.y), Q = jg(A ? -g.z : g.z), C = I & 255, E = B & 255, t = Q & 255;
  return C | E << 8 | t << 16;
}
function xs(g, A) {
  const I = g << 24 >> 24, B = g << 16 >> 24, Q = g << 8 >> 24;
  A.set(I / 127, B / 127, Q / 127, 0);
  const C = A.x * A.x + A.y * A.y + A.z * A.z;
  return A.w = Math.sqrt(Math.max(0, 1 - C)), A;
}
function WI(g) {
  const A = g.clone().normalize();
  A.w < 0 && A.set(-A.x, -A.y, -A.z, -A.w);
  const I = 2 * Math.acos(A.w), B = Math.sqrt(
    A.x * A.x + A.y * A.y + A.z * A.z
  ), Q = B < 1e-6 ? new a.Vector3(1, 0, 0) : new a.Vector3(A.x, A.y, A.z).divideScalar(B), C = Math.abs(Q.x) + Math.abs(Q.y) + Math.abs(Q.z);
  let E = Q.x / C, t = Q.y / C;
  if (Q.z < 0) {
    const r = E;
    E = (1 - Math.abs(t)) * (E >= 0 ? 1 : -1), t = (1 - Math.abs(r)) * (t >= 0 ? 1 : -1);
  }
  const i = E * 0.5 + 0.5, e = t * 0.5 + 0.5, n = Math.round(i * 255), s = Math.round(e * 255);
  return Math.round(I * (255 / Math.PI)) << 16 | s << 8 | n;
}
function RQ(g, A) {
  const I = g & 255, B = g >>> 8 & 255, Q = g >>> 16 & 255, C = I / 255, E = B / 255;
  let t = (C - 0.5) * 2, i = (E - 0.5) * 2;
  const e = 1 - (Math.abs(t) + Math.abs(i)), n = Math.max(-e, 0);
  t += t >= 0 ? -n : n, i += i >= 0 ? -n : n;
  const s = new a.Vector3(t, i, e).normalize(), r = Q / 255 * Math.PI * 0.5, c = Math.sin(r), h = Math.cos(r);
  return A.set(s.x * c, s.y * c, s.z * c, h), A;
}
function Ls(g) {
  const A = g.clone().normalize(), I = 2 * (A.w * A.x + A.y * A.z), B = 1 - 2 * (A.x * A.x + A.y * A.y), Q = Math.atan2(I, B), C = 2 * (A.w * A.y - A.z * A.x), E = Math.abs(C) >= 1 ? Math.sign(C) * (Math.PI / 2) : Math.asin(C), t = 2 * (A.w * A.z + A.x * A.y), i = 1 - 2 * (A.y * A.y + A.z * A.z), e = Math.atan2(t, i), n = (Q + Math.PI) / (2 * Math.PI), s = (E + Math.PI) / (2 * Math.PI), o = (e + Math.PI) / (2 * Math.PI), r = Math.round(n * 255), c = Math.round(s * 255);
  return Math.round(o * 255) << 16 | c << 8 | r;
}
function bs(g, A) {
  const I = g & 255, B = g >>> 8 & 255, Q = g >>> 16 & 255, C = I / 255, E = B / 255, t = Q / 255, i = C * (2 * Math.PI) - Math.PI, e = E * (2 * Math.PI) - Math.PI, n = t * (2 * Math.PI) - Math.PI, s = Math.cos(i * 0.5), o = Math.sin(i * 0.5), r = Math.cos(e * 0.5), c = Math.sin(e * 0.5), h = Math.cos(n * 0.5), w = Math.sin(n * 0.5);
  return A.w = s * r * h + o * c * w, A.x = o * r * h - s * c * w, A.y = s * c * h + o * r * w, A.z = s * r * w - o * c * h, A.normalize(), A;
}
function Zg(g, A, I, B) {
  const Q = Math.max(-127, Math.min(127, g * 127)), C = Math.max(-127, Math.min(127, A * 127)), E = Math.max(-127, Math.min(127, I * 127)), t = Math.max(-127, Math.min(127, B * 127));
  return Q & 255 | (C & 255) << 8 | (E & 255) << 16 | (t & 255) << 24;
}
function Hs(g, A, I) {
  const B = A * 2;
  for (let Q = 0; Q < 9; ++Q) {
    const C = Math.max(-63, Math.min(63, I[Q] * 63)) & 127, E = Q * 7, t = E + 7, i = Math.floor(E / 32), e = E - i * 32, n = C << e & 4294967295;
    if (g[B + i] |= n, t > i * 32 + 32) {
      const s = C >>> 32 - e & 4294967295;
      g[B + i + 1] |= s;
    }
  }
}
function Ks(g, A, I) {
  g[A * 4 + 0] = Zg(
    I[0],
    I[1],
    I[2],
    I[3]
  ), g[A * 4 + 1] = Zg(
    I[4],
    I[5],
    I[6],
    I[7]
  ), g[A * 4 + 2] = Zg(
    I[8],
    I[9],
    I[10],
    I[11]
  ), g[A * 4 + 3] = Zg(
    I[12],
    I[13],
    I[14],
    0
  );
}
function Zs(g, A, I) {
  const B = A * 4;
  for (let Q = 0; Q < 21; ++Q) {
    const C = Math.max(-31, Math.min(31, I[Q] * 31)) & 63, E = Q * 6, t = E + 6, i = Math.floor(E / 32), e = E - i * 32, n = C << e & 4294967295;
    if (g[B + i] |= n, t > i * 32 + 32) {
      const s = C >>> 32 - e & 4294967295;
      g[B + i + 1] |= s;
    }
  }
}
function JQ(g, A) {
  const I = [];
  let B = 0, Q = null;
  const C = new yQ((i, e) => {
    if (I.push(i), B += i.length, e || B >= A) {
      const n = new Uint8Array(B);
      let s = 0;
      for (const o of I)
        n.set(o, s), s += o.length;
      Q = n.slice(0, A);
    }
  }), E = 1024;
  let t = 0;
  for (; Q == null && t < g.length; ) {
    const i = g.slice(t, t + E);
    C.push(i, !1), t += E;
  }
  if (Q == null && (C.push(new Uint8Array(), !0), Q == null))
    throw new Error("Failed to decompress partial gzip");
  return Q;
}
class mQ {
  constructor({
    fileBytes: A,
    chunkBytes: I = 64 * 1024
  }) {
    this.fileBytes = A, this.chunkBytes = I, this.offset = 0, this.chunks = [], this.totalBytes = 0, this.gunzip = new yQ((B, Q) => {
      this.chunks.push(B), this.totalBytes += B.length;
    });
  }
  read(A) {
    for (; this.totalBytes < A && this.offset < this.fileBytes.length; ) {
      const C = Math.min(
        this.offset + this.chunkBytes,
        this.fileBytes.length
      );
      this.gunzip.push(this.fileBytes.subarray(this.offset, C), !1), this.offset = C;
    }
    if (this.totalBytes < A && this.offset >= this.fileBytes.length && this.gunzip.push(new Uint8Array(0), !0), this.totalBytes < A)
      throw new Error(
        `Unexpected EOF: needed ${A}, got ${this.totalBytes}`
      );
    const I = new Uint8Array(this.totalBytes);
    let B = 0;
    for (const C of this.chunks)
      I.set(C, B), B += C.length;
    const Q = I.subarray(0, A);
    return this.chunks = [I.subarray(A)], this.totalBytes -= A, Q;
  }
}
const Ho = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DataCache: as,
  FreeList: dQ,
  GunzipReader: mQ,
  IDENT_VERTEX_SHADER: MQ,
  Sint8ToFloat: es,
  Uint8ToFloat: ss,
  averagePositions: NQ,
  averageQuaternions: pQ,
  cloneClock: GQ,
  coinciDist: kQ,
  computeMaxSplats: Ns,
  coorientDist: FQ,
  decodeQuatEulerXyz888: bs,
  decodeQuatOctXy88R8: RQ,
  decodeQuatXyz888: xs,
  decompressPartialGzip: JQ,
  encodeQuatEulerXyz888: Ls,
  encodeQuatOctXy88R8: WI,
  encodeQuatXyz888: Us,
  encodeSh1Rgb: Hs,
  encodeSh2Rgb: Ks,
  encodeSh3Rgb: Zs,
  epsilonSign: Ys,
  flipPixels: Rs,
  floatBitsToUint: ts,
  floatToSint8: jg,
  floatToUint8: VA,
  fromHalf: MA,
  getArrayBuffers: uQ,
  getTextureSize: dA,
  isAndroid: ks,
  isMobile: ps,
  isOculus: Fs,
  mapFilterObject: os,
  mapObject: ns,
  newArray: rs,
  omitUndefined: ms,
  pixelsToPngUrl: Js,
  setPackedSplat: JI,
  setPackedSplatCenter: cs,
  setPackedSplatOpacity: ls,
  setPackedSplatQuat: ws,
  setPackedSplatRgb: Ds,
  setPackedSplatScales: hs,
  toHalf: Eg,
  uintBitsToFloat: is,
  unpackSplat: AI,
  withinCoinciDist: Ss,
  withinCoorientDist: gI,
  withinDist: fs
}, Symbol.toStringTag, { value: "Module" }));
class VI {
  constructor({
    graph: A,
    inputs: I,
    outputs: B,
    template: Q
  }) {
    this.graph = A, this.template = Q, this.inputs = I ?? {}, this.outputs = B ?? {};
    const C = new wB({ indent: this.template.indent });
    for (const t in this.outputs)
      this.outputs[t] && C.declares.add(this.outputs[t]);
    const E = A.compile({
      inputs: this.inputs,
      outputs: this.outputs,
      compile: C
    });
    this.shader = Q.generate({ globals: C.globals, statements: E }), this.uniforms = C.uniforms, this.updaters = C.updaters;
  }
  prepareMaterial() {
    return qs(this);
  }
  update() {
    for (const A of this.updaters)
      A();
  }
}
class TI {
  constructor(A) {
    const I = A.match(/^([ \t]*)\{\{\s*GLOBALS\s*\}\}/m), B = A.match(/^([ \t]*)\{\{\s*STATEMENTS\s*\}\}/m);
    if (!I || !B)
      throw new Error(
        "Template must contain {{ GLOBALS }} and {{ STATEMENTS }}"
      );
    this.before = A.substring(0, I.index), this.between = A.substring(
      I.index + I[0].length,
      B.index
    ), this.after = A.substring(
      B.index + B[0].length
    ), this.indent = B[1];
  }
  generate({
    globals: A,
    statements: I
  }) {
    return this.before + Array.from(A).join(`

`) + this.between + I.map((B) => this.indent + B).join(`
`) + this.after;
  }
}
const gB = /* @__PURE__ */ new Map();
function qs(g) {
  let A = gB.get(g);
  return A || (A = new a.RawShaderMaterial({
    glslVersion: a.GLSL3,
    vertexShader: MQ,
    fragmentShader: g.shader,
    uniforms: g.uniforms
  }), gB.set(g, A), A);
}
function XI(g, A, I = "add") {
  const B = () => {
    throw new Error(`Invalid ${I} types: ${g}, ${A}`);
  };
  if (g === A) return g;
  if (g === "int") {
    if (wA(A)) return A;
    B();
  }
  if (A === "int") {
    if (wA(g)) return g;
    B();
  }
  if (g === "uint") {
    if (DA(A)) return A;
    B();
  }
  if (A === "uint") {
    if (DA(g)) return g;
    B();
  }
  if (g === "float") {
    if ($A(A)) return A;
    B();
  }
  if (A === "float") {
    if ($A(g)) return g;
    B();
  }
  throw new Error(`Invalid ${I} types: ${g}, ${A}`);
}
function vs(g, A) {
  return XI(g, A, "sub");
}
function Ws(g, A) {
  const I = () => {
    throw new Error(`Invalid mul types: ${g}, ${A}`);
  }, B = (Q) => Q;
  if (g === "int") {
    if (wA(A)) return B(A);
    I();
  }
  if (A === "int") {
    if (wA(g)) return B(g);
    I();
  }
  if (g === "uint") {
    if (DA(A)) return B(A);
    I();
  }
  if (A === "uint") {
    if (DA(g)) return B(g);
    I();
  }
  if (g === "float") {
    if ($A(A)) return B(A);
    I();
  }
  if (A === "float") {
    if ($A(g)) return B(g);
    I();
  }
  if (wA(g) || DA(g) || wA(A) || DA(A)) {
    if (g === A) return B(g);
    I();
  }
  if (g === "vec2") {
    if (A === "vec2" || Ig(A)) return B("vec2");
    if (A === "mat3x2") return B("vec3");
    if (A === "mat4x2") return B("vec4");
    I();
  }
  if (g === "vec3") {
    if (A === "mat2x3") return B("vec2");
    if (A === "vec3" || Bg(A)) return B("vec3");
    if (A === "mat4x3") return B("vec4");
    I();
  }
  if (g === "vec4") {
    if (A === "mat2x4") return B("vec2");
    if (A === "mat3x4") return B("vec3");
    if (A === "vec4" || Qg(A)) return B("vec4");
    I();
  }
  if (A === "vec2") {
    if (Ig(g)) return B("vec2");
    if (g === "mat2x3") return B("vec3");
    if (g === "mat2x4") return B("vec4");
    I();
  }
  if (A === "vec3") {
    if (g === "mat3x2") return B("vec2");
    if (Bg(g)) return B("vec3");
    if (g === "mat3x4") return B("vec4");
    I();
  }
  if (A === "vec4") {
    if (g === "mat4x2") return B("vec2");
    if (g === "mat4x3") return B("vec3");
    if (Qg(g)) return B("vec4");
    I();
  }
  if (Ig(g)) {
    if (Ig(A)) return B("mat2");
    if (A === "mat3x2") return B("mat3x2");
    if (A === "mat4x2") return B("mat4x2");
    I();
  }
  if (g === "mat2x3") {
    if (Ig(A)) return B("mat2x3");
    if (A === "mat3x2") return B("mat3");
    if (A === "mat4x2") return B("mat4x3");
    I();
  }
  if (g === "mat2x4") {
    if (Ig(A)) return B("mat2x4");
    if (A === "mat3x2") return B("mat3x4");
    if (A === "mat4x2") return B("mat4");
    I();
  }
  if (g === "mat3x2") {
    if (A === "mat2x3") return B("mat2");
    if (Bg(A)) return B("mat3x2");
    if (A === "mat4x3") return B("mat4x2");
    I();
  }
  if (Bg(g)) {
    if (A === "mat2x3") return B("mat2x3");
    if (Bg(A)) return B("mat3");
    if (A === "mat4x3") return B("mat4x3");
    I();
  }
  if (g === "mat3x4") {
    if (A === "mat2x3") return B("mat2x4");
    if (Bg(A)) return B("mat3x4");
    if (A === "mat4x3") return B("mat4");
    I();
  }
  if (g === "mat4x2") {
    if (A === "mat2x4") return B("mat2");
    if (A === "mat3x4") return B("mat3x2");
    if (Qg(A)) return B("mat4x2");
    I();
  }
  if (g === "mat4x3") {
    if (A === "mat2x4") return B("mat2x3");
    if (A === "mat3x4") return B("mat3");
    if (Qg(A)) return B("mat4x3");
    I();
  }
  if (Qg(g)) {
    if (A === "mat2x4") return B("mat2x4");
    if (A === "mat3x4") return B("mat3x4");
    if (Qg(A)) return B("mat4");
    I();
  }
  throw new Error(`Invalid mul types: ${g}, ${A}`);
}
function Vs(g, A) {
  return XI(g, A, "div");
}
function Ts(g, A) {
  if (g === A) return g;
  if (g === "int") {
    if (wA(A)) return A;
  } else if (A === "int") {
    if (wA(g)) return g;
  } else if (g === "uint") {
    if (DA(A)) return A;
  } else if (A === "uint" && DA(g))
    return g;
  throw new Error(`Invalid imod types: ${g}, ${A}`);
}
function Xs(g, A) {
  if (g === A || A === "float") return g;
  throw new Error(`Invalid mod types: ${g}, ${A}`);
}
function zs(g) {
  return g;
}
function js(g) {
  return g;
}
function Os(g) {
  return g;
}
function Ps(g) {
  return g;
}
function _s(g) {
  return g;
}
function $s(g) {
  return g;
}
function Ae(g) {
  return g;
}
function ge(g) {
  return g;
}
function Ie(g) {
  return g;
}
function Be(g) {
  return g;
}
function Qe(g) {
  return g;
}
function Ce(g) {
  return g;
}
function Ee(g) {
  return g;
}
function te(g) {
  return g;
}
function ie(g) {
  return g;
}
function se(g) {
  return g;
}
function fQ(g, A, I = "min") {
  if (g === A) return g;
  if (A === "float") {
    if (Yg(g)) return g;
  } else if (A === "int") {
    if (wA(g)) return g;
  } else if (A === "uint" && DA(g))
    return g;
  throw new Error(`Invalid ${I} types: ${g}, ${A}`);
}
function ee(g, A) {
  return fQ(g, A, "max");
}
function ae(g, A, I) {
  if (A === "float") {
    if (Yg(g)) return g;
  } else if (A === "int") {
    if (wA(g)) return g;
  } else if (A === "uint" && DA(g))
    return g;
  throw new Error(`Invalid clamp types: ${g}, ${A}`);
}
function ne(g, A, I) {
  if (I === g || I === "float" || I === "bool" && g === "float" || I === "bvec2" && g === "vec2" || I === "bvec3" && g === "vec3" || I === "bvec4" && g === "vec4") return g;
  throw new Error(`Invalid mix types: ${g}, ${A}, ${I}`);
}
function oe(g, A) {
  if (g === A || A === "float") return A;
  throw new Error(`Invalid step types: ${g}, ${A}`);
}
function re(g, A, I) {
  if (g === A && (g === I || g === "float"))
    return I;
  throw new Error(`Invalid smoothstep types: ${g}, ${A}, ${I}`);
}
function SQ(g, A = "isNan") {
  if (g === "float") return "bool";
  if (g === "vec2") return "bvec2";
  if (g === "vec3") return "bvec3";
  if (g === "vec4") return "bvec4";
  throw new Error(`Invalid ${A} types: ${g}`);
}
function ce(g) {
  return SQ(g, "isInf");
}
const NA = (g, A) => new LQ({ a: g, b: A }), Sg = (g, A) => new bQ({ a: g, b: A }), rA = (g, A) => new HQ({ a: g, b: A }), Og = (g, A) => new KQ({ a: g, b: A }), mI = (g, A) => new ZQ({ a: g, b: A }), YQ = (g, A) => new qQ({ a: g, b: A }), he = (g) => new vQ({ a: g }).outputs, we = (g) => new WQ({ a: g }), De = (g) => new VQ({ a: g }), le = (g) => new TQ({ a: g }), ye = (g) => new XQ({ a: g }), ue = (g) => new zQ({ a: g }), de = (g) => new jQ({ a: g }), Ge = (g) => new OQ({ a: g }), Pg = (g) => new PQ({ a: g }), Me = (g, A) => new _Q({ a: g, b: A }), Ne = (g) => new $Q({ a: g }), pe = (g) => new AC({ a: g }), ke = (g) => new gC({ a: g }), Fe = (g) => new IC({ a: g }), Re = (g) => new BC({ a: g }), Je = (g) => new QC({ a: g }), me = (g) => new CC({ a: g }), fe = (g, A) => new EC({ a: g, b: A }), UQ = (g, A) => new tC({ a: g, b: A }), Se = (g, A, I) => new iC({ a: g, min: A, max: I }), xQ = (g, A, I) => new sC({ a: g, b: A, t: I }), Ye = (g, A) => new eC({ edge: g, x: A }), Ue = (g, A, I) => new aC({ edge0: g, edge1: A, x: I }), xe = (g) => new nC({ a: g }), Le = (g) => new oC({ a: g });
class LQ extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "sum", outTypeFunc: XI }), this.statements = ({ inputs: B, outputs: Q }) => [`${Q.sum} = ${B.a} + ${B.b};`];
  }
}
class bQ extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "difference", outTypeFunc: vs }), this.statements = ({ inputs: B, outputs: Q }) => [`${Q.difference} = ${B.a} - ${B.b};`];
  }
}
class HQ extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "product", outTypeFunc: Ws }), this.statements = ({ inputs: B, outputs: Q }) => [`${Q.product} = ${B.a} * ${B.b};`];
  }
}
class KQ extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "quotient", outTypeFunc: Vs }), this.statements = ({ inputs: B, outputs: Q }) => [`${Q.quotient} = ${B.a} / ${B.b};`];
  }
}
class ZQ extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "remainder", outTypeFunc: Ts }), this.statements = ({ inputs: B, outputs: Q }) => [`${Q.remainder} = ${B.a} % ${B.b};`];
  }
}
class qQ extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "remainder", outTypeFunc: Xs }), this.statements = ({ inputs: B, outputs: Q }) => [`${Q.remainder} = mod(${B.a}, ${B.b});`];
  }
}
class vQ extends T {
  constructor({ a: A }) {
    const I = { a: v(A) }, B = I.a, Q = {
      fract: B,
      integer: B
    };
    super({ inTypes: I, outTypes: Q, inputs: { a: A } }), this.statements = ({ inputs: C, outputs: E }) => [`${E.fract} = modf(${C.a}, ${E.integer});`];
  }
}
class WQ extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "neg", outTypeFunc: zs }), this.statements = ({ inputs: I, outputs: B }) => [`${B.neg} = -${I.a};`];
  }
}
class VQ extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "abs", outTypeFunc: js }), this.statements = ({ inputs: I, outputs: B }) => [`${B.abs} = abs(${I.a});`];
  }
}
class TQ extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "sign", outTypeFunc: Os }), this.statements = ({ inputs: I, outputs: B }) => [`${B.sign} = sign(${I.a});`];
  }
}
class XQ extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "floor", outTypeFunc: Ps }), this.statements = ({ inputs: I, outputs: B }) => [`${B.floor} = floor(${I.a});`];
  }
}
class zQ extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "ceil", outTypeFunc: _s }), this.statements = ({ inputs: I, outputs: B }) => [`${B.ceil} = ceil(${I.a});`];
  }
}
class jQ extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "trunc", outTypeFunc: $s }), this.statements = ({ inputs: I, outputs: B }) => [`${B.trunc} = trunc(${I.a});`];
  }
}
class OQ extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "round", outTypeFunc: Ae }), this.statements = ({ inputs: I, outputs: B }) => [`${B.round} = round(${I.a});`];
  }
}
class PQ extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "fract", outTypeFunc: ge }), this.statements = ({ inputs: I, outputs: B }) => [`${B.fract} = fract(${I.a});`];
  }
}
class _Q extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "power", outTypeFunc: Ie }), this.statements = ({ inputs: B, outputs: Q }) => [`${Q.power} = pow(${B.a}, ${B.b});`];
  }
}
class $Q extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "exp", outTypeFunc: Be }), this.statements = ({ inputs: I, outputs: B }) => [`${B.exp} = exp(${I.a});`];
  }
}
class AC extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "exp2", outTypeFunc: Qe }), this.statements = ({ inputs: I, outputs: B }) => [`${B.exp2} = exp2(${I.a});`];
  }
}
class gC extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "log", outTypeFunc: Ce }), this.statements = ({ inputs: I, outputs: B }) => [`${B.log} = log(${I.a});`];
  }
}
class IC extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "log2", outTypeFunc: Ee }), this.statements = ({ inputs: I, outputs: B }) => [`${B.log2} = log2(${I.a});`];
  }
}
class BC extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "sqr", outTypeFunc: te }), this.statements = ({ inputs: I, outputs: B }) => [`${B.sqr} = ${I.a} * ${I.a};`];
  }
}
class QC extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "sqrt", outTypeFunc: ie }), this.statements = ({ inputs: I, outputs: B }) => [`${B.sqrt} = sqrt(${I.a});`];
  }
}
class CC extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "inversesqrt", outTypeFunc: se }), this.statements = ({ inputs: I, outputs: B }) => [`${B.inversesqrt} = inversesqrt(${I.a});`];
  }
}
class EC extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "min", outTypeFunc: fQ }), this.statements = ({ inputs: B, outputs: Q }) => [`${Q.min} = min(${B.a}, ${B.b});`];
  }
}
class tC extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "max", outTypeFunc: ee }), this.statements = ({ inputs: B, outputs: Q }) => [`${Q.max} = max(${B.a}, ${B.b});`];
  }
}
class iC extends eg {
  constructor({
    a: A,
    min: I,
    max: B
  }) {
    super({
      a: A,
      b: I,
      c: B,
      outKey: "clamp",
      outTypeFunc: ae
    }), this.statements = ({ inputs: Q, outputs: C }) => {
      const { a: E, b: t, c: i } = Q;
      return [`${C.clamp} = clamp(${E}, ${t}, ${i});`];
    };
  }
}
class sC extends eg {
  constructor({ a: A, b: I, t: B }) {
    super({ a: A, b: I, c: B, outKey: "mix", outTypeFunc: ne }), this.statements = ({ inputs: Q, outputs: C }) => {
      const { a: E, b: t, c: i } = Q;
      return [`${C.mix} = mix(${E}, ${t}, ${i});`];
    };
  }
}
class eC extends O {
  constructor({ edge: A, x: I }) {
    super({
      a: A,
      b: I,
      outKey: "step",
      outTypeFunc: oe
    }), this.statements = ({ inputs: B, outputs: Q }) => {
      const { a: C, b: E } = B;
      return [`${Q.step} = step(${C}, ${E});`];
    };
  }
}
class aC extends eg {
  constructor({
    edge0: A,
    edge1: I,
    x: B
  }) {
    super({
      a: A,
      b: I,
      c: B,
      outKey: "smoothstep",
      outTypeFunc: re
    }), this.statements = ({ inputs: Q, outputs: C }) => {
      const { a: E, b: t, c: i } = Q;
      return [`${C.smoothstep} = smoothstep(${E}, ${t}, ${i});`];
    };
  }
}
class nC extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "isNan", outTypeFunc: SQ }), this.statements = ({ inputs: I, outputs: B }) => [`${B.isNan} = isNan(${I.a});`];
  }
}
class oC extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "isInf", outTypeFunc: ce }), this.statements = ({ inputs: I, outputs: B }) => [`${B.isInf} = isInf(${I.a});`];
  }
}
const be = (g, A) => new rC({ a: g, b: A }), He = (g, A) => new cC({ a: g, b: A }), Ke = (g, A) => new hC({ a: g, b: A }), Ze = (g) => new wC({ a: g }), qe = (g, A) => new DC({ a: g, b: A }), ve = (g, A) => new lC({ a: g, b: A }), We = (g, A) => new yC({ a: g, b: A }), Ve = (g, A) => new uC({ a: g, b: A }), Te = (g, A) => new dC({ a: g, b: A }), Xe = (g, A) => new GC({ a: g, b: A }), ze = (g) => new MC({ a: g }), je = (g) => new NC({ a: g }), Oe = (g, A, I) => new pC({ cond: g, t: A, f: I }), Pe = (g) => new FC({ a: g });
class rC extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outTypeFunc: (B, Q) => B, outKey: "and" }), this.statements = ({ inputs: B, outputs: Q }) => this.outTypes.and === "bool" ? [`${Q.and} = ${B.a} && ${B.b};`] : [`${Q.and} = ${B.a} & ${B.b};`];
  }
}
class cC extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outTypeFunc: (B, Q) => B, outKey: "or" }), this.statements = ({ inputs: B, outputs: Q }) => this.outTypes.or === "bool" ? [`${Q.or} = ${B.a} || ${B.b};`] : [`${Q.or} = ${B.a} | ${B.b};`];
  }
}
class hC extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outTypeFunc: (B, Q) => B, outKey: "xor" }), this.statements = ({ inputs: B, outputs: Q }) => this.outTypes.xor === "bool" ? [`${Q.xor} = ${B.a} ^^ ${B.b};`] : [`${Q.xor} = ${B.a} ^ ${B.b};`];
  }
}
class wC extends R {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "not" }), this.statements = ({ inputs: I, outputs: B }) => this.outTypes.not === "bool" ? [`${B.not} = !${I.a};`] : [`${B.not} = not(${I.a});`];
  }
}
class DC extends O {
  constructor({ a: A, b: I }) {
    super({
      a: A,
      b: I,
      outTypeFunc: (B, Q) => aI(B, "lessThan"),
      outKey: "lessThan"
    }), this.statements = ({ inputs: B, outputs: Q }) => this.outTypes.lessThan === "bool" ? [`${Q.lessThan} = ${B.a} < ${B.b};`] : [`${Q.lessThan} = lessThan(${B.a}, ${B.b});`];
  }
}
class lC extends O {
  constructor({ a: A, b: I }) {
    super({
      a: A,
      b: I,
      outTypeFunc: (B, Q) => aI(B, "lessThanEqual"),
      outKey: "lessThanEqual"
    }), this.statements = ({ inputs: B, outputs: Q }) => this.outTypes.lessThanEqual === "bool" ? [`${Q.lessThanEqual} = ${B.a} <= ${B.b};`] : [
      `${Q.lessThanEqual} = lessThanEqual(${B.a}, ${B.b});`
    ];
  }
}
class yC extends O {
  constructor({ a: A, b: I }) {
    super({
      a: A,
      b: I,
      outTypeFunc: (B, Q) => aI(B, "greaterThan"),
      outKey: "greaterThan"
    }), this.statements = ({ inputs: B, outputs: Q }) => this.outTypes.greaterThan === "bool" ? [`${Q.greaterThan} = ${B.a} > ${B.b};`] : [
      `${Q.greaterThan} = greaterThan(${B.a}, ${B.b});`
    ];
  }
}
class uC extends O {
  constructor({ a: A, b: I }) {
    super({
      a: A,
      b: I,
      outTypeFunc: (B, Q) => aI(B, "greaterThanEqual"),
      outKey: "greaterThanEqual"
    }), this.statements = ({ inputs: B, outputs: Q }) => this.outTypes.greaterThanEqual === "bool" ? [`${Q.greaterThanEqual} = ${B.a} >= ${B.b};`] : [
      `${Q.greaterThanEqual} = greaterThanEqual(${B.a}, ${B.b});`
    ];
  }
}
class dC extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outTypeFunc: kC, outKey: "equal" }), this.statements = ({ inputs: B, outputs: Q }) => this.outTypes.equal === "bool" ? [`${Q.equal} = ${B.a} == ${B.b};`] : [`${Q.equal} = equal(${B.a}, ${B.b});`];
  }
}
class GC extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outTypeFunc: _e, outKey: "notEqual" }), this.statements = ({ inputs: B, outputs: Q }) => this.outTypes.notEqual === "bool" ? [`${Q.notEqual} = ${B.a} != ${B.b};`] : [`${Q.notEqual} = notEqual(${B.a}, ${B.b});`];
  }
}
class MC extends R {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (I) => "bool", outKey: "any" }), this.statements = ({ inputs: I, outputs: B }) => [`${B.any} = any(${I.a});`];
  }
}
class NC extends R {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (I) => "bool", outKey: "all" }), this.statements = ({ inputs: I, outputs: B }) => [`${B.all} = all(${I.a});`];
  }
}
class pC extends eg {
  constructor({
    cond: A,
    t: I,
    f: B
  }) {
    super({
      a: A,
      b: I,
      c: B,
      outKey: "select",
      outTypeFunc: (Q, C, E) => C
    }), this.statements = ({ inputs: Q, outputs: C }) => {
      const { a: E, b: t, c: i } = Q;
      return [`${C.select} = (${E}) ? (${t}) : (${i});`];
    };
  }
}
function aI(g, A) {
  if (sg(g))
    return "bool";
  if (g === "ivec2" || g === "uvec2" || g === "vec2")
    return "bvec2";
  if (g === "ivec3" || g === "uvec3" || g === "vec3")
    return "bvec3";
  if (g === "ivec4" || g === "uvec4" || g === "vec4")
    return "bvec4";
  throw new Error(`Invalid ${A} type: ${g}`);
}
function kC(g, A = "equal") {
  if (sg(g))
    return "bool";
  if (ig(g))
    return g;
  if (g === "ivec2" || g === "uvec2" || g === "vec2")
    return "bvec2";
  if (g === "ivec3" || g === "uvec3" || g === "vec3")
    return "bvec3";
  if (g === "ivec4" || g === "uvec4" || g === "vec4")
    return "bvec4";
  throw new Error(`Invalid ${A} type: ${g}`);
}
function _e(g) {
  return kC(g, "notEqual");
}
function $e(g) {
  if (ig(g))
    return "bool";
  if (wA(g))
    return "int";
  if (DA(g))
    return "uint";
  throw new Error(`Invalid compXor type: ${g}`);
}
class FC extends R {
  constructor({ a: A }) {
    const I = $e(v(A));
    super({ a: A, outTypeFunc: (B) => I, outKey: "compXor" }), this.statements = ({ inputs: B, outputs: Q }) => {
      if (sg(this.outTypes.compXor))
        return [`${Q.compXor} = ${B.a};`];
      const E = (ug(I) ? ["x", "y"] : dg(I) ? ["x", "y", "z"] : ["x", "y", "z", "w"]).map((i) => `${B.a}.${i}`), t = ig(I) ? "^^" : "^";
      return [`${Q.compXor} = ${E.join(` ${t} `)};`];
    };
  }
}
const Aa = (g) => new UC({ value: g }), ga = (g) => new xC({ value: g }), Ia = (g) => new LC({ value: g }), RC = (g) => new bC({ value: g }), Ba = (g) => new HC({ value: g }), Qa = (g) => new KC({ value: g }), Ca = (g) => new ZC({ value: g }), Ea = (g) => new qC({ value: g }), ta = (g) => new vC({ value: g }), ia = (g) => new WC({ value: g }), sa = (g) => new VC({ value: g }), ea = (g) => new TC({ value: g }), aa = (g) => new XC({ value: g }), JC = (g) => new zC({ value: g }), tg = (g) => new jC({ value: g }), mC = (g) => new OC({ value: g }), na = (g) => new PC({ value: g }), oa = (g) => new _C({ value: g }), ra = (g) => new $C({ value: g }), fC = (g) => new AE({ value: g }), ca = (g) => new gE({ value: g }), ha = (g) => new IE({ value: g }), wa = (g) => new BE({ value: g }), Da = (g) => new QE({ value: g }), la = (g) => new CE({ value: g }), ya = (g) => new EE({ value: g }), ua = (g) => new tE({ value: g }), SC = (g) => new iE({ value: g }), da = (g) => new sE({ value: g }), YC = (g) => new eE({ value: g });
class tA extends R {
  constructor({
    value: A,
    outType: I,
    outKey: B
  }) {
    super({ a: A, outTypeFunc: () => I, outKey: B }), this.statements = ({ inputs: Q, outputs: C }) => [
      `${C[B]} = ${cB(I)}(${Q.a});`
    ];
  }
}
class UC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bool", outKey: "bool" });
  }
}
class xC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "int", outKey: "int" });
  }
}
class LC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uint", outKey: "uint" });
  }
}
class bC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "float", outKey: "float" });
  }
}
class HC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec2", outKey: "bvec2" });
  }
}
class KC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec3", outKey: "bvec3" });
  }
}
class ZC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec4", outKey: "bvec4" });
  }
}
class qC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec2", outKey: "ivec2" });
  }
}
class vC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec3", outKey: "ivec3" });
  }
}
class WC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec4", outKey: "ivec4" });
  }
}
class VC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec2", outKey: "uvec2" });
  }
}
class TC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec3", outKey: "uvec3" });
  }
}
class XC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec4", outKey: "uvec4" });
  }
}
class zC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec2", outKey: "vec2" });
  }
}
class jC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec3", outKey: "vec3" });
  }
}
class OC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec4", outKey: "vec4" });
  }
}
class PC extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat2", outKey: "mat2" });
  }
}
class _C extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat3", outKey: "mat3" });
  }
}
class $C extends tA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat4", outKey: "mat4" });
  }
}
class AE extends R {
  constructor({ value: A }) {
    super({ a: A, outKey: "int", outTypeFunc: () => "int" }), this.statements = ({ inputs: I, outputs: B }) => [`${B.int} = floatBitsToInt(${I.a});`];
  }
}
class gE extends R {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: I, outputs: B }) => [`${B.uint} = floatBitsToUint(${I.a});`];
  }
}
class IE extends R {
  constructor({ value: A }) {
    super({ a: A, outKey: "float", outTypeFunc: () => "float" }), this.statements = ({ inputs: I, outputs: B }) => [`${B.float} = intBitsToFloat(${I.a});`];
  }
}
class BE extends R {
  constructor({ value: A }) {
    super({ a: A, outKey: "float", outTypeFunc: () => "float" }), this.statements = ({ inputs: I, outputs: B }) => [`${B.float} = uintBitsToFloat(${I.a});`];
  }
}
class QE extends R {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: I, outputs: B }) => [`${B.uint} = packSnorm2x16(${I.a});`];
  }
}
class CE extends R {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: I, outputs: B }) => [`${B.vec2} = unpackSnorm2x16(${I.a});`];
  }
}
class EE extends R {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: I, outputs: B }) => [`${B.uint} = packUnorm2x16(${I.a});`];
  }
}
class tE extends R {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: I, outputs: B }) => [`${B.vec2} = unpackUnorm2x16(${I.a});`];
  }
}
class iE extends R {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: I, outputs: B }) => [`${B.uint} = packHalf2x16(${I.a});`];
  }
}
class sE extends R {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: I, outputs: B }) => [`${B.vec2} = unpackHalf2x16(${I.a});`];
  }
}
class eE extends R {
  constructor({ value: A }) {
    super({ a: A, outKey: "rgba8", outTypeFunc: () => "vec4" }), this.statements = ({ inputs: I, outputs: B }) => [
      `uvec4 uRgba = uvec4(${I.a} & 0xffu, (${I.a} >> 8u) & 0xffu, (${I.a} >> 16u) & 0xffu, (${I.a} >> 24u) & 0xffu);`,
      `${B.rgba8} = vec4(uRgba) / 255.0;`
    ];
  }
}
const Ga = (g) => new oE({ a: g }), Ma = (g, A) => new rE({ a: g, b: A }), Na = (g, A) => new cE({ a: g, b: A }), pa = (g, A) => new hE({ a: g, b: A }), aE = (g) => new wE({ a: g }), ka = (g, A, I) => new yE({ a: g, b: A, c: I }), Fa = (g, A) => new uE({ incident: g, normal: A }), Ra = (g, A, I) => new dE({ incident: g, normal: A, eta: I }), Rg = (g) => new FE({ vector: g }), KA = ({
  vector: g,
  vectorType: A,
  x: I,
  y: B,
  z: Q,
  w: C,
  r: E,
  g: t,
  b: i,
  a: e
}) => new RE({ vector: g, vectorType: A, x: I, y: B, z: Q, w: C, r: E, g: t, b: i, a: e }), Ja = (g) => new DE({ a: g }), nE = (g, A) => new lE({ a: g, b: A }), ma = (g, A) => new JE({ vector: g, select: A }), fa = (g, A) => new GE({ a: g, b: A }), Sa = (g, A) => new ME({ a: g, b: A }), Ya = (g) => new NE({ a: g }), Ua = (g) => new pE({ a: g }), xa = (g) => new kE({ a: g });
class oE extends R {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (I) => "float", outKey: "length" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.length} = length(${I.a});`
    ];
  }
}
class rE extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "distance", outTypeFunc: (B, Q) => "float" }), this.statements = ({ inputs: B, outputs: Q }) => [
      `${Q.distance} = distance(${B.a}, ${B.b});`
    ];
  }
}
class cE extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "dot", outTypeFunc: (B, Q) => "float" }), this.statements = ({ inputs: B, outputs: Q }) => [
      `${Q.dot} = dot(${B.a}, ${B.b});`
    ];
  }
}
class hE extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "cross", outTypeFunc: (B, Q) => "vec3" }), this.statements = ({ inputs: B, outputs: Q }) => [
      `${Q.cross} = cross(${B.a}, ${B.b});`
    ];
  }
}
class wE extends R {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "normalize" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.normalize} = normalize(${I.a});`
    ];
  }
}
function La(g) {
  if (g === "vec3")
    return "vec2";
  if (g === "vec4")
    return "vec3";
  throw new Error("Invalid type");
}
class DE extends R {
  constructor({ a: A }) {
    super({
      a: A,
      outTypeFunc: (I) => La(I),
      outKey: "projected"
    }), this.statements = ({ inputs: I, outputs: B }) => {
      if (this.inTypes.a === "vec3")
        return [`${B.projected} = ${I.a}.xy / ${I.a}.z;`];
      if (this.inTypes.a === "vec4")
        return [`${B.projected} = ${I.a}.xyz / ${I.a}.w;`];
      throw new Error("Invalid type");
    };
  }
}
function ba(g) {
  if (g === "float") return "vec2";
  if (g === "vec2") return "vec3";
  if (g === "vec3") return "vec4";
  throw new Error("Invalid type");
}
class lE extends O {
  constructor({ a: A, b: I }) {
    const B = v(A), Q = ba(B);
    super({ a: A, b: I, outKey: "extend", outTypeFunc: () => Q }), this.statements = ({ inputs: C, outputs: E }) => [
      `${E.extend} = ${Q}(${C.a}, ${C.b});`
    ];
  }
}
class yE extends eg {
  constructor({ a: A, b: I, c: B }) {
    super({
      a: A,
      b: I,
      c: B,
      outKey: "forward",
      outTypeFunc: (Q, C, E) => Q
    }), this.statements = ({ inputs: Q, outputs: C }) => [
      `${C.forward} = faceforward(${Q.a}, ${Q.b}, ${Q.c});`
    ];
  }
}
class uE extends O {
  constructor({
    incident: A,
    normal: I
  }) {
    super({
      a: A,
      b: I,
      outKey: "reflection",
      outTypeFunc: (B, Q) => B
    }), this.statements = ({ inputs: B, outputs: Q }) => [
      `${Q.reflection} = reflect(${B.a}, ${B.b});`
    ];
  }
}
class dE extends eg {
  constructor({
    incident: A,
    normal: I,
    eta: B
  }) {
    super({
      a: A,
      b: I,
      c: B,
      outKey: "refraction",
      outTypeFunc: (Q, C, E) => Q
    }), this.statements = ({ inputs: Q, outputs: C }) => [
      `${C.refraction} = refract(${Q.a}, ${Q.b}, ${Q.c});`
    ];
  }
}
class GE extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "product", outTypeFunc: (B, Q) => B }), this.statements = ({ inputs: B, outputs: Q }) => [
      `${Q.product} = matrixCompMult(${A}, ${I});`
    ];
  }
}
function Ha(g, A) {
  if (g === "vec2") {
    if (A === "vec2") return "mat2";
    if (A === "vec3") return "mat3x2";
    if (A === "vec4") return "mat4x2";
  }
  if (g === "vec3") {
    if (A === "vec2") return "mat2x3";
    if (A === "vec3") return "mat3";
    if (A === "vec4") return "mat4x3";
  }
  if (g === "vec4") {
    if (A === "vec2") return "mat2x4";
    if (A === "vec3") return "mat3x4";
    if (A === "vec4") return "mat4";
  }
  throw new Error(`Invalid outer type: ${g}, ${A}`);
}
class ME extends O {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "outer", outTypeFunc: Ha }), this.statements = ({ inputs: B, outputs: Q }) => [
      `${Q.outer} = outerProduct(${B.a}, ${B.b});`
    ];
  }
}
function Ka(g) {
  if (g === "mat2") return "mat2";
  if (g === "mat3") return "mat3";
  if (g === "mat4") return "mat4";
  if (g === "mat2x2") return "mat2x2";
  if (g === "mat2x3") return "mat3x2";
  if (g === "mat2x4") return "mat4x2";
  if (g === "mat3x2") return "mat2x3";
  if (g === "mat3x3") return "mat3x3";
  if (g === "mat3x4") return "mat4x3";
  if (g === "mat4x2") return "mat2x4";
  if (g === "mat4x3") return "mat3x4";
  if (g === "mat4x4") return "mat4x4";
  throw new Error(`Invalid transpose type: ${g}`);
}
class NE extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "transpose", outTypeFunc: Ka }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.transpose} = transpose(${I.a});`
    ];
  }
}
class pE extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "det", outTypeFunc: (I) => "float" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.det} = determinant(${I.a});`
    ];
  }
}
class kE extends R {
  constructor({ a: A }) {
    super({ a: A, outKey: "inverse", outTypeFunc: (I) => I }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.inverse} = inverse(${A});`
    ];
  }
}
function Za(g) {
  const A = (I) => I;
  switch (g) {
    case "vec2":
      return A({ x: "float", y: "float", r: "float", g: "float" });
    case "vec3":
      return A({
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      });
    case "vec4":
      return A({
        x: "float",
        y: "float",
        z: "float",
        w: "float",
        r: "float",
        g: "float",
        b: "float",
        a: "float"
      });
    case "ivec2":
      return A({ x: "int", y: "int", r: "int", g: "int" });
    case "ivec3":
      return A({
        x: "int",
        y: "int",
        z: "int",
        r: "int",
        g: "int",
        b: "int"
      });
    case "ivec4":
      return A({
        x: "int",
        y: "int",
        z: "int",
        w: "int",
        r: "int",
        g: "int",
        b: "int",
        a: "int"
      });
    case "uvec2":
      return A({ x: "uint", y: "uint", r: "uint", g: "uint" });
    case "uvec3":
      return A({
        x: "uint",
        y: "uint",
        z: "uint",
        r: "uint",
        g: "uint",
        b: "uint"
      });
    case "uvec4":
      return A({
        x: "uint",
        y: "uint",
        z: "uint",
        w: "uint",
        r: "uint",
        g: "uint",
        b: "uint",
        a: "uint"
      });
    default:
      throw new Error(`Invalid vector type: ${g}`);
  }
}
class FE extends T {
  constructor({ vector: A }) {
    const B = { vector: v(A) }, Q = Za(B.vector);
    super({ inTypes: B, outTypes: Q, inputs: { vector: A } }), this.statements = ({ inputs: C, outputs: E }) => {
      const { x: t, y: i, z: e, w: n, r: s, g: o, b: r, a: c } = E, { vector: h } = C;
      return [
        t ? `${t} = ${h}.x;` : null,
        i ? `${i} = ${h}.y;` : null,
        e ? `${e} = ${h}.z;` : null,
        n ? `${n} = ${h}.w;` : null,
        s ? `${s} = ${h}.r;` : null,
        o ? `${o} = ${h}.g;` : null,
        r ? `${r} = ${h}.b;` : null,
        c ? `${c} = ${h}.a;` : null
      ].filter(Boolean);
    };
  }
}
class RE extends T {
  constructor({
    vector: A,
    vectorType: I,
    x: B,
    y: Q,
    z: C,
    w: E,
    r: t,
    g: i,
    b: e,
    a: n
  }) {
    if (!A && !I)
      throw new Error("Either vector or vectorType must be provided");
    const s = I ?? v(A), o = nB(s), r = oB(s), c = {
      vector: s,
      x: o,
      y: o,
      r: o,
      g: o
    }, h = { vector: A, x: B, y: Q, r: t, g: i };
    r >= 3 && (Object.assign(c, { z: o, b: o }), Object.assign(h, { z: C, b: e })), r >= 4 && (Object.assign(c, { w: o, a: o }), Object.assign(h, { w: E, a: n })), super({ inTypes: c, outTypes: { vector: s }, inputs: h }), this.statements = ({ inputs: w, outputs: D }) => {
      const { vector: y } = D, {
        vector: l,
        x: d,
        y: u,
        z: p,
        w: m,
        r: M,
        g: G,
        b: J,
        a: k
      } = w, N = [
        `${y}.x = ${d ?? M ?? (l ? `${l}.x` : Ng(o))};`,
        `${y}.y = ${u ?? G ?? (l ? `${l}.y` : Ng(o))};`
      ];
      return r >= 3 && N.push(
        `${y}.z = ${p ?? J ?? (l ? `${l}.z` : Ng(o))};`
      ), r >= 4 && N.push(
        `${y}.w = ${m ?? k ?? (l ? `${l}.w` : Ng(o))};`
      ), N;
    };
  }
  dynoOut() {
    return new W(
      this,
      "vector"
    );
  }
}
function qa(g, A) {
  let I = null;
  if (Yg(g) ? I = A.length === 1 ? "float" : A.length === 2 ? "vec2" : A.length === 3 ? "vec3" : A.length === 4 ? "vec4" : null : wA(g) ? I = A.length === 1 ? "int" : A.length === 2 ? "ivec2" : A.length === 3 ? "ivec3" : A.length === 4 ? "ivec4" : null : DA(g) && (I = A.length === 1 ? "uint" : A.length === 2 ? "uvec2" : A.length === 3 ? "uvec3" : A.length === 4 ? "uvec4" : null), I == null)
    throw new Error(`Invalid swizzle: ${A}`);
  return I;
}
class JE extends R {
  constructor({ vector: A, select: I }) {
    super({
      a: A,
      outKey: "swizzle",
      outTypeFunc: (B) => qa(B, I)
    }), this.statements = ({ inputs: B, outputs: Q }) => [
      `${Q.swizzle} = ${B.a}.${I};`
    ];
  }
}
const va = (g, A, I) => new xE({ index: g, from: A, to: I }), Wa = (g) => new Gg({ value: g }), Va = (g) => new RA({ state: g }), Ta = (g) => new JA({ state: g }), mE = (g) => new LE({ value: g }), fE = (g) => new bE({ value: g }), SE = (g) => new HE({ value: g }), YE = (g) => new KE({ value: g }), Xa = (g) => new ZE({ value: g }), za = (g) => new qE({ value: g }), UE = (g) => new vE({ value: g }), fI = (g) => new WE({ value: g });
class xE extends T {
  constructor({
    from: A,
    to: I,
    index: B
  }) {
    super({
      inTypes: { from: "int", to: "int", index: "int" },
      outTypes: { index: "int" },
      inputs: { from: A, to: I, index: B },
      statements: ({ inputs: Q, outputs: C }) => [
        `${C.index} = ${Q.index} - ${Q.from} + ${Q.to};`
      ]
    });
  }
  dynoOut() {
    return new W(this, "index");
  }
}
class RA extends T {
  constructor({ state: A }) {
    const I = v(A);
    super({
      inTypes: { state: I },
      outTypes: { state: "uint" },
      inputs: { state: A },
      globals: () => [
        aA(`
          uint pcg_next(uint state) {
            return state * 747796405u + 2891336453u;
          }
        `)
      ],
      statements: ({ inputs: B, outputs: Q }) => {
        const C = I === "uint" ? `${B.state}` : I === "int" ? `uint(${B.state})` : `floatBitsToUint(${B.state})`;
        return [`${Q.state} = pcg_next(${C});`];
      }
    });
  }
  dynoOut() {
    return new W(this, "state");
  }
}
class JA extends T {
  constructor({ state: A }) {
    super({
      inTypes: { state: "uint" },
      outTypes: { hash: "uint" },
      inputs: { state: A },
      globals: () => [
        aA(`
          uint pcg_hash(uint state) {
            uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
            return (hash >> 22u) ^ hash;
          }
        `)
      ],
      statements: ({ inputs: I, outputs: B }) => [
        `${B.hash} = pcg_hash(${I.state});`
      ]
    });
  }
  dynoOut() {
    return new W(this, "hash");
  }
}
class Gg extends T {
  constructor({ value: A }) {
    const I = v(A), B = rB(I);
    super({
      inTypes: { value: I },
      outTypes: { state: "uint" },
      inputs: { value: A },
      globals: () => [
        aA(`
          uint pcg_mix(uint value) {
            return value;
          }
          uint pcg_mix(uvec2 value) {
            return value.x + 0x9e3779b9u * value.y;
          }
          uint pcg_mix(uvec3 value) {
            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z;
          }
          uint pcg_mix(uvec4 value) {
            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z + 0xc2b2ae35u * value.w;
          }
        `)
      ],
      statements: ({ inputs: Q, outputs: C }) => {
        const E = DA(I) ? `${Q.value}` : wA(I) ? `${B}(${Q.value})` : `floatBitsToUint(${Q.value})`;
        return [
          `${B} bits = ${E};`,
          `${C.state} = pcg_mix(bits);`
        ];
      }
    });
  }
  dynoOut() {
    return new W(this, "state");
  }
}
class LE extends qA {
  constructor({ value: A }) {
    super({
      inTypes: { value: v(A) },
      outTypes: { hash: "uint" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        let B = new Gg({ value: I }).outputs.state;
        return B = new RA({ state: B }).outputs.state, new JA({ state: B }).outputs;
      }
    });
  }
  dynoOut() {
    return new W(this, "hash");
  }
}
class bE extends qA {
  constructor({ value: A }) {
    super({
      inTypes: { value: v(A) },
      outTypes: { hash: "uvec2" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        let B = new Gg({ value: I }).outputs.state;
        B = new RA({ state: B }).outputs.state;
        const Q = new JA({ state: B }).outputs.hash;
        B = new RA({ state: B }).outputs.state;
        const C = new JA({ state: B }).outputs.hash;
        return { hash: KA({ vectorType: "uvec2", x: Q, y: C }) };
      }
    });
  }
  dynoOut() {
    return new W(this, "hash");
  }
}
class HE extends qA {
  constructor({ value: A }) {
    super({
      inTypes: { value: v(A) },
      outTypes: { hash: "uvec3" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        let B = new Gg({ value: I }).outputs.state;
        B = new RA({ state: B }).outputs.state;
        const Q = new JA({ state: B }).outputs.hash;
        B = new RA({ state: B }).outputs.state;
        const C = new JA({ state: B }).outputs.hash;
        B = new RA({ state: B }).outputs.state;
        const E = new JA({ state: B }).outputs.hash;
        return { hash: KA({ vectorType: "uvec3", x: Q, y: C, z: E }) };
      }
    });
  }
  dynoOut() {
    return new W(this, "hash");
  }
}
class KE extends qA {
  constructor({ value: A }) {
    super({
      inTypes: { value: v(A) },
      outTypes: { hash: "uvec4" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        let B = new Gg({ value: I }).outputs.state;
        B = new RA({ state: B }).outputs.state;
        const Q = new JA({ state: B }).outputs.hash;
        B = new RA({ state: B }).outputs.state;
        const C = new JA({ state: B }).outputs.hash;
        B = new RA({ state: B }).outputs.state;
        const E = new JA({ state: B }).outputs.hash;
        B = new RA({ state: B }).outputs.state;
        const t = new JA({ state: B }).outputs.hash;
        return { hash: KA({ vectorType: "uvec4", x: Q, y: C, z: E, w: t }) };
      }
    });
  }
  dynoOut() {
    return new W(this, "hash");
  }
}
class ZE extends qA {
  constructor({ value: A }) {
    super({
      inTypes: { value: v(A) },
      outTypes: { hash: "float" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        const B = mE(I);
        return { hash: rA(RC(B), gA("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new W(this, "hash");
  }
}
class qE extends qA {
  constructor({ value: A }) {
    super({
      inTypes: { value: v(A) },
      outTypes: { hash: "vec2" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        const B = fE(I);
        return { hash: rA(JC(B), gA("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new W(this, "hash");
  }
}
class vE extends qA {
  constructor({ value: A }) {
    super({
      inTypes: { value: v(A) },
      outTypes: { hash: "vec3" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        const B = SE(I);
        return { hash: rA(tg(B), gA("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new W(this, "hash");
  }
}
class WE extends qA {
  constructor({ value: A }) {
    super({
      inTypes: { value: v(A) },
      outTypes: { hash: "vec4" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        const B = YE(I);
        return { hash: rA(mC(B), gA("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new W(this, "hash");
  }
}
const VE = (g, {
  scale: A,
  scales: I,
  rotate: B,
  translate: Q
}) => new XE({ position: g, scale: A, scales: I, rotate: B, translate: Q }).outputs.position, TE = (g, {
  scale: A,
  scales: I,
  rotate: B
}) => new zE({ dir: g, scale: A, scales: I, rotate: B }).outputs.dir, ja = (g, { rotate: A }) => new jE({ quaternion: g, rotate: A }).outputs.quaternion;
class XE extends T {
  constructor({
    position: A,
    scale: I,
    scales: B,
    rotate: Q,
    translate: C
  }) {
    super({
      inTypes: {
        position: "vec3",
        scale: "float",
        scales: "vec3",
        rotate: "vec4",
        translate: "vec3"
      },
      outTypes: { position: "vec3" },
      inputs: { position: A, scale: I, scales: B, rotate: Q, translate: C },
      statements: ({ inputs: E, outputs: t }) => {
        const { position: i } = t;
        if (!i)
          return [];
        const { scale: e, scales: n, rotate: s, translate: o } = E;
        return [
          `${i} = ${E.position ?? "vec3(0.0, 0.0, 0.0)"};`,
          e ? `${i} *= ${e};` : null,
          n ? `${i} *= ${n};` : null,
          s ? `${i} = quatVec(${s}, ${i});` : null,
          o ? `${i} += ${o};` : null
        ].filter(Boolean);
      }
    });
  }
}
class zE extends T {
  constructor({
    dir: A,
    scale: I,
    scales: B,
    rotate: Q
  }) {
    super({
      inTypes: { dir: "vec3", scale: "float", scales: "vec3", rotate: "vec4" },
      outTypes: { dir: "vec3" },
      inputs: { dir: A, scale: I, scales: B, rotate: Q },
      statements: ({ inputs: C, outputs: E }) => {
        const { dir: t } = E;
        if (!t)
          return [];
        const { scale: i, scales: e, rotate: n } = C;
        return [
          `${t} = ${C.dir ?? "vec3(0.0, 0.0, 0.0)"};`,
          i ? `${t} *= ${i};` : null,
          e ? `${t} *= ${e};` : null,
          n ? `${t} = quatVec(${n}, ${t});` : null
        ].filter(Boolean);
      }
    });
  }
}
class jE extends T {
  constructor({
    quaternion: A,
    rotate: I
  }) {
    super({
      inTypes: { quaternion: "vec4", rotate: "vec4" },
      outTypes: { quaternion: "vec4" },
      inputs: { quaternion: A, rotate: I },
      statements: ({ inputs: B, outputs: Q }) => {
        const { quaternion: C } = Q;
        return C ? [
          `${C} = ${B.quaternion ?? "vec4(0.0, 0.0, 0.0, 1.0)"};`,
          I ? `${C} = quatQuat(${B.rotate}, ${C});` : null
        ].filter(Boolean) : [];
      }
    });
  }
}
const Oa = () => {
  throw new Error("Not implemented");
}, Pa = () => {
  throw new Error("Not implemented");
}, _a = () => {
  throw new Error("Not implemented");
}, $a = () => {
  throw new Error("Not implemented");
}, An = () => {
  throw new Error("Not implemented");
}, gn = () => {
  throw new Error("Not implemented");
}, In = (g, A) => new OE({ texture: g, lod: A }), Bn = (g, A, I) => new PE({ texture: g, coord: A, bias: I }), Qn = (g, A, I) => new _E({ texture: g, coord: A, lod: I });
class OE extends T {
  constructor({ texture: A, lod: I }) {
    const B = v(A);
    super({
      inTypes: { texture: B, lod: "int" },
      outTypes: { size: $E(B) },
      inputs: { texture: A, lod: I },
      statements: ({ inputs: Q, outputs: C }) => [
        `${C.size} = textureSize(${Q.texture}, ${Q.lod ?? "0"});`
      ]
    });
  }
  dynoOut() {
    return new W(this, "size");
  }
}
class PE extends T {
  constructor({
    texture: A,
    coord: I,
    bias: B
  }) {
    const Q = v(A);
    super({
      inTypes: {
        texture: Q,
        coord: Cn(Q),
        bias: "float"
      },
      outTypes: { sample: At(Q) },
      inputs: { texture: A, coord: I, bias: B },
      statements: ({ inputs: C, outputs: E }) => [
        `${E.sample} = texture(${C.texture}, ${C.coord}${C.bias ? `, ${C.bias}` : ""});`
      ]
    });
  }
  dynoOut() {
    return new W(this, "sample");
  }
}
class _E extends T {
  constructor({
    texture: A,
    coord: I,
    lod: B
  }) {
    const Q = v(A);
    super({
      inTypes: {
        texture: Q,
        coord: $E(Q),
        lod: "int"
      },
      outTypes: { texel: At(Q) },
      inputs: { texture: A, coord: I, lod: B },
      statements: ({ inputs: C, outputs: E }) => [
        `${E.texel} = texelFetch(${C.texture}, ${C.coord}, ${C.lod ?? "0"});`
      ]
    });
  }
  dynoOut() {
    return new W(this, "texel");
  }
}
function $E(g) {
  switch (g) {
    case "sampler2D":
    case "usampler2D":
    case "isampler2D":
    case "samplerCube":
    case "usamplerCube":
    case "isamplerCube":
    case "sampler2DShadow":
    case "samplerCubeShadow":
      return "ivec2";
    case "sampler3D":
    case "usampler3D":
    case "isampler3D":
    case "sampler2DArray":
    case "usampler2DArray":
    case "isampler2DArray":
    case "sampler2DArrayShadow":
      return "ivec3";
    default:
      throw new Error(`Invalid texture type: ${g}`);
  }
}
function Cn(g) {
  switch (g) {
    case "sampler2D":
    case "usampler2D":
    case "isampler2D":
      return "vec2";
    case "sampler3D":
    case "usampler3D":
    case "isampler3D":
    case "samplerCube":
    case "usamplerCube":
    case "isamplerCube":
    case "sampler2DArray":
    case "usampler2DArray":
    case "isampler2DArray":
    case "sampler2DShadow":
      return "vec3";
    case "samplerCubeShadow":
    case "sampler2DArrayShadow":
      return "vec4";
    default:
      throw new Error(`Invalid texture type: ${g}`);
  }
}
function At(g) {
  switch (g) {
    case "sampler2D":
    case "sampler2DArray":
    case "sampler3D":
    case "samplerCube":
    case "sampler2DShadow":
      return "vec4";
    case "usampler2D":
    case "usampler2DArray":
    case "usampler3D":
    case "usamplerCube":
      return "uvec4";
    case "isampler2D":
    case "isampler2DArray":
    case "isampler3D":
    case "isamplerCube":
      return "ivec4";
    case "samplerCubeShadow":
    case "sampler2DArrayShadow":
      return "float";
    default:
      throw new Error(`Invalid texture type: ${g}`);
  }
}
const En = (g) => new gt({ degrees: g }), tn = (g) => new It({ radians: g }), SI = (g) => new Bt({ radians: g }), sn = (g) => new Qt({ radians: g }), en = (g) => new Ct({ radians: g }), an = (g) => new Et({ sin: g }), nn = (g) => new tt({ cos: g }), on = (g) => new it({ tan: g }), rn = (g, A) => new st({ y: g, x: A }), cn = (g) => new et({ x: g }), hn = (g) => new at({ x: g }), wn = (g) => new nt({ x: g }), Dn = (g) => new ot({ x: g }), ln = (g) => new rt({ x: g }), yn = (g) => new ct({ x: g });
class gt extends R {
  constructor({ degrees: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "radians" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.radians} = radians(${I.a});`
    ];
  }
}
class It extends R {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "degrees" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.degrees} = degrees(${I.a});`
    ];
  }
}
class Bt extends R {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "sin" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.sin} = sin(${I.a});`
    ];
  }
}
class Qt extends R {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "cos" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.cos} = cos(${I.a});`
    ];
  }
}
class Ct extends R {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "tan" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.tan} = tan(${I.a});`
    ];
  }
}
class Et extends R {
  constructor({ sin: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "asin" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.asin} = asin(${I.a});`
    ];
  }
}
class tt extends R {
  constructor({ cos: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "acos" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.acos} = acos(${I.a});`
    ];
  }
}
class it extends R {
  constructor({ tan: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "atan" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.atan} = atan(${I.a});`
    ];
  }
}
class st extends O {
  constructor({ y: A, x: I }) {
    super({
      a: A,
      b: I,
      outTypeFunc: (B, Q) => B,
      outKey: "atan2"
    }), this.statements = ({ inputs: B, outputs: Q }) => [
      `${Q.atan2} = atan2(${B.a}, ${B.b});`
    ];
  }
}
class et extends R {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "sinh" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.sinh} = sinh(${I.a});`
    ];
  }
}
class at extends R {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "cosh" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.cosh} = cosh(${I.a});`
    ];
  }
}
class nt extends R {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "tanh" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.tanh} = tanh(${I.a});`
    ];
  }
}
class ot extends R {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "asinh" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.asinh} = asinh(${I.a});`
    ];
  }
}
class rt extends R {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "acosh" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.acosh} = acosh(${I.a});`
    ];
  }
}
class ct extends R {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "atanh" }), this.statements = ({ inputs: I, outputs: B }) => [
      `${B.atanh} = atanh(${I.a});`
    ];
  }
}
const Ko = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Abs: VQ,
  Acos: tt,
  Acosh: rt,
  Add: LQ,
  All: NC,
  And: rC,
  Any: MC,
  Asin: Et,
  Asinh: ot,
  Atan: it,
  Atan2: st,
  Atanh: ct,
  BVec2: HC,
  BVec3: KC,
  BVec4: ZC,
  BinaryOp: O,
  Bool: UC,
  Ceil: zQ,
  Clamp: iC,
  Combine: RE,
  CombineGsplat: MB,
  CompMult: GE,
  CompXor: FC,
  Compilation: wB,
  Cos: Qt,
  Cosh: at,
  Cross: hE,
  Degrees: It,
  Determinant: pE,
  Distance: rE,
  Div: KQ,
  Dot: cE,
  Dyno: T,
  DynoBlock: qA,
  DynoBool: $g,
  DynoBvec2: mB,
  DynoBvec3: UB,
  DynoBvec4: bB,
  DynoConst: hB,
  DynoFloat: Cg,
  DynoInt: fg,
  DynoIsampler2D: AQ,
  DynoIsampler2DArray: IQ,
  DynoIsampler3D: CQ,
  DynoIsamplerCube: iQ,
  DynoIvec2: SB,
  DynoIvec3: LB,
  DynoIvec4: KB,
  DynoLiteral: Dg,
  DynoMat2: ZB,
  DynoMat2x2: qB,
  DynoMat2x3: vB,
  DynoMat2x4: WB,
  DynoMat3: VB,
  DynoMat3x2: TB,
  DynoMat3x3: XB,
  DynoMat3x4: zB,
  DynoMat4: jB,
  DynoMat4x2: OB,
  DynoMat4x3: PB,
  DynoMat4x4: _B,
  DynoOutput: W,
  DynoProgram: VI,
  DynoProgramTemplate: TI,
  DynoRemapIndex: xE,
  DynoSampler2D: gQ,
  DynoSampler2DArray: BQ,
  DynoSampler2DArrayShadow: aQ,
  DynoSampler2DShadow: eQ,
  DynoSampler3D: EQ,
  DynoSamplerCube: sQ,
  DynoSamplerCubeShadow: nQ,
  DynoUint: JB,
  DynoUniform: S,
  DynoUsampler2D: $B,
  DynoUsampler2DArray: kg,
  DynoUsampler3D: QQ,
  DynoUsamplerCube: tQ,
  DynoUvec2: fB,
  DynoUvec3: xB,
  DynoUvec4: HB,
  DynoValue: _A,
  DynoVec2: YB,
  DynoVec3: yg,
  DynoVec4: bg,
  Equal: dC,
  Exp: $Q,
  Exp2: AC,
  ExtendVec: lE,
  FaceForward: yE,
  Float: bC,
  FloatBitsToInt: AE,
  FloatBitsToUint: gE,
  Floor: XQ,
  Fract: PQ,
  GreaterThan: yC,
  GreaterThanEqual: uC,
  Gsplat: BA,
  GsplatNormal: pB,
  Hash: LE,
  Hash2: bE,
  Hash3: HE,
  Hash4: KE,
  HashFloat: ZE,
  HashVec2: qE,
  HashVec3: vE,
  HashVec4: WE,
  IMod: ZQ,
  IVec2: qC,
  IVec3: vC,
  IVec4: WC,
  Int: xC,
  IntBitsToFloat: IE,
  Inverse: kE,
  InverseSqrt: CC,
  IsInf: oC,
  IsNan: nC,
  Length: oE,
  LessThan: DC,
  LessThanEqual: lC,
  Log: gC,
  Log2: IC,
  Mat2: PC,
  Mat3: _C,
  Mat4: $C,
  Max: tC,
  Min: EC,
  Mix: sC,
  Mod: qQ,
  Modf: vQ,
  Mul: HQ,
  Neg: WQ,
  Normalize: wE,
  Not: wC,
  NotEqual: GC,
  NumPackedSplats: lB,
  Or: cC,
  Outer: ME,
  OutputPackedSplat: RB,
  OutputRgba8: vI,
  PackHalf2x16: iE,
  PackSnorm2x16: QE,
  PackUnorm2x16: EE,
  PcgHash: JA,
  PcgMix: Gg,
  PcgNext: RA,
  Pow: _Q,
  ProjectH: DE,
  Radians: gt,
  ReadPackedSplat: uB,
  ReadPackedSplatRange: dB,
  ReflectVec: uE,
  RefractVec: dE,
  Round: OQ,
  Select: pC,
  Sign: TQ,
  SimpleCast: tA,
  Sin: Bt,
  Sinh: et,
  Smoothstep: aC,
  Split: FE,
  SplitGsplat: GB,
  Sqr: BC,
  Sqrt: QC,
  Step: eC,
  Sub: bQ,
  Swizzle: JE,
  TPackedSplats: Lg,
  Tan: Ct,
  Tanh: nt,
  TexelFetch: _E,
  Texture: PE,
  TextureSize: OE,
  TransformDir: zE,
  TransformGsplat: kB,
  TransformPosition: XE,
  TransformQuaternion: jE,
  Transpose: NE,
  TrinaryOp: eg,
  Trunc: jQ,
  UVec2: VC,
  UVec3: TC,
  UVec4: XC,
  Uint: LC,
  UintBitsToFloat: BE,
  UintToRgba8: eE,
  UnaryOp: R,
  UnpackHalf2x16: sE,
  UnpackSnorm2x16: CE,
  UnpackUnorm2x16: tE,
  Vec2: zC,
  Vec3: jC,
  Vec4: OC,
  Xor: hC,
  abs: De,
  acos: nn,
  acosh: ln,
  add: NA,
  all: je,
  and: be,
  any: ze,
  arrayIndex: An,
  arrayLength: gn,
  asin: an,
  asinh: Dn,
  atan: on,
  atan2: rn,
  atanh: yn,
  bool: Aa,
  bvec2: Ba,
  bvec3: Qa,
  bvec4: Ca,
  ceil: ue,
  clamp: Se,
  combine: KA,
  combineGsplat: lg,
  comment: $a,
  compMult: fa,
  compXor: Pe,
  cos: sn,
  cosh: hn,
  cross: pa,
  defineGsplat: pA,
  defineGsplatNormal: NB,
  definePackedSplats: sI,
  degrees: tn,
  determinant: Ua,
  distance: Ma,
  div: Og,
  dot: Na,
  dyno: xg,
  dynoBlock: YA,
  dynoBool: ti,
  dynoBvec2: ei,
  dynoBvec3: ri,
  dynoBvec4: wi,
  dynoConst: gA,
  dynoDeclare: ZI,
  dynoFloat: bA,
  dynoFor: _a,
  dynoIf: Oa,
  dynoInt: si,
  dynoIsampler2D: Yi,
  dynoIsampler2DArray: Li,
  dynoIsampler3D: Ki,
  dynoIsamplerCube: vi,
  dynoIvec2: ni,
  dynoIvec3: hi,
  dynoIvec4: li,
  dynoLiteral: _g,
  dynoMat2: ui,
  dynoMat2x2: di,
  dynoMat2x3: Gi,
  dynoMat2x4: Mi,
  dynoMat3: Ni,
  dynoMat3x2: pi,
  dynoMat3x3: ki,
  dynoMat3x4: Fi,
  dynoMat4: Ri,
  dynoMat4x2: Ji,
  dynoMat4x3: mi,
  dynoMat4x4: fi,
  dynoSampler2D: Ui,
  dynoSampler2DArray: bi,
  dynoSampler2DArrayShadow: Ti,
  dynoSampler2DShadow: Vi,
  dynoSampler3D: Zi,
  dynoSamplerCube: Wi,
  dynoSamplerCubeShadow: Xi,
  dynoSwitch: Pa,
  dynoUint: ii,
  dynoUsampler2D: Si,
  dynoUsampler2DArray: xi,
  dynoUsampler3D: Hi,
  dynoUsamplerCube: qi,
  dynoUvec2: ai,
  dynoUvec3: ci,
  dynoUvec4: Di,
  dynoVec2: oi,
  dynoVec3: zA,
  dynoVec4: yi,
  equal: Te,
  exp: Ne,
  exp2: pe,
  extendVec: nE,
  faceforward: ka,
  float: RC,
  floatBitsToInt: fC,
  floatBitsToUint: ca,
  floor: ye,
  fract: Pg,
  greaterThan: We,
  greaterThanEqual: Ve,
  gsplatNormal: Qi,
  hash: mE,
  hash2: fE,
  hash3: SE,
  hash4: YE,
  hashFloat: Xa,
  hashVec2: za,
  hashVec3: UE,
  hashVec4: fI,
  imod: mI,
  int: ga,
  intBitsToFloat: ha,
  inverse: xa,
  inversesqrt: me,
  isAllFloatType: $A,
  isBoolType: ig,
  isFloatType: Yg,
  isInf: Le,
  isIntType: wA,
  isMat2: Ig,
  isMat3: Bg,
  isMat4: Qg,
  isMatFloatType: aB,
  isNan: xe,
  isScalarType: sg,
  isUintType: DA,
  isVector2Type: ug,
  isVector3Type: dg,
  isVector4Type: Ug,
  isVectorType: _t,
  ivec2: Ea,
  ivec3: ta,
  ivec4: ia,
  length: Ga,
  lessThan: qe,
  lessThanEqual: ve,
  literalNegOne: Ii,
  literalOne: gi,
  literalZero: Ng,
  log: ke,
  log2: Fe,
  mat2: na,
  mat3: oa,
  mat4: ra,
  max: UQ,
  min: fe,
  mix: xQ,
  mod: YQ,
  modf: he,
  mul: rA,
  neg: we,
  normalize: aE,
  not: Ze,
  notEqual: Xe,
  numPackedSplats: Bi,
  numberAsFloat: q,
  numberAsInt: CA,
  numberAsUint: EA,
  or: He,
  outer: Sa,
  outputPackedSplat: FB,
  outputRgba8: Ci,
  packHalf2x16: SC,
  packSnorm2x16: Da,
  packUnorm2x16: ya,
  pcgHash: Ta,
  pcgMix: Wa,
  pcgNext: Va,
  pow: Me,
  projectH: Ja,
  radians: En,
  readPackedSplat: mg,
  readPackedSplatRange: DB,
  reflectVec: Fa,
  refractVec: Ra,
  remapIndex: va,
  round: Ge,
  sameSizeIvec: Ai,
  sameSizeUvec: rB,
  sameSizeVec: $t,
  select: Oe,
  sign: le,
  sin: SI,
  sinh: cn,
  smoothstep: Ue,
  split: Rg,
  splitGsplat: pg,
  sqr: Re,
  sqrt: Je,
  step: Ye,
  sub: Sg,
  swizzle: ma,
  tan: en,
  tanh: wn,
  texelFetch: Qn,
  texture: Bn,
  textureSize: In,
  transformDir: TE,
  transformGsplat: qI,
  transformPos: VE,
  transformQuat: ja,
  transpose: Ya,
  trunc: de,
  typeLiteral: cB,
  uint: Ia,
  uintBitsToFloat: wa,
  uintToRgba8: YC,
  uniform: Ei,
  unindent: aA,
  unindentLines: mA,
  unpackHalf2x16: da,
  unpackSnorm2x16: la,
  unpackUnorm2x16: ua,
  uvec2: sa,
  uvec3: ea,
  uvec4: aa,
  valType: v,
  vec2: JC,
  vec3: tg,
  vec4: mC,
  vectorDim: oB,
  vectorElementType: nB,
  xor: Ke
}, Symbol.toStringTag, { value: "Module" }));
var un = `precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out vec4 target;

{{ GLOBALS }}

void computeReadback(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        computeReadback(index);
    } else {
        target = vec4(0.0, 0.0, 0.0, 0.0);
    }
}`;
const sA = class sA {
  constructor({ renderer: A } = {}) {
    this.renderer = A, this.capacity = 0, this.count = 0;
  }
  dispose() {
    this.target && (this.target.dispose(), this.target = void 0);
  }
  // Ensure we have a buffer large enough for the readback of count indices.
  // Pass in previous bufer of the desired type.
  ensureBuffer(A, I) {
    const Q = Math.ceil(Math.max(1, A) / X) * X * 4;
    if (I.byteLength >= Q)
      return I;
    const C = new ArrayBuffer(Q);
    if (I instanceof ArrayBuffer)
      return C;
    const E = I.constructor;
    return new E(C);
  }
  // Ensure our render target is large enough for the readback of capacity indices.
  ensureCapacity(A) {
    const { width: I, height: B, depth: Q, maxSplats: C } = dA(A);
    (!this.target || C > this.capacity) && (this.dispose(), this.capacity = C, this.target = new a.WebGLArrayRenderTarget(I, B, Q, {
      depthBuffer: !1,
      stencilBuffer: !1,
      generateMipmaps: !1,
      magFilter: a.NearestFilter,
      minFilter: a.NearestFilter
    }), this.target.texture.format = a.RGBAFormat, this.target.texture.type = a.UnsignedByteType, this.target.texture.internalFormat = "RGBA8");
  }
  // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(A) {
    let I = sA.readbackProgram.get(A);
    if (!I) {
      const Q = YA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: C }) => (A.inputs.index = C, { rgba8: new vI({ rgba8: A.outputs.rgba8 }) })
      );
      sA.programTemplate || (sA.programTemplate = new TI(un)), I = new VI({
        graph: Q,
        inputs: { index: "index" },
        outputs: { rgba8: "target" },
        template: sA.programTemplate
      }), Object.assign(I.uniforms, {
        targetLayer: { value: 0 },
        targetBase: { value: 0 },
        targetCount: { value: 0 }
      }), sA.readbackProgram.set(A, I);
    }
    const B = I.prepareMaterial();
    return sA.mesh.material = B, { program: I, material: B };
  }
  saveRenderState(A) {
    return {
      xrPresenting: A.xr.isPresenting,
      autoClear: A.autoClear,
      scissorTest: A.getScissorTest(),
      pixelRatio: A.getPixelRatio()
    };
  }
  resetRenderState(A, I) {
    A.setRenderTarget(null), A.setPixelRatio(I.pixelRatio), A.xr.isPresenting = I.xrPresenting, A.autoClear = I.autoClear, A.setScissorTest(I.scissorTest);
  }
  process({
    count: A,
    material: I
  }) {
    const B = this.renderer;
    if (!B)
      throw new Error("No renderer");
    if (!this.target)
      throw new Error("No target");
    const Q = X * WA;
    I.uniforms.targetBase.value = 0, I.uniforms.targetCount.value = A;
    let C = 0;
    for (; C < A; ) {
      const E = Math.floor(C / Q), t = E * Q, i = Math.min(
        WA,
        Math.ceil((A - t) / X)
      );
      I.uniforms.targetLayer.value = E, B.setPixelRatio(1), B.setRenderTarget(this.target, E), B.xr.isPresenting = !1, B.autoClear = !1, B.setScissorTest(!0), B.setScissor(0, 0, X, i), B.render(sA.scene, sA.camera), C += X * i;
    }
    this.count = A;
  }
  async read({
    readback: A
  }) {
    const I = this.renderer;
    if (!I)
      throw new Error("No renderer");
    if (!this.target)
      throw new Error("No target");
    const B = Math.ceil(this.count / X) * X;
    if (A.byteLength < B * 4)
      throw new Error(
        `Readback buffer too small: ${A.byteLength} < ${B * 4}`
      );
    const Q = new Uint8Array(
      A instanceof ArrayBuffer ? A : A.buffer
    ), C = X * WA;
    let E = 0;
    const t = [];
    for (; E < this.count; ) {
      const i = Math.floor(E / C), e = i * C, n = Math.min(
        WA,
        Math.ceil((this.count - e) / X)
      );
      I.setPixelRatio(1), I.setRenderTarget(this.target, i);
      const s = X * n * 4, o = Q.subarray(
        e * 4,
        e * 4 + s
      ), r = I == null ? void 0 : I.readRenderTargetPixelsAsync(
        this.target,
        0,
        0,
        X,
        n,
        o
      );
      t.push(r), E += X * n;
    }
    return Promise.all(t).then(() => A);
  }
  // Perform render operation to run the Rgba8Readback program
  // but don't perform the readback yet.
  render({
    reader: A,
    count: I,
    renderer: B
  }) {
    if (this.renderer = B || this.renderer, !this.renderer)
      throw new Error("No renderer");
    this.ensureCapacity(I);
    const { program: Q, material: C } = this.prepareProgramMaterial(A);
    Q.update();
    const E = this.saveRenderState(this.renderer);
    this.process({ count: I, material: C }), this.resetRenderState(this.renderer, E);
  }
  // Perform a readback of the render target, returning a buffer of the
  // given type.
  async readback({
    readback: A
  }) {
    if (!this.renderer)
      throw new Error("No renderer");
    const I = this.saveRenderState(this.renderer), B = this.read({ readback: A });
    return this.resetRenderState(this.renderer, I), B;
  }
  // Perform a render and readback operation for the given Rgba8Readback,
  // and readback buffer (call ensureBuffer first).
  async renderReadback({
    reader: A,
    count: I,
    renderer: B,
    readback: Q
  }) {
    if (this.renderer = B || this.renderer, !this.renderer)
      throw new Error("No renderer");
    this.ensureCapacity(I);
    const { program: C, material: E } = this.prepareProgramMaterial(A);
    C.update();
    const t = this.saveRenderState(this.renderer);
    this.process({ count: I, material: E });
    const i = this.read({ readback: Q });
    return this.resetRenderState(this.renderer, t), i;
  }
  getTexture() {
    var A;
    return (A = this.target) == null ? void 0 : A.texture;
  }
};
sA.programTemplate = null, sA.readbackProgram = /* @__PURE__ */ new Map(), sA.geometry = new a.PlaneGeometry(2, 2), sA.mesh = new a.Mesh(
  sA.geometry,
  new a.RawShaderMaterial({ visible: !1 })
), sA.scene = new a.Scene().add(sA.mesh), sA.camera = new a.Camera();
let II = sA;
const eA = class eA {
  constructor(A = {}) {
    this.capacity = 0, this.count = 0, this.array = null, this.readback = null, this.source = null, this.needsUpdate = !0, this.dyno = new S({
      key: "rgbaArray",
      type: ht,
      globals: () => [wt],
      value: {
        texture: eA.getEmpty(),
        count: 0
      },
      update: (I) => {
        var B;
        return I.texture = ((B = this.readback) == null ? void 0 : B.getTexture()) ?? this.source ?? eA.getEmpty(), I.count = this.count, I;
      }
    }), A.array ? (this.array = A.array, this.capacity = Math.floor(this.array.length / 4), this.capacity = Math.floor(this.capacity / X) * X, this.count = Math.min(
      this.capacity,
      A.count ?? Number.POSITIVE_INFINITY
    )) : (this.capacity = A.capacity ?? 0, this.count = 0);
  }
  // Free up resources
  dispose() {
    this.readback && (this.readback.dispose(), this.readback = null), this.source && (this.source.dispose(), this.source = null);
  }
  // Ensure that our array is large enough to hold capacity RGBA8 values.
  ensureCapacity(A) {
    var I;
    if (!this.array || A > (((I = this.array) == null ? void 0 : I.length) ?? 0) / 4) {
      this.capacity = dA(A).maxSplats;
      const B = new Uint8Array(this.capacity * 4);
      this.array && B.set(this.array), this.array = B;
    }
    return this.array;
  }
  // Get the THREE.DataArrayTexture from either the readback or the source.
  getTexture() {
    var I;
    let A = (I = this.readback) == null ? void 0 : I.getTexture();
    return (this.source || this.array) && (A = this.maybeUpdateSource()), A ?? eA.getEmpty();
  }
  // Create or get a THREE.DataArrayTexture from the data array.
  maybeUpdateSource() {
    if (!this.array)
      throw new Error("No array");
    if (this.needsUpdate || !this.source) {
      if (this.needsUpdate = !1, this.source) {
        const { width: A, height: I, depth: B } = this.source.image;
        this.capacity !== A * I * B && (this.source.dispose(), this.source = null);
      }
      if (this.source)
        this.array.buffer !== this.source.image.data.buffer && (this.source.image.data = new Uint8Array(this.array.buffer));
      else {
        const { width: A, height: I, depth: B } = dA(this.capacity);
        this.source = new a.DataArrayTexture(
          this.array,
          A,
          I,
          B
        ), this.source.format = a.RGBAFormat, this.source.type = a.UnsignedByteType, this.source.internalFormat = "RGBA8", this.source.needsUpdate = !0;
      }
      this.source.needsUpdate = !0;
    }
    return this.source;
  }
  // Generate the RGBA8 values from a Rgba8Readback dyno program.
  render({
    reader: A,
    count: I,
    renderer: B
  }) {
    this.readback || (this.readback = new II({ renderer: B })), this.readback.render({ reader: A, count: I, renderer: B }), this.capacity = this.readback.capacity, this.count = this.readback.count;
  }
  // Extract the RGBA8 values from a PackedSplats collection.
  fromPackedSplats({
    packedSplats: A,
    base: I,
    count: B,
    renderer: Q
  }) {
    const { dynoSplats: C, dynoBase: E, dynoCount: t, reader: i } = eA.makeDynos();
    return C.packedSplats = A, E.value = I, t.value = B, this.render({ reader: i, count: B, renderer: Q }), this;
  }
  // Read back the RGBA8 values from the readback buffer.
  async read() {
    if (!this.readback)
      throw new Error("No readback");
    return (!this.array || this.array.length < this.count * 4) && (this.array = new Uint8Array(this.capacity * 4)), (await this.readback.readback({ readback: this.array })).subarray(0, this.count * 4);
  }
  // Can be used where you need an uninitialized THREE.DataArrayTexture like
  // a uniform you will update with the result of this.getTexture() later.
  static getEmpty() {
    if (!eA.emptySource) {
      const A = new Uint8Array(4);
      eA.emptySource = new a.DataArrayTexture(A, 1, 1, 1), eA.emptySource.format = a.RGBAFormat, eA.emptySource.type = a.UnsignedByteType, eA.emptySource.internalFormat = "RGBA8", eA.emptySource.needsUpdate = !0;
    }
    return eA.emptySource;
  }
  // Create a dyno program that can extract RGBA8 values from a PackedSplats
  static makeDynos() {
    if (!eA.dynos) {
      const A = new zI(), I = new fg({ value: 0 }), B = new fg({ value: 0 }), Q = YA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: C }) => {
          if (!C)
            throw new Error("index is undefined");
          C = NA(C, I);
          const E = DB(
            A,
            C,
            I,
            B
          );
          return { rgba8: pg(E).outputs.rgba };
        }
      );
      eA.dynos = { dynoSplats: A, dynoBase: I, dynoCount: B, reader: Q };
    }
    return eA.dynos;
  }
};
eA.emptySource = null, eA.dynos = null;
let YI = eA;
const ht = { type: "RgbaArray" }, wt = aA(`
  struct RgbaArray {
    sampler2DArray texture;
    int count;
  };
`);
function dn(g, A) {
  return new T({
    inTypes: { rgba: ht, index: "int" },
    outTypes: { rgba: "vec4" },
    inputs: { rgba: g, index: A },
    globals: () => [wt],
    statements: ({ inputs: B, outputs: Q }) => mA(`
        if ((index >= 0) && (index < ${B.rgba}.count)) {
          ${Q.rgba} = texelFetch(${B.rgba}.texture, splatTexCoord(index), 0);
        } else {
          ${Q.rgba} = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `)
  }).outputs.rgba;
}
var Gn = /* @__PURE__ */ ((g) => (g.ALL = "all", g.PLANE = "plane", g.SPHERE = "sphere", g.BOX = "box", g.ELLIPSOID = "ellipsoid", g.CYLINDER = "cylinder", g.CAPSULE = "capsule", g.INFINITE_CONE = "infinite_cone", g))(Gn || {});
function Mn(g) {
  switch (g) {
    case "all":
      return 0;
    case "plane":
      return 1;
    case "sphere":
      return 2;
    case "box":
      return 3;
    case "ellipsoid":
      return 4;
    case "cylinder":
      return 5;
    case "capsule":
      return 6;
    case "infinite_cone":
      return 7;
    default:
      throw new Error(`Unknown SDF type: ${g}`);
  }
}
var Nn = /* @__PURE__ */ ((g) => (g.MULTIPLY = "multiply", g.SET_RGB = "set_rgb", g.ADD_RGBA = "add_rgba", g))(Nn || {});
function pn(g) {
  switch (g) {
    case "multiply":
      return 0;
    case "set_rgb":
      return 1;
    case "add_rgba":
      return 2;
    default:
      throw new Error(`Unknown blend mode: ${g}`);
  }
}
class kn extends a.Object3D {
  constructor(A = {}) {
    super();
    const { type: I, invert: B, opacity: Q, color: C, displace: E, radius: t } = A;
    this.type = I ?? "sphere", this.invert = B ?? !1, this.opacity = Q ?? 1, this.color = C ?? new a.Color(1, 1, 1), this.displace = E ?? new a.Vector3(0, 0, 0), this.radius = t ?? 0;
  }
}
const iI = class iI extends a.Object3D {
  constructor(A = {}) {
    const {
      name: I,
      rgbaBlendMode: B = "multiply",
      sdfSmooth: Q = 0,
      softEdge: C = 0,
      invert: E = !1,
      sdfs: t = null
    } = A;
    super(), this.rgbaBlendMode = B, this.sdfSmooth = Q, this.softEdge = C, this.invert = E, this.sdfs = t, this.ordering = iI.nextOrdering++, this.name = I ?? `Edit ${this.ordering}`;
  }
  addSdf(A) {
    this.sdfs == null && (this.sdfs = []), this.sdfs.push(A);
  }
  removeSdf(A) {
    this.sdfs != null && (this.sdfs = this.sdfs.filter((I) => I !== A));
  }
};
iI.nextOrdering = 1;
let BI = iI;
class Fn {
  constructor({ maxSdfs: A, maxEdits: I }) {
    this.maxSdfs = Math.max(16, A ?? 0), this.numSdfs = 0, this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4), this.sdfFloatData = new Float32Array(this.sdfData.buffer), this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs), this.dynoSdfArray = new S({
      key: "sdfArray",
      type: Dt,
      globals: () => [lt],
      value: {
        numSdfs: 0,
        sdfTexture: this.sdfTexture
      },
      update: (B) => (B.numSdfs = this.numSdfs, B.sdfTexture = this.sdfTexture, B)
    }), this.maxEdits = Math.max(16, I ?? 0), this.numEdits = 0, this.editData = new Uint32Array(this.maxEdits * 4), this.editFloatData = new Float32Array(this.editData.buffer), this.dynoNumEdits = new fg({ value: 0 }), this.dynoEdits = this.newEdits(this.editData, this.maxEdits);
  }
  newSdfTexture(A, I) {
    const B = new a.DataTexture(
      A,
      8,
      I,
      a.RGBAIntegerFormat,
      a.UnsignedIntType
    );
    return B.internalFormat = "RGBA32UI", B.needsUpdate = !0, B;
  }
  newEdits(A, I) {
    return new S({
      key: "edits",
      type: "uvec4",
      count: I,
      globals: () => [yt],
      value: A
    });
  }
  // Ensure our SDF texture and edits uniform array have enough capacity.
  // Reallocate if not.
  ensureCapacity({
    maxSdfs: A,
    maxEdits: I
  }) {
    let B = !1;
    return A > this.sdfTexture.image.height && (this.sdfTexture.dispose(), this.maxSdfs = Math.max(this.maxSdfs * 2, A), this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4), this.sdfFloatData = new Float32Array(this.sdfData.buffer), this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs)), I > (this.dynoEdits.count ?? 0) && (this.maxEdits = Math.max(this.maxEdits * 2, I), this.editData = new Uint32Array(this.maxEdits * 4), this.editFloatData = new Float32Array(this.editData.buffer), this.dynoEdits = this.newEdits(this.editData, this.maxEdits), B = !0), B;
  }
  updateEditData(A, I) {
    const B = this.editData[A] !== I;
    return this.editData[A] = I, B;
  }
  updateEditFloatData(A, I) {
    ag[0] = I;
    const B = this.editFloatData[A] !== ag[0];
    return B && (this.editFloatData[A] = ag[0]), B;
  }
  encodeEdit(A, {
    sdfFirst: I,
    sdfCount: B,
    invert: Q,
    rgbaBlendMode: C,
    softEdge: E,
    sdfSmooth: t
  }) {
    const i = A * 4;
    let e = !1;
    return e = this.updateEditData(i + 0, C | (Q ? 256 : 0)) || e, e = this.updateEditData(i + 1, I | B << 16) || e, e = this.updateEditFloatData(i + 2, E) || e, e = this.updateEditFloatData(i + 3, t) || e, e;
  }
  updateSdfData(A, I) {
    const B = this.sdfData[A] !== I;
    return this.sdfData[A] = I, B;
  }
  updateSdfFloatData(A, I) {
    ag[0] = I;
    const B = this.sdfFloatData[A] !== ag[0];
    return B && (this.sdfFloatData[A] = ag[0]), B;
  }
  encodeSdf(A, {
    sdfType: I,
    invert: B,
    center: Q,
    quaternion: C,
    scale: E,
    sizes: t
  }, i) {
    const e = A * 32, n = I | (B ? 256 : 0);
    let s = !1;
    s = this.updateSdfFloatData(e + 0, (Q == null ? void 0 : Q.x) ?? 0) || s, s = this.updateSdfFloatData(e + 1, (Q == null ? void 0 : Q.y) ?? 0) || s, s = this.updateSdfFloatData(e + 2, (Q == null ? void 0 : Q.z) ?? 0) || s, s = this.updateSdfData(e + 3, n) || s, s = this.updateSdfFloatData(e + 4, (C == null ? void 0 : C.x) ?? 0) || s, s = this.updateSdfFloatData(e + 5, (C == null ? void 0 : C.y) ?? 0) || s, s = this.updateSdfFloatData(e + 6, (C == null ? void 0 : C.z) ?? 0) || s, s = this.updateSdfFloatData(e + 7, (C == null ? void 0 : C.w) ?? 0) || s, s = this.updateSdfFloatData(e + 8, (E == null ? void 0 : E.x) ?? 0) || s, s = this.updateSdfFloatData(e + 9, (E == null ? void 0 : E.y) ?? 0) || s, s = this.updateSdfFloatData(e + 10, (E == null ? void 0 : E.z) ?? 0) || s, s = this.updateSdfData(e + 11, 0) || s, s = this.updateSdfFloatData(e + 12, (t == null ? void 0 : t.x) ?? 0) || s, s = this.updateSdfFloatData(e + 13, (t == null ? void 0 : t.y) ?? 0) || s, s = this.updateSdfFloatData(e + 14, (t == null ? void 0 : t.z) ?? 0) || s, s = this.updateSdfFloatData(e + 15, (t == null ? void 0 : t.w) ?? 0) || s;
    const o = Math.min(4, i.length);
    for (let r = 0; r < o; ++r) {
      const c = e + 16 + r * 4;
      s = this.updateSdfFloatData(c + 0, i[r].x) || s, s = this.updateSdfFloatData(c + 1, i[r].y) || s, s = this.updateSdfFloatData(c + 2, i[r].z) || s, s = this.updateSdfFloatData(c + 3, i[r].w) || s;
    }
    return s;
  }
  // Update the SDFs and edits from an array of SplatEdits and their
  // associated SplatEditSdfs, updating it for the dyno shader program.
  update(A) {
    const I = A.reduce((s, { sdfs: o }) => s + o.length, 0), B = this.ensureCapacity({
      maxEdits: A.length,
      maxSdfs: I
    }), Q = [new a.Vector4(), new a.Vector4()], C = new a.Vector3(), E = new a.Quaternion(), t = new a.Vector3(), i = new a.Vector4();
    let e = 0, n = B;
    A.length !== this.dynoNumEdits.value && (this.dynoNumEdits.value = A.length, this.numEdits = A.length, n = !0);
    for (const [s, { edit: o, sdfs: r }] of A.entries()) {
      n = this.encodeEdit(s, {
        sdfFirst: e,
        sdfCount: r.length,
        invert: o.invert,
        rgbaBlendMode: pn(o.rgbaBlendMode),
        softEdge: o.softEdge,
        sdfSmooth: o.sdfSmooth
      }) || n;
      let c = !1;
      for (const h of r)
        i.set(h.scale.x, h.scale.y, h.scale.z, h.radius), h.scale.setScalar(1), h.updateMatrixWorld(), h.matrixWorld.clone().invert().decompose(C, E, t), h.scale.set(i.x, i.y, i.z), h.updateMatrixWorld(), Q[0].set(h.color.r, h.color.g, h.color.b, h.opacity), Q[1].set(h.displace.x, h.displace.y, h.displace.z, 1), c = this.encodeSdf(
          e,
          {
            sdfType: Mn(h.type),
            invert: h.invert,
            center: C,
            quaternion: E,
            scale: t,
            sizes: i
          },
          Q
        ) || c, e += 1;
      this.numSdfs = e, c && (this.sdfTexture.needsUpdate = !0), n || (n = c);
    }
    return { updated: n, dynoUpdated: B };
  }
  // Modify a Gsplat in a dyno shader program using the current edits and SDFs.
  modify(A) {
    return Rn(
      A,
      this.dynoSdfArray,
      this.dynoNumEdits,
      this.dynoEdits
    );
  }
}
const Dt = { type: "SdfArray" }, lt = aA(`
  struct SdfArray {
    int numSdfs;
    usampler2D sdfTexture;
  };

  void unpackSdfArray(
    usampler2D sdfTexture, int sdfIndex, out uint flags,
    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,
    int numValues, out vec4 values[4]
  ) {
    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);
    flags = temp.w;
    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);
    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);
    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);
    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    for (int i = 0; i < numValues; ++i) {
      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);
      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));
    }
  }

  const uint SDF_FLAG_TYPE = 0xFFu;
  const uint SDF_FLAG_INVERT = 1u << 8u;

  const uint SDF_TYPE_ALL = 0u;
  const uint SDF_TYPE_PLANE = 1u;
  const uint SDF_TYPE_SPHERE = 2u;
  const uint SDF_TYPE_BOX = 3u;
  const uint SDF_TYPE_ELLIPSOID = 4u;
  const uint SDF_TYPE_CYLINDER = 5u;
  const uint SDF_TYPE_CAPSULE = 6u;
  const uint SDF_TYPE_INFINITE_CONE = 7u;

  float evaluateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 outValues[4]
  ) {
    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;
    float maxExp = -1.0 / 0.0;
    for (int i = 0; i < numValues; ++i) {
        outValues[i] = vec4(0.0);
    }

    uint flags;
    vec3 center, scale;
    vec4 quaternion, sizes;
    vec4 values[4];

    int sdfLast = min(sdfFirst + sdfCount, numSdfs);
    for (int index = sdfFirst; index < sdfLast; ++index) {
      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);
      uint sdfType = flags & SDF_FLAG_TYPE;
      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;

      float distance;
      switch (sdfType) {
        case SDF_TYPE_ALL:
          distance = -1.0 / 0.0;
          break;
        case SDF_TYPE_PLANE: {
          distance = sdfPos.z;
          break;
        }
        case SDF_TYPE_SPHERE: {
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_BOX: {
          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;
          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;
          break;
        }
        case SDF_TYPE_ELLIPSOID: {
          vec3 sizes = sizes.xyz;
          float k0 = length(sdfPos / sizes);
          float k1 = length(sdfPos / dot(sizes, sizes));
          distance = k0 * (k0 - 1.0) / k1;
          break;
        }
        case SDF_TYPE_CYLINDER: {
          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;
          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
          break;
        }
        case SDF_TYPE_CAPSULE: {
          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_INFINITE_CONE: {
          float angle = 0.25 * PI * sizes.w;
          vec2 c = vec2(sin(angle), cos(angle));
          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);
          float d = length(q - c * max(dot(q, c), 0.0));
          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);
          break;
        }
      }

      if ((flags & SDF_FLAG_INVERT) != 0u) {
        distance = -distance;
      }

      if (smoothK == 0.0) {
        if (distance < distanceAccum) {
          distanceAccum = distance;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] = values[i];
          }
        }
      } else {
        float scaledDistance = -distance / smoothK;
        if (scaledDistance > maxExp) {
          float scale = exp(maxExp - scaledDistance);
          distanceAccum *= scale;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] *= scale;
          }
          maxExp = scaledDistance;
        }

        float weight = exp(scaledDistance - maxExp);
        distanceAccum += weight;
        for (int i = 0; i < numValues; ++i) {
          outValues[i] += weight * values[i];
        }
      }
    }

    if (smoothK == 0.0) {
      return distanceAccum;
    } else {
      // Very distant SDFs may result in 0 accumulation
      if (distanceAccum == 0.0) {
        return 1.0 / 0.0;
      }
      for (int i = 0; i < numValues; ++i) {
        outValues[i] /= distanceAccum;
      }
      return (-log(distanceAccum) - maxExp) * smoothK;
    }
  }

  float modulateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 values[4],
    float softEdge, bool invert
  ) {
    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);
    if (invert) {
      distance = -distance;
    }

    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)
      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);
  }
`), yt = aA(`
  const uint EDIT_FLAG_BLEND = 0xFFu;
  const uint EDIT_BLEND_MULTIPLY = 0u;
  const uint EDIT_BLEND_SET_RGB = 1u;
  const uint EDIT_BLEND_ADD_RGBA = 2u;
  const uint EDIT_FLAG_INVERT = 0x100u;

  void decodeEdit(
    uvec4 packedEdit, out int sdfFirst, out int sdfCount,
    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth
  ) {
    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;
    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;

    sdfFirst = int(packedEdit.y & 0xFFFFu);
    sdfCount = int(packedEdit.y >> 16u);

    softEdge = uintBitsToFloat(packedEdit.z);
    sdfSmooth = uintBitsToFloat(packedEdit.w);
  }

  void applyRgbaDisplaceEdit(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,
    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba
  ) {
    vec4 values[4];
    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);
    // On Android, moving values[0] is necessary to work around a compiler bug.
    vec4 sdfRgba = values[0];
    vec4 sdfDisplaceScale = values[1];

    vec4 target;
    switch (rgbaBlendMode) {
      case EDIT_BLEND_MULTIPLY:
        target = rgba * sdfRgba;
        break;
      case EDIT_BLEND_SET_RGB:
        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);
        break;
      case EDIT_BLEND_ADD_RGBA:
        target = rgba + sdfRgba;
        break;
      default:
        // Debug output if blend mode not set
        target = vec4(fract(pos), 1.0);
    }
    rgba = mix(rgba, target, modulate);
    pos += sdfDisplaceScale.xyz * modulate;
  }

  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {
    int sdfFirst, sdfCount;
    bool invert;
    uint rgbaBlendMode;
    float softEdge, sdfSmooth;
    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);
    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);
  }
`);
function Rn(g, A, I, B) {
  return new T({
    inTypes: {
      gsplat: BA,
      sdfArray: Dt,
      numEdits: "int",
      rgbaDisplaceEdits: "uvec4"
    },
    outTypes: { gsplat: BA },
    globals: () => [lt, yt],
    inputs: { gsplat: g, sdfArray: A, numEdits: I, rgbaDisplaceEdits: B },
    statements: ({ inputs: C, outputs: E }) => {
      const { sdfArray: t, numEdits: i, rgbaDisplaceEdits: e } = C, { gsplat: n } = E;
      return mA(`
        ${n} = ${C.gsplat};
        if (isGsplatActive(${n}.flags)) {
          for (int editIndex = 0; editIndex < ${i}; ++editIndex) {
            applyPackedRgbaDisplaceEdit(
              ${e}[editIndex], ${t}.sdfTexture, ${t}.numSdfs,
              ${n}.center, ${n}.rgba
            );
          }
        }
      `);
    }
  }).outputs.gsplat;
}
const ag = new Float32Array(1);
class Jn {
  constructor(A) {
    this.modifier = A, this.cache = /* @__PURE__ */ new Map();
  }
  apply(A) {
    let I = this.cache.get(A);
    return I || (I = YA(
      { index: "int" },
      { gsplat: BA },
      ({ index: B }) => {
        const { gsplat: Q } = A.apply({ index: B });
        return this.modifier.apply({ gsplat: Q });
      }
    ), this.cache.set(A, I)), I;
  }
}
class hg {
  // Create the dyno uniforms that parameterize the transform, setting them
  // to initial values that are different from any valid transform.
  constructor() {
    this.scale = new Cg({ value: Number.NEGATIVE_INFINITY }), this.rotate = new bg({
      value: new a.Quaternion(
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      )
    }), this.translate = new yg({
      value: new a.Vector3(
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      )
    });
  }
  // Apply the transform to a Vec3 position in a dyno program.
  apply(A) {
    return VE(A, {
      scale: this.scale,
      rotate: this.rotate,
      translate: this.translate
    });
  }
  applyDir(A) {
    return TE(A, {
      rotate: this.rotate
    });
  }
  // Apply the transform to a Gsplat in a dyno program.
  applyGsplat(A) {
    return qI(A, {
      scale: this.scale,
      rotate: this.rotate,
      translate: this.translate
    });
  }
  // Update the uniforms to match the given transform matrix.
  updateFromMatrix(A) {
    const I = new a.Vector3(), B = new a.Quaternion(), Q = new a.Vector3();
    A.decompose(Q, B, I);
    const C = (I.x + I.y + I.z) / 3;
    let E = !1;
    return C !== this.scale.value && (this.scale.value = C, E = !0), Q.equals(this.translate.value) || (this.translate.value.copy(Q), E = !0), B.equals(this.rotate.value) || (this.rotate.value.copy(B), E = !0), E;
  }
  // Update this transform to match the object's to-world transform.
  update(A) {
    return A.updateMatrixWorld(), this.updateFromMatrix(A.matrixWorld);
  }
}
class nI extends a.Object3D {
  constructor({
    numSplats: A,
    generator: I,
    construct: B,
    update: Q
  }) {
    if (super(), this.numSplats = A ?? 0, this.generator = I, this.frameUpdate = Q, this.version = 0, B) {
      const C = B(this);
      Object.assign(this, C);
    }
  }
  updateVersion() {
    this.version += 1;
  }
  set needsUpdate(A) {
    A && this.updateVersion();
  }
}
const OA = class OA extends nI {
  constructor(A = {}) {
    const I = new hg(), B = new hg(), Q = new hg(), C = new hg(), E = new bg({
      value: new a.Vector4(
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY
      )
    }), t = new Cg({ value: 0 }), i = new Cg({ value: 0 }), e = {
      transform: I,
      viewToWorld: B,
      worldToView: Q,
      viewToObject: C,
      recolor: E,
      time: t,
      deltaTime: i
    };
    if (super({
      update: ({ time: n, deltaTime: s, viewToWorld: o, globalEdits: r }) => this.update({ time: n, deltaTime: s, viewToWorld: o, globalEdits: r })
    }), this.isInitialized = !1, this.recolor = new a.Color(1, 1, 1), this.opacity = 1, this.enableViewToObject = !1, this.enableViewToWorld = !1, this.enableWorldToView = !1, this.skinning = null, this.edits = null, this.rgbaDisplaceEdits = null, this.splatRgba = null, this.maxSh = 3, this.packedSplats = A.packedSplats ?? new ZA(), this.numSplats = this.packedSplats.numSplats, this.editable = A.editable ?? !0, this.onFrame = A.onFrame, this.context = e, this.objectModifier = A.objectModifier, this.worldModifier = A.worldModifier, this.updateGenerator(), A.url || A.fileBytes || A.constructSplats || A.packedSplats && !A.packedSplats.isInitialized)
      this.initialized = this.asyncInitialize(A).then(async () => {
        if (this.updateGenerator(), this.isInitialized = !0, A.onLoad) {
          const n = A.onLoad(this);
          n instanceof Promise && await n;
        }
        return this;
      });
    else if (this.isInitialized = !0, this.initialized = Promise.resolve(this), A.onLoad) {
      const n = A.onLoad(this);
      n instanceof Promise && (this.initialized = n.then(() => this));
    }
  }
  async asyncInitialize(A) {
    const { url: I, fileBytes: B, fileType: Q, fileName: C, maxSplats: E, constructSplats: t } = A;
    if (I || B || t) {
      const i = {
        url: I,
        fileBytes: B,
        fileType: Q,
        fileName: C,
        maxSplats: E,
        construct: t
      };
      this.packedSplats.reinitialize(i);
    }
    this.packedSplats && (await this.packedSplats.initialized, this.numSplats = this.packedSplats.numSplats, this.updateGenerator());
  }
  static async staticInitialize() {
    await KI(), OA.isStaticInitialized = !0;
  }
  // Creates a new Gsplat with the provided parameters (all values in "float" space,
  // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,
  // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential
  // doubling strategy to fit the new data, so it's fairly efficient to just
  // pushSplat(...) each Gsplat you want to create in a loop.
  pushSplat(A, I, B, Q, C) {
    this.packedSplats.pushSplat(A, I, B, Q, C);
  }
  // This method iterates over all Gsplats in this instance's packedSplats,
  // invoking the provided callback with index: number in 0..=(this.numSplats-1) and
  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
  // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).
  // Note that the objects passed in as center etc. are the same for every callback
  // invocation: these objects are reused for efficiency. Changing these values has
  // no effect as they are decoded/unpacked copies of the underlying data. To update
  // the packedSplats, call .packedSplats.setSplat(index, center, scales,
  // quaternion, opacity, color).
  forEachSplat(A) {
    this.packedSplats.forEachSplat(A);
  }
  // Call this when you are finished with the SplatMesh and want to free
  // any buffers it holds (via packedSplats).
  dispose() {
    this.packedSplats.dispose();
  }
  constructGenerator(A) {
    const { transform: I, viewToObject: B, recolor: Q } = A, C = YA(
      { index: "int" },
      { gsplat: BA },
      ({ index: E }) => {
        if (!E)
          throw new Error("index is undefined");
        let t = mg(this.packedSplats.dyno, E);
        if (this.maxSh >= 1) {
          const { sh1Texture: e, sh2Texture: n, sh3Texture: s } = this.ensureShTextures();
          if (e) {
            const o = B.translate, { center: r } = pg(t).outputs, c = aE(Sg(r, o));
            let h = Yn(t, e, c);
            this.maxSh >= 2 && n && (h = NA(h, Un(t, n, c))), this.maxSh >= 3 && s && (h = NA(h, xn(t, s, c)));
            let { rgba: w } = pg(t).outputs;
            w = NA(w, nE(h, gA("float", 0))), t = lg({ gsplat: t, rgba: w });
          }
        }
        if (this.splatRgba) {
          const e = dn(this.splatRgba.dyno, E);
          t = lg({ gsplat: t, rgba: e });
        }
        this.skinning && (t = this.skinning.modify(t)), this.objectModifier && (t = this.objectModifier.apply({ gsplat: t }).gsplat), t = I.applyGsplat(t);
        const i = rA(Q, pg(t).outputs.rgba);
        return t = lg({ gsplat: t, rgba: i }), this.rgbaDisplaceEdits && (t = this.rgbaDisplaceEdits.modify(t)), this.worldModifier && (t = this.worldModifier.apply({ gsplat: t }).gsplat), { gsplat: t };
      }
    );
    this.generator = C;
  }
  // Call this whenever something changes in the Gsplat processing pipeline,
  // for example changing maxSh or updating objectModifier or worldModifier.
  // Compiled generators are cached for efficiency and re-use when the same
  // pipeline structure emerges after successive changes.
  updateGenerator() {
    this.constructGenerator(this.context);
  }
  // This is called automatically by ForgeRenderer and you should not have to
  // call it. It updates parameters for the generated pipeline and calls
  // updateGenerator() if the pipeline needs to change.
  update({
    time: A,
    viewToWorld: I,
    deltaTime: B,
    globalEdits: Q
  }) {
    var w;
    this.numSplats = this.packedSplats.numSplats, this.context.time.value = A, this.context.deltaTime.value = B, OA.dynoTime.value = A;
    const { transform: C, viewToObject: E, recolor: t } = this.context;
    let i = C.update(this);
    this.context.viewToWorld.updateFromMatrix(I) && this.enableViewToWorld && (i = !0);
    const e = I.clone().invert();
    this.context.worldToView.updateFromMatrix(e) && this.enableWorldToView && (i = !0);
    const o = new a.Matrix4().compose(
      C.translate.value,
      C.rotate.value,
      new a.Vector3().setScalar(C.scale.value)
    ).invert().multiply(I);
    E.updateFromMatrix(o) && (this.enableViewToObject || this.packedSplats.extra.sh1) && (i = !0);
    const r = new a.Vector4(
      this.recolor.r,
      this.recolor.g,
      this.recolor.b,
      this.opacity
    );
    r.equals(t.value) || (t.value.copy(r), i = !0);
    const c = this.editable ? (this.edits ?? []).concat(Q) : [];
    this.editable && !this.edits && this.traverseVisible((D) => {
      D instanceof BI && c.push(D);
    }), c.sort((D, y) => D.ordering - y.ordering);
    const h = c.map((D) => {
      if (D.sdfs != null)
        return { edit: D, sdfs: D.sdfs };
      const y = [];
      return D.traverseVisible((l) => {
        l instanceof kn && y.push(l);
      }), { edit: D, sdfs: y };
    });
    if (h.length > 0 && !this.rgbaDisplaceEdits) {
      const D = h.length, y = h.reduce(
        (l, d) => l + d.sdfs.length,
        0
      );
      this.rgbaDisplaceEdits = new Fn({
        maxEdits: D,
        maxSdfs: y
      }), this.updateGenerator();
    }
    if (this.rgbaDisplaceEdits) {
      const D = this.rgbaDisplaceEdits.update(h);
      i || (i = D.updated), D.dynoUpdated && this.updateGenerator();
    }
    i && this.updateVersion(), (w = this.onFrame) == null || w.call(this, { mesh: this, time: A, deltaTime: B });
  }
  // This method conforms to the standard THREE.Raycaster API, performing object-ray
  // intersections using this method to populate the provided intersects[] array
  // with each intersection point.
  raycast(A, I) {
    if (!this.packedSplats.packedArray || !this.packedSplats.numSplats)
      return;
    const { near: B, far: Q, ray: C } = A, E = this.matrixWorld.clone().invert(), t = new a.Matrix3().setFromMatrix4(E), i = C.origin.clone().applyMatrix4(E), e = C.direction.clone().applyMatrix3(t), n = new a.Vector3();
    E.decompose(new a.Vector3(), new a.Quaternion(), n), (n.x * n.y * n.z) ** (1 / 3);
    const o = Vt(
      i.x,
      i.y,
      i.z,
      e.x,
      e.y,
      e.z,
      B,
      Q,
      this.packedSplats.numSplats,
      this.packedSplats.packedArray,
      !0
    );
    for (const r of o) {
      const c = C.direction.clone().multiplyScalar(r).add(C.origin);
      I.push({
        distance: r,
        point: c,
        object: this
      });
    }
  }
  ensureShTextures() {
    if (!this.packedSplats.extra.sh1)
      return {};
    let A = this.packedSplats.extra.sh1Texture;
    if (!A) {
      let Q = this.packedSplats.extra.sh1;
      const { width: C, height: E, depth: t, maxSplats: i } = dA(
        Q.length / 2
      );
      if (Q.length < i * 2) {
        const n = new Uint32Array(i * 2);
        n.set(Q), this.packedSplats.extra.sh1 = n, Q = n;
      }
      const e = new a.DataArrayTexture(Q, C, E, t);
      e.format = a.RGIntegerFormat, e.type = a.UnsignedIntType, e.internalFormat = "RG32UI", e.needsUpdate = !0, A = new kg({
        value: e,
        key: "sh1"
      }), this.packedSplats.extra.sh1Texture = A;
    }
    if (!this.packedSplats.extra.sh2)
      return { sh1Texture: A };
    let I = this.packedSplats.extra.sh2Texture;
    if (!I) {
      let Q = this.packedSplats.extra.sh2;
      const { width: C, height: E, depth: t, maxSplats: i } = dA(
        Q.length / 4
      );
      if (Q.length < i * 4) {
        const n = new Uint32Array(i * 4);
        n.set(Q), this.packedSplats.extra.sh2 = n, Q = n;
      }
      const e = new a.DataArrayTexture(Q, C, E, t);
      e.format = a.RGBAIntegerFormat, e.type = a.UnsignedIntType, e.internalFormat = "RGBA32UI", e.needsUpdate = !0, I = new kg({
        value: e,
        key: "sh2"
      }), this.packedSplats.extra.sh2Texture = I;
    }
    if (!this.packedSplats.extra.sh3)
      return { sh1Texture: A, sh2Texture: I };
    let B = this.packedSplats.extra.sh3Texture;
    if (!B) {
      let Q = this.packedSplats.extra.sh3;
      const { width: C, height: E, depth: t, maxSplats: i } = dA(
        Q.length / 4
      );
      if (Q.length < i * 4) {
        const n = new Uint32Array(i * 4);
        n.set(Q), this.packedSplats.extra.sh3 = n, Q = n;
      }
      const e = new a.DataArrayTexture(Q, C, E, t);
      e.format = a.RGBAIntegerFormat, e.type = a.UnsignedIntType, e.internalFormat = "RGBA32UI", e.needsUpdate = !0, B = new kg({
        value: e,
        key: "sh3"
      }), this.packedSplats.extra.sh3Texture = B;
    }
    return { sh1Texture: A, sh2Texture: I, sh3Texture: B };
  }
};
OA.staticInitialized = OA.staticInitialize(), OA.isStaticInitialized = !1, OA.dynoTime = new Cg({ value: 0 });
let Ag = OA;
const mn = aA(`
  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {
    // Extract sint7 values packed into 2 x uint32
    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;
    vec3 sh1_0 = vec3(ivec3(
      int(packed.x << 25u) >> 25,
      int(packed.x << 18u) >> 25,
      int(packed.x << 11u) >> 25
    )) / 63.0;
    vec3 sh1_1 = vec3(ivec3(
      int(packed.x << 4u) >> 25,
      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,
      int(packed.y << 22u) >> 25
    )) / 63.0;
    vec3 sh1_2 = vec3(ivec3(
      int(packed.y << 15u) >> 25,
      int(packed.y << 8u) >> 25,
      int(packed.y << 1u) >> 25
    )) / 63.0;

    return sh1_0 * (-0.4886025 * viewDir.y)
      + sh1_1 * (0.4886025 * viewDir.z)
      + sh1_2 * (-0.4886025 * viewDir.x);
  }
`), fn = aA(`
  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {
    // Extract sint8 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);
    vec3 sh2_0 = vec3(ivec3(
      int(packed.x << 24u) >> 24,
      int(packed.x << 16u) >> 24,
      int(packed.x << 8u) >> 24
    )) / 127.0;
    vec3 sh2_1 = vec3(ivec3(
      int(packed.x) >> 24,
      int(packed.y << 24u) >> 24,
      int(packed.y << 16u) >> 24
    )) / 127.0;
    vec3 sh2_2 = vec3(ivec3(
      int(packed.y << 8u) >> 24,
      int(packed.y) >> 24,
      int(packed.z << 24u) >> 24
    )) / 127.0;
    vec3 sh2_3 = vec3(ivec3(
      int(packed.z << 16u) >> 24,
      int(packed.z << 8u) >> 24,
      int(packed.z) >> 24
    )) / 127.0;
    vec3 sh2_4 = vec3(ivec3(
      int(packed.w << 24u) >> 24,
      int(packed.w << 16u) >> 24,
      int(packed.w << 8u) >> 24
    )) / 127.0;

    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)
      + sh2_1 * (1.0925484 * viewDir.y * viewDir.z)
      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))
      + sh2_3 * (1.0925484 * viewDir.x * viewDir.z)
      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));
  }
`), Sn = aA(`
  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {
    // Extract sint6 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);
    vec3 sh3_0 = vec3(ivec3(
      int(packed.x << 26u) >> 26,
      int(packed.x << 20u) >> 26,
      int(packed.x << 14u) >> 26
    )) / 31.0;
    vec3 sh3_1 = vec3(ivec3(
      int(packed.x << 8u) >> 26,
      int(packed.x << 2u) >> 26,
      int((packed.x >> 4u) | (packed.y << 28u)) >> 26
    )) / 31.0;
    vec3 sh3_2 = vec3(ivec3(
      int(packed.y << 22u) >> 26,
      int(packed.y << 16u) >> 26,
      int(packed.y << 10u) >> 26
    )) / 31.0;
    vec3 sh3_3 = vec3(ivec3(
      int(packed.y << 4u) >> 26,
      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,
      int(packed.z << 24u) >> 26
    )) / 31.0;
    vec3 sh3_4 = vec3(ivec3(
      int(packed.z << 18u) >> 26,
      int(packed.z << 12u) >> 26,
      int(packed.z << 6u) >> 26
    )) / 31.0;
    vec3 sh3_5 = vec3(ivec3(
      int(packed.z) >> 26,
      int(packed.w << 26u) >> 26,
      int(packed.w << 20u) >> 26
    )) / 31.0;
    vec3 sh3_6 = vec3(ivec3(
      int(packed.w << 14u) >> 26,
      int(packed.w << 8u) >> 26,
      int(packed.w << 2u) >> 26
    )) / 31.0;

    float xx = viewDir.x * viewDir.x;
    float yy = viewDir.y * viewDir.y;
    float zz = viewDir.z * viewDir.z;
    float xy = viewDir.x * viewDir.y;
    float yz = viewDir.y * viewDir.z;
    float zx = viewDir.z * viewDir.x;

    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))
      + sh3_1 * (2.8906114 * xy * viewDir.z) +
      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))
      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))
      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))
      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))
      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));
  }
`);
function Yn(g, A, I) {
  return xg({
    inTypes: { gsplat: BA, sh1: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: g, sh1: A, viewDir: I },
    globals: () => [pA, mn],
    statements: ({ inputs: B, outputs: Q }) => mA(`
        if (isGsplatActive(${B.gsplat}.flags)) {
          ${Q.rgb} = evaluateSH1(${B.gsplat}, ${B.sh1}, ${B.viewDir});
        } else {
          ${Q.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
function Un(g, A, I) {
  return xg({
    inTypes: { gsplat: BA, sh2: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: g, sh2: A, viewDir: I },
    globals: () => [pA, fn],
    statements: ({ inputs: B, outputs: Q }) => mA(`
        if (isGsplatActive(${B.gsplat}.flags)) {
          ${Q.rgb} = evaluateSH2(${B.gsplat}, ${B.sh2}, ${B.viewDir});
        } else {
          ${Q.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
function xn(g, A, I) {
  return xg({
    inTypes: { gsplat: BA, sh3: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: g, sh3: A, viewDir: I },
    globals: () => [pA, Sn],
    statements: ({ inputs: B, outputs: Q }) => mA(`
        if (isGsplatActive(${B.gsplat}.flags)) {
          ${Q.rgb} = evaluateSH3(${B.gsplat}, ${B.sh3}, ${B.viewDir});
        } else {
          ${Q.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
const wg = class wg {
  // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet
  constructor({ fileBytes: A }) {
    this.header = "", this.littleEndian = !0, this.elements = {}, this.comments = [], this.data = null, this.numSplats = 0, this.fileBytes = A instanceof ArrayBuffer ? new Uint8Array(A) : A;
  }
  // Identify and parse the PLY text header (assumed to be <64KB in size).
  // this.elements will contain all the elements in the file, typically
  // "vertex" contains the Gsplat data.
  async parseHeader() {
    const I = new ReadableStream({
      start: (E) => {
        E.enqueue(this.fileBytes.slice(0, 65536)), E.close();
      }
    }).pipeThrough(new TextDecoderStream()).getReader();
    this.header = "";
    const B = `end_header
`;
    for (; ; ) {
      const { value: E, done: t } = await I.read();
      if (t)
        throw new Error("Failed to read header");
      this.header += E;
      const i = this.header.indexOf(B);
      if (i >= 0) {
        this.header = this.header.slice(0, i + B.length);
        break;
      }
    }
    const Q = new TextEncoder().encode(this.header).length;
    this.data = new DataView(this.fileBytes.buffer, Q), this.elements = {};
    let C = null;
    this.comments = [], this.header.trim().split(`
`).forEach((E, t) => {
      const i = E.trim();
      if (t === 0) {
        if (i !== "ply")
          throw new Error("Invalid PLY header");
        return;
      }
      if (i.length === 0)
        return;
      const e = i.split(" ");
      switch (e[0]) {
        case "format":
          if (e[1] === "binary_little_endian")
            this.littleEndian = !0;
          else if (e[1] === "binary_big_endian")
            this.littleEndian = !1;
          else
            throw new Error(`Unsupported PLY format: ${e[1]}`);
          if (e[2] !== "1.0")
            throw new Error(`Unsupported PLY version: ${e[2]}`);
          break;
        case "end_header":
          break;
        case "comment":
          this.comments.push(i.slice(8));
          break;
        case "element": {
          const n = e[1];
          C = {
            name: n,
            count: Number.parseInt(e[2]),
            properties: {}
          }, this.elements[n] = C;
          break;
        }
        case "property":
          if (C == null)
            throw new Error("Property must be inside an element");
          e[1] === "list" ? C.properties[e[4]] = {
            isList: !0,
            type: e[3],
            countType: e[2]
          } : C.properties[e[2]] = {
            isList: !1,
            type: e[1]
          };
          break;
      }
    }), this.elements.vertex && (this.numSplats = this.elements.vertex.count);
  }
  parseData(A) {
    let I = 0;
    const B = this.data;
    if (B == null)
      throw new Error("No data to parse");
    for (const Q in this.elements) {
      const C = this.elements[Q], { count: E, properties: t } = C, i = {}, e = [];
      for (const [s, o] of Object.entries(t))
        o.isList ? (i[s] = [], e.push(() => {
          const r = i[s];
          r.length = vg[o.countType](
            B,
            I,
            this.littleEndian
          ), I += ng[o.countType];
          for (let c = 0; c < r.length; c++)
            r[c] = vg[o.type](
              B,
              I,
              this.littleEndian
            ), I += ng[o.type];
        })) : (i[s] = 0, e.push(() => {
          i[s] = vg[o.type](
            B,
            I,
            this.littleEndian
          ), I += ng[o.type];
        }));
      const n = A(C) ?? (() => {
      });
      for (let s = 0; s < E; s++) {
        for (const o of e)
          o();
        n(s, i);
      }
    }
  }
  // Parse all the Gsplat data in the PLY file in go, invoking the given
  // callbacks for each Gsplat.
  parseSplats(A, I) {
    if (this.elements.vertex == null)
      throw new Error("No vertex element found");
    let B = !1;
    const Q = [];
    let C = 0, E = [], t = [], i = [], e, n, s;
    function o() {
      const D = bn[C];
      E = new Array(3).fill(null).flatMap(
        (y, l) => [0, 1, 2].map((d, u) => `f_rest_${l + u * D / 3}`)
      ), t = new Array(5).fill(null).flatMap(
        (y, l) => [0, 1, 2].map((d, u) => `f_rest_${3 + l + u * D / 3}`)
      ), i = new Array(7).fill(null).flatMap(
        (y, l) => [0, 1, 2].map((d, u) => `f_rest_${8 + l + u * D / 3}`)
      ), e = C >= 1 ? new Float32Array(3 * 3) : void 0, n = C >= 2 ? new Float32Array(5 * 3) : void 0, s = C >= 3 ? new Float32Array(7 * 3) : void 0;
    }
    function r(D, y) {
      if (!e)
        throw new Error("Missing sh1");
      for (const [l, d] of E.entries())
        e[l] = y[d] * 8 / 255 - 4;
      if (n)
        for (const [l, d] of t.entries())
          n[l] = y[d] * 8 / 255 - 4;
      if (s)
        for (const [l, d] of i.entries())
          s[l] = y[d] * 8 / 255 - 4;
      I == null || I(D, e, n, s);
    }
    function c(D) {
      const {
        min_x: y,
        min_y: l,
        min_z: d,
        max_x: u,
        max_y: p,
        max_z: m,
        min_scale_x: M,
        min_scale_y: G,
        min_scale_z: J,
        max_scale_x: k,
        max_scale_y: N,
        max_scale_z: Y,
        min_r: F,
        min_g: f,
        min_b: U,
        max_r: L,
        max_g: K,
        max_b: Z
      } = D.properties;
      if (!y || !l || !d || !u || !p || !m || !M || !G || !J || !k || !N || !Y || !F || !f || !U || !L || !K || !Z)
        throw new Error("Missing PLY chunk properties");
      return B = !0, (QA, z) => {
        const {
          min_x: AA,
          min_y: $,
          min_z: P,
          max_x: j,
          max_y: V,
          max_z: x,
          min_scale_x: uA,
          min_scale_y: iA,
          min_scale_z: b,
          max_scale_x: nA,
          max_scale_y: oA,
          max_scale_z: H,
          min_r: kA,
          min_g: GA,
          min_b: UA,
          max_r: xA,
          max_g: LA,
          max_b: lA
        } = z;
        Q.push({
          min_x: AA,
          min_y: $,
          min_z: P,
          max_x: j,
          max_y: V,
          max_z: x,
          min_scale_x: uA,
          min_scale_y: iA,
          min_scale_z: b,
          max_scale_x: nA,
          max_scale_y: oA,
          max_scale_z: H,
          min_r: kA,
          min_g: GA,
          min_b: UA,
          max_r: xA,
          max_g: LA,
          max_b: lA
        });
      };
    }
    function h(D) {
      if (I && D.name === "sh")
        return C = BB(D.properties), o(), r;
      if (D.name !== "vertex")
        return null;
      const { packed_position: y, packed_rotation: l, packed_scale: d, packed_color: u } = D.properties;
      if (!y || !l || !d || !u)
        throw new Error(
          "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"
        );
      const p = Math.sqrt(2);
      return (m, M) => {
        const G = Q[m >>> 8];
        if (G == null)
          throw new Error("Missing PLY chunk");
        const {
          min_x: J,
          min_y: k,
          min_z: N,
          max_x: Y,
          max_y: F,
          max_z: f,
          min_scale_x: U,
          min_scale_y: L,
          min_scale_z: K,
          max_scale_x: Z,
          max_scale_y: QA,
          max_scale_z: z,
          min_r: AA,
          min_g: $,
          min_b: P,
          max_r: j,
          max_g: V,
          max_b: x
        } = G, { packed_position: uA, packed_rotation: iA, packed_scale: b, packed_color: nA } = M, oA = (uA >>> 21 & 2047) / 2047 * (Y - J) + J, H = (uA >>> 11 & 1023) / 1023 * (F - k) + k, kA = (uA & 2047) / 2047 * (f - N) + N, GA = ((iA >>> 20 & 1023) / 1023 - 0.5) * p, UA = ((iA >>> 10 & 1023) / 1023 - 0.5) * p, xA = ((iA & 1023) / 1023 - 0.5) * p, LA = Math.sqrt(Math.max(0, 1 - GA * GA - UA * UA - xA * xA)), lA = iA >>> 30, vA = lA === 0 ? GA : lA === 1 ? LA : UA, oI = lA <= 1 ? UA : lA === 2 ? LA : xA, rI = lA <= 2 ? xA : LA, cI = lA === 0 ? LA : GA, hI = Math.exp(
          (b >>> 21 & 2047) / 2047 * (Z - U) + U
        ), wI = Math.exp(
          (b >>> 11 & 1023) / 1023 * (QA - L) + L
        ), DI = Math.exp(
          (b & 2047) / 2047 * (z - K) + K
        ), lI = (nA >>> 24 & 255) / 255 * (j - AA) + AA, yI = (nA >>> 16 & 255) / 255 * (V - $) + $, xt = (nA >>> 8 & 255) / 255 * (x - P) + P, Lt = (nA & 255) / 255;
        A(
          m,
          oA,
          H,
          kA,
          hI,
          wI,
          DI,
          vA,
          oI,
          rI,
          cI,
          Lt,
          lI,
          yI,
          xt
        );
      };
    }
    const w = (D) => {
      if (D.name === "chunk" && this.comments.some(
        (V) => V.toLowerCase().includes("supersplat")
      ))
        return c(D);
      if (B)
        return h(D);
      if (D.name !== "vertex")
        return null;
      const {
        x: y,
        y: l,
        z: d,
        scale_0: u,
        scale_1: p,
        scale_2: m,
        rot_0: M,
        rot_1: G,
        rot_2: J,
        rot_3: k,
        opacity: N,
        f_dc_0: Y,
        f_dc_1: F,
        f_dc_2: f,
        red: U,
        green: L,
        blue: K,
        alpha: Z
      } = D.properties;
      if (!y || !l || !d)
        throw new Error("Missing PLY properties: x, y, z");
      const QA = u && p && m, z = M && G && J && k, AA = Z != null ? Wg[Z.type] : 1, $ = U != null ? Wg[U.type] : 1, P = L != null ? Wg[L.type] : 1, j = K != null ? Wg[K.type] : 1;
      return C = BB(D.properties), o(), (V, x) => {
        const uA = QA ? Math.exp(x.scale_0) : wg.defaultPointScale, iA = QA ? Math.exp(x.scale_1) : wg.defaultPointScale, b = QA ? Math.exp(x.scale_2) : wg.defaultPointScale, nA = z ? x.rot_1 : 0, oA = z ? x.rot_2 : 0, H = z ? x.rot_3 : 0, kA = z ? x.rot_0 : 1, GA = N != null ? 1 / (1 + Math.exp(-x.opacity)) : Z != null ? x.alpha / AA : 1, UA = Y != null ? x.f_dc_0 * qg + 0.5 : U != null ? x.red / $ : 1, xA = F != null ? x.f_dc_1 * qg + 0.5 : L != null ? x.green / P : 1, LA = f != null ? x.f_dc_2 * qg + 0.5 : K != null ? x.blue / j : 1;
        if (A(
          V,
          x.x,
          x.y,
          x.z,
          uA,
          iA,
          b,
          nA,
          oA,
          H,
          kA,
          GA,
          UA,
          xA,
          LA
        ), I && e) {
          if (e)
            for (const [lA, vA] of E.entries())
              e[lA] = x[vA];
          if (n)
            for (const [lA, vA] of t.entries())
              n[lA] = x[vA];
          if (s)
            for (const [lA, vA] of i.entries())
              s[lA] = x[vA];
          I(V, e, n, s);
        }
      };
    };
    this.parseData(w);
  }
  // Inject RGBA values into original PLY file, which can be used to modify
  // the color/opacity of the Gsplats and write out the modified PLY file.
  injectRgba(A) {
    let I = 0;
    const B = this.data;
    if (B == null)
      throw new Error("No parsed data");
    if (A.length !== this.numSplats * 4)
      throw new Error("Invalid RGBA array length");
    for (const Q in this.elements) {
      const C = this.elements[Q], { count: E, properties: t } = C, i = [];
      let e = 0;
      const n = Q === "vertex";
      if (n) {
        for (const s of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"])
          if (!t[s] || t[s].type !== "float")
            throw new Error(`Can't injectRgba due to property: ${s}`);
      }
      for (const [s, o] of Object.entries(t))
        if (o.isList)
          i.push(() => {
            const r = vg[o.countType](
              B,
              I,
              this.littleEndian
            );
            I += ng[o.countType], I += r * ng[o.type];
          });
        else {
          if (n)
            if (s === "f_dc_0" || s === "f_dc_1" || s === "f_dc_2") {
              const r = Number.parseInt(
                s.slice(5)
              );
              i.push(() => {
                const c = (A[e + r] / 255 - 0.5) / qg;
                IB[o.type](
                  B,
                  I,
                  this.littleEndian,
                  c
                );
              });
            } else s === "opacity" && i.push(() => {
              const r = Math.max(
                -100,
                Math.min(
                  100,
                  -Math.log(1 / (A[e + 3] / 255) - 1)
                )
              );
              IB[o.type](
                B,
                I,
                this.littleEndian,
                r
              );
            });
          i.push(() => {
            I += ng[o.type];
          });
        }
      for (let s = 0; s < E; s++) {
        for (const o of i)
          o();
        n && (e += 4);
      }
    }
  }
};
wg.defaultPointScale = 1e-3;
let QI = wg;
const qg = 0.28209479177387814, vg = {
  char: (g, A, I) => g.getInt8(A),
  uchar: (g, A, I) => g.getUint8(A),
  short: (g, A, I) => g.getInt16(A, I),
  ushort: (g, A, I) => g.getUint16(A, I),
  int: (g, A, I) => g.getInt32(A, I),
  uint: (g, A, I) => g.getUint32(A, I),
  float: (g, A, I) => g.getFloat32(A, I),
  double: (g, A, I) => g.getFloat64(A, I)
}, IB = {
  char: (g, A, I, B) => {
    g.setInt8(A, B);
  },
  uchar: (g, A, I, B) => {
    g.setUint8(A, B);
  },
  short: (g, A, I, B) => {
    g.setInt16(A, B, I);
  },
  ushort: (g, A, I, B) => {
    g.setUint16(A, B, I);
  },
  int: (g, A, I, B) => {
    g.setInt32(A, B, I);
  },
  uint: (g, A, I, B) => {
    g.setUint32(A, B, I);
  },
  float: (g, A, I, B) => {
    g.setFloat32(A, B, I);
  },
  double: (g, A, I, B) => {
    g.setFloat64(A, B, I);
  }
}, ng = {
  char: 1,
  uchar: 1,
  short: 2,
  ushort: 2,
  int: 4,
  uint: 4,
  float: 4,
  double: 8
}, Wg = {
  char: 127,
  uchar: 255,
  short: 32767,
  ushort: 65535,
  int: 2147483647,
  uint: 4294967295,
  float: 1,
  double: 1
}, Ln = {
  0: 0,
  9: 1,
  24: 2,
  45: 3
}, bn = {
  0: 0,
  1: 9,
  2: 24,
  3: 45
};
function BB(g) {
  let A = 0;
  for (; g[`f_rest_${A}`]; )
    A += 1;
  const I = Ln[A];
  if (I == null)
    throw new Error(`Unsupported number of SH coefficients: ${A}`);
  return I;
}
const ut = '(function(){"use strict";let tA;function xt(E){const A=tA.__externref_table_alloc();return tA.__wbindgen_export_2.set(A,E),A}function Ut(E,A){try{return E.apply(this,A)}catch(g){const I=xt(g);tA.__wbindgen_exn_store(I)}}function sB(E){const A=typeof E;if(A=="number"||A=="boolean"||E==null)return`${E}`;if(A=="string")return`"${E}"`;if(A=="symbol"){const B=E.description;return B==null?"Symbol":`Symbol(${B})`}if(A=="function"){const B=E.name;return typeof B=="string"&&B.length>0?`Function(${B})`:"Function"}if(Array.isArray(E)){const B=E.length;let Q="[";B>0&&(Q+=sB(E[0]));for(let t=1;t<B;t++)Q+=", "+sB(E[t]);return Q+="]",Q}const g=/\\[object ([^\\]]+)\\]/.exec(toString.call(E));let I;if(g&&g.length>1)I=g[1];else return toString.call(E);if(I=="Object")try{return"Object("+JSON.stringify(E)+")"}catch{return"Object"}return E instanceof Error?`${E.name}: ${E.message}\n${E.stack}`:I}let eB=0,_g=null;function MI(){return(_g===null||_g.byteLength===0)&&(_g=new Uint8Array(tA.memory.buffer)),_g}const GI=typeof TextEncoder<"u"?new TextEncoder("utf-8"):{encode:()=>{throw Error("TextEncoder not available")}},Lt=typeof GI.encodeInto=="function"?function(E,A){return GI.encodeInto(E,A)}:function(E,A){const g=GI.encode(E);return A.set(g),{read:E.length,written:g.length}};function bt(E,A,g){if(g===void 0){const C=GI.encode(E),i=A(C.length,1)>>>0;return MI().subarray(i,i+C.length).set(C),eB=C.length,i}let I=E.length,B=A(I,1)>>>0;const Q=MI();let t=0;for(;t<I;t++){const C=E.charCodeAt(t);if(C>127)break;Q[B+t]=C}if(t!==I){t!==0&&(E=E.slice(t)),B=g(B,I,I=t+E.length*3,1)>>>0;const C=MI().subarray(B+t,B+I),i=Lt(E,C);t+=i.written,B=g(B,I,t,1)>>>0}return eB=t,B}let cg=null;function BQ(){return(cg===null||cg.buffer.detached===!0||cg.buffer.detached===void 0&&cg.buffer!==tA.memory.buffer)&&(cg=new DataView(tA.memory.buffer)),cg}const QQ=typeof TextDecoder<"u"?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};typeof TextDecoder<"u"&&QQ.decode();function tQ(E,A){return E=E>>>0,QQ.decode(MI().subarray(E,E+A))}function CQ(E,A,g){return tA.decode_wlg(E,A,g)}function Ht(E,A,g,I){return tA.old_sort_splats(E,A,g,I)>>>0}function Zt(E,A,g){return tA.sort_splats(E,A,g)>>>0}function Kt(E,A,g,I,B,Q,t,C,i,s,a){return tA.raycast_splats(E,A,g,I,B,Q,t,C,i,s,a)}async function qt(E,A){if(typeof Response=="function"&&E instanceof Response){if(typeof WebAssembly.instantiateStreaming=="function")try{return await WebAssembly.instantiateStreaming(E,A)}catch(I){if(E.headers.get("Content-Type")!="application/wasm")console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n",I);else throw I}const g=await E.arrayBuffer();return await WebAssembly.instantiate(g,A)}else{const g=await WebAssembly.instantiate(E,A);return g instanceof WebAssembly.Instance?{instance:g,module:E}:g}}function Wt(){const E={};return E.wbg={},E.wbg.__wbg_buffer_09165b52af8c5237=function(A){return A.buffer},E.wbg.__wbg_buffer_609cc3eee51ed158=function(A){return A.buffer},E.wbg.__wbg_get_b9b93047fe3cf45b=function(A,g){return A[g>>>0]},E.wbg.__wbg_instanceof_Uint8Array_17156bcf118086a9=function(A){let g;try{g=A instanceof Uint8Array}catch{g=!1}return g},E.wbg.__wbg_length_3b4f022188ae8db6=function(A){return A.length},E.wbg.__wbg_length_6ca527665d89694d=function(A){return A.length},E.wbg.__wbg_length_8cfd2c6409af88ad=function(A){return A.length},E.wbg.__wbg_length_a446193dc22c12f8=function(A){return A.length},E.wbg.__wbg_length_e2d2a49132c1b256=function(A){return A.length},E.wbg.__wbg_new_405e22f390576ce2=function(){return new Object},E.wbg.__wbg_new_9fee97a409b32b68=function(A){return new Uint16Array(A)},E.wbg.__wbg_new_a12002a7f91c75be=function(A){return new Uint8Array(A)},E.wbg.__wbg_new_e3b321dcfef89fc7=function(A){return new Uint32Array(A)},E.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354=function(A,g,I){return new Float32Array(A,g>>>0,I>>>0)},E.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212=function(A,g,I){return new Uint32Array(A,g>>>0,I>>>0)},E.wbg.__wbg_newwithlength_5a5efe313cfd59f1=function(A){return new Float32Array(A>>>0)},E.wbg.__wbg_newwithlength_bd3de93688d68fbc=function(A){return new Uint32Array(A>>>0)},E.wbg.__wbg_set_10bad9bee0e9c58b=function(A,g,I){A.set(g,I>>>0)},E.wbg.__wbg_set_65595bdd868b3009=function(A,g,I){A.set(g,I>>>0)},E.wbg.__wbg_set_bb8cecf6a62b9f46=function(){return Ut(function(A,g,I){return Reflect.set(A,g,I)},arguments)},E.wbg.__wbg_set_d23661d19148b229=function(A,g,I){A.set(g,I>>>0)},E.wbg.__wbg_set_f4f1f0daa30696fc=function(A,g,I){A.set(g,I>>>0)},E.wbg.__wbg_subarray_3aaeec89bb2544f0=function(A,g,I){return A.subarray(g>>>0,I>>>0)},E.wbg.__wbg_subarray_769e1e0f81bb259b=function(A,g,I){return A.subarray(g>>>0,I>>>0)},E.wbg.__wbindgen_debug_string=function(A,g){const I=sB(g),B=bt(I,tA.__wbindgen_malloc,tA.__wbindgen_realloc),Q=eB;BQ().setInt32(A+4*1,Q,!0),BQ().setInt32(A+4*0,B,!0)},E.wbg.__wbindgen_init_externref_table=function(){const A=tA.__wbindgen_export_2,g=A.grow(4);A.set(0,void 0),A.set(g+0,void 0),A.set(g+1,null),A.set(g+2,!0),A.set(g+3,!1)},E.wbg.__wbindgen_memory=function(){return tA.memory},E.wbg.__wbindgen_number_new=function(A){return A},E.wbg.__wbindgen_string_new=function(A,g){return tQ(A,g)},E.wbg.__wbindgen_throw=function(A,g){throw new Error(tQ(A,g))},E}function Vt(E,A){return tA=E.exports,NI.__wbindgen_wasm_module=A,cg=null,_g=null,tA.__wbindgen_start(),tA}async function NI(E){if(tA!==void 0)return tA;typeof E<"u"&&(Object.getPrototypeOf(E)===Object.prototype?{module_or_path:E}=E:console.warn("using deprecated parameters for the initialization function; pass a single object instead")),typeof E>"u"&&(E=new URL("data:application/wasm;base64,AGFzbQEAAAABtgItYAJ/fwF/YAJ/fwBgA39/fwF/YAF/AGABfwF/YAN/f38AYAV/f39/fwBgBH9/f38AYAFvAX9gAW8Bb2ADb39/AW9gBX9/f39/AX9gA29vfwBgAABgA39+fgBgA39+fgF/YAd/f39/f39/AX9gBn9/f39/fwBgAX0BfWAEf39/fwF/YAABb2ABfwFvYAZ/f39/f38Bf2AAAX9gC39/f39/f39/f39/AX9gAn9/AW9gAXwBb2ACb38Bb2ADb29vAX9gAn9vAGAHf39/f39/fwBgAn9/AX5gAn9+AX9gAn9+AGALfX19fX19fX1/b38Bb2ABfwF9YAV/f35/fwBgBH9+f38AYAV/f31/fwBgBH99f38AYAV/f3x/fwBgBH98f38AYAR/f29vAX9gA39vbwF/YAJ9fQF9ArcIHgN3YmcVX193YmluZGdlbl9zdHJpbmdfbmV3ABkDd2JnFV9fd2JpbmRnZW5fbnVtYmVyX25ldwAaA3diZxpfX3diZ19nZXRfYjliOTMwNDdmZTNjZjQ1YgAbA3diZx1fX3diZ19sZW5ndGhfZTJkMmE0OTEzMmMxYjI1NgAIA3diZxpfX3diZ19uZXdfNDA1ZTIyZjM5MDU3NmNlMgAUA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3diZ19uZXdfYTEyMDAyYTdmOTFjNzViZQAJA3diZxpfX3diZ19zZXRfNjU1OTViZGQ4NjhiMzAwOQAMA3diZx1fX3diZ19sZW5ndGhfYTQ0NjE5M2RjMjJjMTJmOAAIA3diZxpfX3diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwAMA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAAIA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAoDd2JnGl9fd2JnX25ld19lM2IzMjFkY2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAwDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAgDd2JnMV9fd2JnX25ld3dpdGhi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CwJAIAAoAhAiAkUNAEGousIAQQggAhDVBEUNAEEBDAILIAFBATsBJCABIAQ2AiAgAUEANgIcIAFBAToAGCABQd8ANgIUIAEgBDYCECABQQA2AgwgASAENgIIIAEgAzYCBCABQd8ANgIAIAFBKGogARBQAn8gASgCKEUEQAJAIAEtACUNACABQQE6ACUCQCABLQAkQQFGBEAgASgCICEFIAEoAhwhBAwBCyABKAIgIgUgASgCHCIERg0BCyABKAIEIARqIQMgBSAEawwCC0GwusIAEK4EAAsgASgCHCEEIAEgASgCMDYCHCADIARqIQMgASgCLCAEawshBAJAIAIEQCADIAQgAhDVBA0BCyABQcgAaiABQSBqKQIANwMAIAFBQGsgAUEYaikCADcDACABQThqIAFBEGopAgA3AwAgAUEwaiABQQhqKQIANwMAIAEgASkCADcDKAJAIAEtAE0NACACIQMDQCABKAIsIQUgAUHUAGogAUEoahBQAn8gASgCVEUEQCABLQBNDQMgAUEBOgBNAkAgAS0ATEEBRgRAIAEoAkghBSABKAJEIQQMAQsgASgCSCIFIAEoAkQiBEYNBAsgASgCLCAEaiEGIAUgBGsMAQsgASgCRCEEIAEgASgCXDYCRCAEIAVqIQYgASgCWCAEawshBAJAIANFBEBBACEDDAELQbm2wgBBASADENUEDQMgACgCECICRQRAQQAhAkEAIQMMAQsgAiEDIAYgBCACENUEDQMLIAEtAE1FDQALCyACRQ0BQcC6wgBBAiACENUERQ0BC0EBDAELAkAgACgCECICRQ0AQcK6wgBBAyACENUERQ0AQQEMAQsCQAJAAkAgACgCACIDRQRAQQAhAwwBC0EAIQIDQAJAIAAoAggiBCAAKAIETw0AIAMgBGotAABBxQBHDQAgACAEQQFqNgIIDAILAkAgAkUNACAAKAIQIgNFDQBB9bnCAEECIAMQ1QRFDQBBAQwFCyAAECcNAiACQQFrIQIgACgCACIDDQALQQAhAwsgACgCECIEBEBBAUH1s8IAQQEgBBDVBA0DGiAAKAIAIQMLIANFDQEgACgCCCICIAAoAgRPDQEgAiADai0AAEH1AEcNASAAIAJBAWo2AghBAAwCC0EBDAELAkAgACgCECICRQ0AQcW6wgBBBCACENUERQ0AQQEMAQsgABAnCyABQeAAaiQAC+sJAgJ/AX4jAEEwayICJAACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkBBAiAAKAIAQfv///8HaiIDIANBDk8bQQFrDg0BAgMEBQYHCAkKCwwNAAsgAiAAQQRqNgIEIAJBATYCDCACQfCnwQA2AgggAkIBNwIUIAIgAkEEaq1CgICAgJA4hDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQRQwNCyACIABBBGo2AgQgAkEBNgIMIAJB8KfBADYCCCACQgE3AhQgAiACQQRqrUKAgICA4DiENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahBFDAwLIAIgADYCBCACQQE2AgwgAkHwp8EANgIIIAJCATcCFCACIAJBBGqtQoCAgICQN4Q3AyAgAiACQSBqNgIQIAEoAhwgASgCICACQQhqEEUMCwsgASgCHEH4xcEAQSYgASgCICgCDBECAAwKCyACIABBBGo2AgAgAiAAQQhqNgIEIAJBAzYCDCACQfjGwQA2AgggAkICNwIUIAIgAq1CgICAgPA1hDcDKCACIAJBBGqtQoCAgIDgNIQ3AyAgAiACQSBqNgIQIAEoAhwgASgCICACQQhqEEUMCQsgAiAAQQRqNgIEIAJBAjYCDCACQfC8wQA2AgggAkIBNwIUIAIgAkEEaq1CgICAgLA4hDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQRQwICyACIABBBGo2AgQgAkECNgIMIAJB3MfBADYCCCACQgE3AhQgAiACQQRqrUKAgICA8DWENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahBFDAcLIAEoAhxB7MfBAEEtIAEoAiAoAgwRAgAMBgsgAiAAQQRqNgIEIAJBATYCDCACQcDIwQA2AgggAkIBNwIUIAIgAkEEaq1CgICAgIA2hDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQRQwFCyACIABBBGo2AgAgAiAAQQhqNgIEIAJBAjYCDCACQYDJwQA2AgggAkICNwIUIAJCgICAgPA1IgQgAkEEaq2ENwMoIAIgBCACrYQ3AyAgAiACQSBqNgIQIAEoAhwgASgCICACQQhqEEUMBAsgAiAAQQRqNgIAIAIgAEEIajYCBCACQQM2AgwgAkH0ycEANgIIIAJCAjcCFCACIAJBBGqtQoCAgIDgNIQ3AyggAiACrUKAgICA8DWENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahBFDAMLIAIgAEEEajYCACACIABBCGo2AgQgAkECNgIMIAJBuMrBADYCCCACQgI3AhQgAkKAgICA8DUiBCACrYQ3AyggAiAEIAJBBGqthDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQRQwCCyACIABBBGo2AgQgAkECNgIMIAJB+MrBADYCCCACQgI3AhQgAkLIysGAgDk3AyggAiACQQRqrUKAgICA4DSENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahBFDAELIAIgAEEEajYCBCACQQI2AgwgAkHEy8EANgIIIAJCAjcCFCACQsjKwYCAOTcDKCACIAJBBGqtQoCAgIDgNIQ3AyAgAiACQSBqNgIQIAEoAhwgASgCICACQQhqEEULIAJBMGokAAvoCQEJfyMAQdAAayIBJABBgYDEACEDAkACQCAAKAIEIgQgACgCECICSQ0AIAAgBCACayIGNgIEIAAgACgCACIDIAJqIgQ2AgACQAJAAkAgAkECRgRAIAMtAAAiAkHBAGtBX3FBCmogAkEwayACQTlLGyICQRBPDQUgAy0AASIDQcEAa0FfcUEKaiADQTBrIANBOUsbIgNBEE8NBSACQQR0IANyIgLAQQBODQFBgIDEACEDIAJB/wFxIgVBwAFJDQQgAQJ/QQIgBUHgAUkNABogBUHwAUkEQEEBIQhBAwwBCyAFQfgBTw0FQQQLIgM2AgggAUEAOgAPIAFBADsADSABIAI6AAwgASABQQxqNgIEIAZBAkkNAyAAIAZBAmsiBzYCBCAAIARBAmo2AgAgBC0AACIFQcEAa0FfcUEKaiAFQTBrIAVBOUsbIglBD0sNBQJAIAQtAAEiBUHBAGtBX3FBCmogBUEwayAFQTlLGyIFQQ9LDQAgASAJQQR0IAVyOgANIAJB/wFxQeABSQ0DIAdBAkkNBCAAIAZBBGsiBTYCBCAAIARBBGo2AgAgBC0AAiICQcEAa0FfcUEKaiACQTBrIAJBOUsbIgdBD0sNBiAELQADIgJBwQBrQV9xQQpqIAJBMGsgAkE5SxsiAkEPSw0AIAEgB0EEdCACcjoADiAIDQMgBUECSQ0EIAAgBkEGazYCBCAAIARBBmo2AgAgBC0ABCIAQcEAa0FfcUEKaiAAQTBrIABBOUsbIgZBD0sNBiAELQAFIgBBwQBrQV9xQQpqIABBMGsgAEE5SxsiAEEPSw0AIAEgBkEEdCAAcjoADwwDCwwFC0HMtsIAQShB9LbCABDtAgALQQEhAyABQQE2AgggAUEAOgAPIAFBADsADSABIAI6AAwgASABQQxqNgIECyABQTBqIAFBDGogAxA9IAEoAjANACABKAI0IQAgASABKAI4IgQ2AhQgASAANgIQIAECfwJAIARFDQAgACAEaiEFAkAgBQJ/IAAsAAAiA0EATgRAIANB/wFxIQMgAEEBagwBCyAALQABQT9xIQIgA0EfcSEGIANBX00EQCAGQQZ0IAJyIQMgAEECagwBCyAALQACQT9xIAJBBnRyIQIgA0FwSQRAIAIgBkEMdHIhAyAAQQNqDAELIAZBEnRBgIDwAHEgAC0AA0E/cSACQQZ0cnIhAyAAQQRqCyIGRwRAIAYsAAAaDAELIANBgIDEAEcNBAsgBEEQSQ0AIAAgBBAvDAELAn9BACEDQQAgBEUNABogBEEDcSEGAkAgBEEESQRAQQAhBAwBCyAEQXxxIQVBACEEA0AgBCAAIANqIgIsAABBv39KaiACQQFqLAAAQb9/SmogAkECaiwAAEG/f0pqIAJBA2osAABBv39KaiEEIAUgA0EEaiIDRw0ACwsgBgRAIAAgA2ohAANAIAQgACwAAEG/f0pqIQQgAEEBaiEAIAZBAWsiBg0ACwsgBAsLNgJMIAFBBDYCHCABQYS4wgA2AhggAUIDNwIkIAEgAUHMAGqtQoCAgIAQhDcDQCABIAFBEGqtQoCAgIDgwQCENwM4IAEgAUEEaq1CgICAgPDBAIQ3AzAgASABQTBqNgIgIAFBGGpBpLjCABCkAwALQYCAxAAhAwsgAUHQAGokACADDwtBhLfCABCuBAAL2RoCCX8CfiMAQSBrIgYkAAJAAkACQAJAAkACQAJAAkACQCAAKAIAIgMEQCAAKAIIIgIgACgCBE8NAyAAIAJBAWo2AgggAiADai0AACIBQeEAayIEQf8BcSIFQRlLQb/38x0gBXZBAXFFcg0CIAAoAhAiAA0BQQAhAwwJCyAAKAIQIgBFBEBBACEDDAkLQe25wgBBASAAENUEIQMMCAsgBEH/AXFBAnQiAUHcvcIAaigCACABQfS8wgBqKAIAIAAQ1QQhAwwHCyAAIAAoAgxBAWoiBDYCDCAEQfQDTQRAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQcEAaw4UAgYNBQ0EDQ0NDQ0NDQ0BAQAAAgMNCyAAKAIQIgIEQEEBIQNB+bPCAEEBIAIQ1QQNFSAAKAIAIgNFDRILIAAoAggiAiAAKAIETw0RIAIgA2otAABBzABHDREgACACQQFqNgIIIAZBEGogABBwIAYtABANByAGKQMYIgpQRQ0GDBELIAAoAhAiAgRAQQEhA0H6s8IAQQEgAhDVBA0UCyAAKAIQIQMgAUHQAEcNByADRQ0IQZK6wgBBBiADENUERQ0IDBILIAAoAhAiAgRAQQEhA0H3ucIAQQEgAhDVBA0TC0EBIQMgABAnDRIgAUHBAEYEQCAAKAIQIgEEQEGYusIAQQIgARDVBA0UCyAAQQEQIA0TCyAAKAIQIgFFDRBB+LnCAEEBIAEQ1QRFDRAMEgsgACgCECIBBEBBASEDQfazwgBBASABENUEDRILIAZBCGohA0EAIQECfwJAIAAoAgAiAkUNAANAAkAgACgCCCIEIAAoAgRPDQAgAiAEai0AAEHFAEcNACAAIARBAWo2AggMAgsCQCABRQ0AIAAoAhAiAkUNAEH1ucIAQQIgAhDVBEUNAEEBDAMLQQEgABAnDQIaIAFBAWohASAAKAIAIgINAAsLQQALIQIgAyABNgIEIAMgAjYCACAGKAIIDRAgBigCDEEBRgRAIAAoAhAiAUUNEEEBIQNB9LPCAEEBIAEQ1QQNEgsgACgCECIBRQ0PQQEhA0H1s8IAQQEgARDVBEUNDwwRC0EAIQEjAEEQayIDJAACQAJAAkACQCAAKAIAIgIEQCAAKAIIIgQgACgCBCIFTw0DIAIgBGotAABBxwBHDQMgACAEQQFqIgE2AgggASAFTw0BIAEgAmotAABB3wBHDQEgACAEQQJqNgIIDAILIAAoAhAiAkUNA0HtucIAQQEgAhDVBCEBDAMLA0ACQAJAAkACQCABIAVJBEAgASACai0AAEHfAEYNAQsgASAFRg0DIAEgAmotAAAiBEEwayIHQf8BcUEKSQ0CIARB4QBrQf8BcUEaSQ0BIARBwQBrQf8BcUEaTw0DIARBHWshBwwCCyAAIAFBAWo2AgggCkJ9Vg0CIApCAXwhCgwECyAEQdcAayEHCyAAIAFBAWoiATYCCCADIAoQmwIgAykDCEIAUg0AIAMpAwAiCyAHrUL/AYN8IgogC1oNAQsLAkAgACgCECIBRQ0AQcS5wgBBECABENUERQ0AQQEhAQwDC0EAIQEgAEEAOgAEIABBADYCAAwCCyAKQgF8IQsLAkAgACgCECIBBEAgC1ANAUHvucIAQQQgARDVBARAQQEhAQwDCyAAIAAoAhRBAWo2AhQgAEIBELwBBEBBASEBDAMLQgEhCgNAIAogC1EEQCAAKAIQIgJFDQNBASEBQfO5wgBBAiACENUERQ0DDAQLAkAgClANACAAKAIQIgFFDQBB9bnCAEECIAEQ1QRFDQBBASEBDAQLQQEhASAAIAAoAhRBAWo2AhQgCkIBfCEKIABCARC8AUUNAAsMAgsgABAkIQEMAQsgABAkIQEgACAAKAIUIAunazYCFAsgA0EQaiQAIAFFDQ4MDwsgACgCECIBBEBBmrrCAEEEIAEQ1QQNDwtBASEDQQAhASMAQRBrIgQkAAJAAkACQAJAIAAoAgAiAgRAIAAoAggiBSAAKAIEIgdPDQMgAiAFai0AAEHHAEcNAyAAIAVBAWoiATYCCCABIAdPDQEgASACai0AAEHfAEcNASAAIAVBAmo2AggMAgsgACgCECICRQ0DQe25wgBBASACENUEIQEMAwsDQAJAAkACQAJAIAEgB0kEQCABIAJqLQAAQd8ARg0BCyABIAdGDQMgASACai0AACIFQTBrIghB/wFxQQpJDQIgBUHhAGtB/wFxQRpJDQEgBUHBAGtB/wFxQRpPDQMgBUEdayEIDAILIAAgAUEBajYCCCAKQn1WDQIgCkIBfCEKDAQLIAVB1wBrIQgLIAAgAUEBaiIBNgIIIAQgChCbAiAEKQMIQgBSDQAgBCkDACILIAitQv8Bg3wiCiALWg0BCwsCQCAAKAIQIgFFDQBBxLnCAEEQIAEQ1QRFDQBBASEBDAMLQQAhASAAQQA6AAQgAEEANgIADAILIApCAXwhCwsgACgCECIBRQRAQQAhAQNAAkAgACgCCCIFIAAoAgRPDQAgAiAFai0AAEHFAEcNACAAIAVBAWo2AghBACEBDAMLAkAgAUUNACAAKAIQIgJFDQBBnrrCAEEDIAIQ1QRFDQBBASEBDAMLIAAQQgRAQQEhAQwDCyABQQFrIQEgACgCACICDQALQQAhAQwBCwJAIAtQDQBB77nCAEEEIAEQ1QQEQEEBIQEMAgsgACAAKAIUQQFqNgIUIABCARC8AQRAQQEhAQwCC0IBIQoDQCAKIAtRBEAgACgCECICRQ0CQQEhAUHzucIAQQIgAhDVBEUNAgwDCwJAIApQDQAgACgCECIBRQ0AQfW5wgBBAiABENUERQ0AQQEhAQwDC0EBIQEgACAAKAIUQQFqNgIUIApCAXwhCiAAQgEQvAFFDQALDAELAn9BACAAKAIAIgJFDQAaQQAhAQJAA0ACQCAAKAIIIgUgACgCBE8NACACIAVqLQAAQcUARw0AIAAgBUEBajYCCEEADAMLAkAgAUUNACAAKAIQIgJFDQBBnrrCAEEDIAIQ1QQNAgsgABBCDQEgAUEBayEBIAAoAgAiAg0AC0EADAELQQELIQEgACAAKAIUIAunazYCFAsgBEEQaiQAIAENDyAAKAIAIgJFDQUgACgCCCIBIAAoAgRPDQUgASACai0AAEHMAEcNBSAAIAFBAWo2AgggBkEQaiAAEHAgBi0AEA0GIAYpAxgiClANDSAAKAIQIgEEQEGeusIAQQMgARDVBA0PCyAAIAoQvAFFDQ0MDgtBACEBIwBBIGsiAiQAAkACQAJAAkACfgJAAkACQCAAKAIAIgUEQCAAKAIIIgMgACgCBCIHSQRAIAMgBWotAABB3wBGDQMLIAMgByADIAdLGyEJIAMhAQNAIAEgB0kEQCABIAVqLQAAQd8ARg0DCyABIAlGDQYCQCABIAVqLQAAIgRBMGsiCEH/AXFBCkkNACAEQeEAa0H/AXFBGk8EQCAEQcEAa0H/AXFBGk8NCCAEQR1rIQgMAQsgBEHXAGshCAsgACABQQFqIgE2AgggAiAKEJsCIAIpAwhCAFINBiACKQMAIgsgCK1C/wGDfCIKIAtaDQALDAULIAAoAhAiA0UNB0HtucIAQQEgAxDVBCEBDAcLIAAgAUEBajYCCCAKQn9SDQEMAwsgACADQQFqNgIIQgAMAQsgCkIBfAshCiAKIANBAWutWg0AQQEhASAAKAIQIQMgACgCDEEBaiIEQfQDSw0BIANFBEBBACEBDAQLIAJBGGoiBSAAQQhqIgMpAgA3AwAgACAENgIMIAMgCj4CACACIAApAgA3AxAgABAnIQEgAyAFKQMANwIAIAAgAikDEDcCAAwDC0EAIQEgACgCECIDRQ0BQcS5wgBBECADENUERQ0BQQEhAQwCCyADRQ0AQdS5wgBBGSADENUEDQELIAAgAToABEEAIQEgAEEANgIACyACQSBqJAAgAQ0NDAwLIAAgChC8AQ0MIAAoAhAiAkUNCkEBIQNBjbrCAEEBIAIQ1QRFDQoMDQsgACgCECEBAkAgBi0AESIDRQRAIAFFDQFBxLnCAEEQIAEQ1QRFDQEMDQsgAUUNAEHUucIAQRkgARDVBA0MCyAAIAM6AAQMCAsgA0UNAEGOusIAQQQgAxDVBA0KCyAAECdFDQgMCQsgACgCECIBRQ0EQcS5wgBBECABENUEDQkMBAsgACgCECEBAkAgBi0AESIDRQRAIAFFDQFBxLnCAEEQIAEQ1QRFDQEMCQsgAUUNAEHUucIAQRkgARDVBA0ICyAAIAM6AAQMBAsgACACNgIIIABBABAfRQ0FDAYLIAAoAhAiAQRAQdS5wgBBGSABENUEDQYLIABBAToABAwCCyAAKAIQIgFFDQBBxLnCAEEQIAEQ1QQNBAtBACEDIABBADoABCAAQQA2AgAMBAtBACEDIABBADYCAAwDCwJAIAFB0gBGDQAgACgCECIBRQ0AQY66wgBBBCABENUEDQILIAAQJw0BC0EAIQMgACgCAEUNASAAIAAoAgxBAWs2AgwMAQtBASEDCyAGQSBqJAAgAwvriAECJn8KfiMAQYABayITJAACQAJAAkAgASgCAEECRg0AIAEtAMwDIRsgAS0AEEEEcQRAIBtBAXFFDQIgASgCGA0BDAILIBtBAXFFDQELIAEQvwENACAAQQQ6AAAgAEEANgIEDAELAkAgARC/ASADTw0AIAEoAgBBAkYNACABQShqIQ0gAUHgA2ohJUG4hcEAKQMAIi9C/wGDITBB8P/AACkCACIxQv8BgyEyIBNB7ABqQQFyISMCfwJAAkADQCABLQDMAyEEAkAgAS0AEEEEcQRAIARBAXFFDQEgASgCGA0GDAELIARBAXENBQsgARC/ASEEIBMgJTYCRCABKAIAIBNBBzYCSEECRiIGDQJBACABIAYbISAgAyAEayEmIBNByABqECogASgCmAIhJCABKAKcAiEEIBNBADYCbCAEIAEoApQCQQAgBCAkSRtqIScCQANAIBMoAkQiBCgCACEGAn4CQAJAIAQoAgQiBUEDTwRAICMgBi8AADsAACAEIAVBA2s2AgQgBCAGQQNqNgIAICNBAmogBkECai0AADoAAAwBCyAEQQA2AgQgBCAFIAZqNgIAIDJCBFINAQsgEy0AbSIFQQF2QQNxIgdBA0YEQCAbQf+BfHFBgARyIRsgLkKAfoNCBIQMAgsCQAJAAkAgEy0AbkEFdCAFQfgBcUEDdnIgEy0Ab0ENdHIiBkGAgAhNBEAgBiEEIAdBAWsOAgECAwsgG0H/gXxxQYAEciEbIC5CgP7//w+DIAatQiCGhEIGhAwEC0EBIQYMAQtBACEECyATQQE2AmwgG0GAgHxxIAdyIAVBAXFBCHRyIRsgBK0gBq1CIIaEDAELIBtB/4F8cUGABHIhGyAxCyEuIBtBgP4DcUGABEYNASABIAEpA8ADQgN8NwPAAyATIBs2AnggEyAuNwNwIBNByABqIRggE0HwAGohBiATQcQAaiEEQQAhBUEAIQ5CACEqQgAhLEIAIS0jAEHAgAhrIg8kAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBNB7ABqIiItAABBAWsOAgABDQsgBi0ACEEBaw4DAgMEAQsgGEEHNgIADBwLIA9BDGpBAEGAgAgQWhogBCgCACEEAkAgBigCACIKQYCACEkNACAKQRF2IQcgDUHoAWohC0Hw/8AAKQMAIi1C/wGDQgRSBEADQCAEKAIAIQYgBCgCBCIFQYCACEkNCCAPQQxqIgggBkGAgAgQOxogBCAFQYCACGs2AgQgBCAGQYCACGo2AgAgCyAIQYCACBCnASAHQQFrIgcNAAwCCwALA0AgBCgCACEGIAQCfyAEKAIEIghBgIAITwRAIA9BDGogBkGAgAgQOxogBkGAgAhqIQUgCEGAgAhrDAELIAYgCGohBUEACzYCBCAEIAU2AgAgCyAPQQxqQYCACBCnASAHQQFrIgcNAAsLIAQoAgAhBSAEKAIEIgcgCkH//wdxIgZJDQYgByAGayEHIAUgBmohCyAGQQFGDQMgD0EMaiAFIAYQOxoMBAsgD0EAOgAMIAYoAgAhByAEKAIAIgQoAgQiBkUNByAEIAZBAWs2AgQgBCAEKAIAIgRBAWo2AgAgDyAELQAAIgU6AAwMCAsgBigCBCIhIQcgDSgCiAMiBSAhSQRAICEgBWsiBiANKAKAAyAFa0sEQCANQYADaiAFIAZBAUEBEJABIA0oAogDIQULIA0oAoQDIgogBWohByAGQQJPBH8gB0EAIAZBAWsiBhBaGiAKIAUgBmoiBWoFIAcLQQA6AAAgBUEBaiEHCyANIAc2AogDIAQoAgAiBCgCACEGAkAgByAEKAIEIgVNBEAgDSgChAMhCiAFIAdrIQUgBiAHaiELAkAgB0EBRwRAIAogBiAHEDsaDAELIAogBi0AADoAAAsgBCAFNgIEIAQgCzYCAAwBC0EAIQcgBEEANgIEIAQgBSAGajYCAEHw/8AAKQMAIi2nIgRB/wFxQQRHDQwLIA0oAogDIRUgDSgChAMhBiAPQQA6AKaACCAPQQA6AKSACCAPQQA2ApiACCAPQQA2AqCACCAPQQxqIQogD0GYgAhqIQQjAEEgayIFJAAgBSAVNgIIIAUgBjYCBCAFQQA2AgwgBUEQaiIHIAVBBGoiC0ECEE8gBSkDGCErAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBSgCEEUEQCAEICunQQNxIgg6AA4gByALQQIQTyAFKQMYISsgBSgCEA0BIBVFDQJBg4aQKEGBhIQYIAYtAAAiC0ECcRsgC0EBdEEYcXYiB0EHcSAVSw0DICunIQcgCEECSQRAIARBADYCAAJAAkACQAJAIAdB/wFxDgQBAgEDAAtBrN/BAEHGAEGg4cEAEO0CAAsgBCALQQN2NgIIQQEhBwwPCyAVQQFHBEAgBCAGLQABQQR0IAtBBHZyNgIIQQIhBwwPC0EBQQFB8ODBABCtAgALIBVBAUYNBSAVQQJLBEAgBCAGLQABQQR0IAtBBHZyIAYtAAJBDHRyNgIIQQMhBwwOC0ECQQJBkOHBABCtAgALAkACQAJAIAdB/wFxIgcEQCAHQQNLDQ8gBEGBCDsBDCAHQQJrDgICAwELIARBgQI7AQwLIBVBAUYNByAEIAYtAAEiB0E/cUEEdCALQQR2cjYCCCAVQQJLBEAgBEEBNgIAIAQgBi0AAkECdCAHQQZ2cjYCBEEDIQcMDwtBAkECQdDhwQAQrQIACyAVQQFGDQcgFUECTQ0IQQQhByAEIAYtAAFBBHQgC0EEdnIgBi0AAiILQQNxQQx0cjYCCCAVQQNHBEAgBEEBNgIAIAQgBi0AA0EGdCALQQJ2cjYCBAwOC0EDQQNBgOLBABCtAgALIBVBAUYNCCAVQQJNDQkgBCAGLQABQQR0IAtBBHZyIAYtAAIiB0E/cUEMdHI2AgggFUEDRg0KIBVBBEsEQCAEQQE2AgAgBCAGLQADQQJ0IAdBBnZyIAYtAARBCnRyNgIEQQUhBwwNC0EEQQRBwOLBABCtAgALIAUoAhQhBCAKICs3AgQgCiAENgIADAwLIAUoAhQhBCAKICs3AgQgCiAENgIADAsLQQBBAEHg4MEAEK0CAAsgCiAHOgAIIAogFTYCBCAKQQQ6AAAMCQtBAUEBQYDhwQAQrQIAC0EBQQFBwOHBABCtAgALQQFBAUHg4cEAEK0CAAtBAkECQfDhwQAQrQIAC0EBQQFBkOLBABCtAgALQQJBAkGg4sEAEK0CAAtBA0EDQbDiwQAQrQIAC0Gs38EAQcYAQbDhwQAQ7QIACyAKQQU6AAAgCiAHOgABCyAFQSBqJAAgDy0ADSEEIA8tAAwiBUEFRw0MIAQgFUsNDQJAAkACQCAPKAKYgAhFBEAgDy0ApoAIIgcOAgIDAQsgDygCnIAIIQcMAgtB5IDBAEETQfiAwQAQ7QIACyAPKAKggAghBwsgFSAEayIfIAdJDQ4gDUEANgLwAiAPQQxqIRQgBCAGaiEcIAchBiANQegCaiEQIwBBMGsiCSQAAkACQAJAAkACQAJAAkACQAJAIA9BmIAIaiIFLQAOIgRBAWsOAwIBAQALIAUoAggiBCAGSw0DIAQgECgCACAQKAIIIgZrSwRAIBAgBiAEQQFBARCSASAQKAIIIQYLIBAoAgQgBmogHCAEEDsaIBQgBDYCBCAQIAQgBmo2AgggFEGegICAeDYCAAwHCyAFKAIAQQFHBEBBk4CAgHghCAwGCyAFLQAMQQFHBEBBlICAgHghCAwGCyAFKAIEIREgBS0ADSEeIAUoAggiFiAQKAIAIBAoAggiBWtLBEAgECAFIBZBAUEBEJIBCyAGIBFJDQMCQCAEQQJGBEAgCUEYaiEZQQAhBUIAISsjAEFAaiIMJAAgDSIIQQA2AggCQAJAAn8gESIERQRAQYiAgIB4IRIMAgsgHEEBaiEXIARBAWshBQJAAkACQAJAAkACQAJAIBwsAAAiCkEASARAIAggCkH/AGsiHUH/AXEiCyAIKAIUIgRLBH8gCyAEayIOIAgoAgwgBGtLBEAgCEEMaiAEIA5BAUEBEJIBIAgoAhQhBAsgCCgCECIaIARqIRIgDkECTwR/IBJBACAOQQFrIg4QWhogGiAEIA5qIgRqBSASC0EAOgAAIARBAWoFIAsLNgIUIB1BAXEgC0EBdmoiBCAFTQRAIApB/wBxQQJ0QQxqIR1BACEEA0AgBEEBdiEKAkACQAJAAkAgBEEBcUUEQCAFIApNDQEgCCgCFCIOIARNDQIgCCgCECAEaiAKIBdqLQAAQQR2OgAADAQLIAUgCk0EQCAKIAVBjPrBABCtAgALIAgoAhQiDiAESw0CIAQgDkGc+sEAEK0CAAsgCiAFQez5wQAQrQIACyAEIA5B/PnBABCtAgALIAgoAhAgBGogCiAXai0AAEEPcToAAAsgCyAEQQFqIgRHDQALIAgoAhQhBAwCC0GQgICAeCESQQAhCEEAIQ4MCQsCQAJAIAUgCk8EQCAMQRhqIAhBPGoiBCAXIAVBBhAtIAwoAhwhCyAMKAIYIhJBhYCAgHhHDQEgCiALTw0CIAtBCHYhCEGPgICAeCESIAshBSAKIQQMCwtBiYCAgHghEkEAIQggCiEEDAoLIAtBCHYhCCAMKAIgIgRBgH5xIQ4gDCkCJCErIAshBQwJCyAIKAJEBH4gCCgCQCkCAAVCAAshKyAMIAQ2AgAgDCArNwIEIAwgKzcCECAMIAQ2AgwCQCAFIAtrIgUgCiALayIETwRAIAxBADoALCAMQgA3AyAgDCALIBdqNgIYIAwgBDYCHCAMIARBA3Q2AihBACEEDAELIARBgH5xIQ4gBUEIdiEIQY6AgIB4IRIMCQsDQCAEQQhPAn4gDkH/AXFFBEAgDEEYakEBEFsMAQsgDCAOQQFrIgU6ACwgDCkDICAFQT9xrYhCAYMLIitCAVFyRQRAIARBAWohBCAMLQAsIQ4MAQsLIARBB0sNAyAMQTBqIgQgDCAMQRhqIgsQ6AEgDC0AMCIFQQNHDQYgBCAMQQxqIAsQ6AEgDC0AMCIFQQNHDQUgCkEDdEEIaiEdIAhBADYCFCAMLQAJIQQgDCgCDCELIAwoAgAhDkEAIQUCQCAIQQxqIgoCfwJAA0AgCigCACAFRgRAIApBrPrBABDCAQsgCCgCECAFaiAEOgAAIAggBUEBajYCFAJ+QgAgDC0ACCIERQ0AGiAEIAwtACwiBU0EQCAMIAUgBGsiBToALEJ/IASthkJ/hSAMKQMgIAVBP3GtiIMMAQsgDEEYaiAEEFsLISsCfgJAIAwoAgQgK6dqIgQgDigCCCIFSQRAIAwgDigCBCAEQQN0aikCACIrNwIEIAgoAgwhEiAIKAIUIQUgDC0AFSEEAkAgDCgCKCAMLQAsakEATgRAIAUgEkYEQCAKQbz6wQAQwgELIAgoAhAgBWogBDoAACAIIAVBAWo2AhQgDC0AFCIEDQFCAAwECyAFIBJHDQdB3PrBAAwGCyAMLQAsIgUgBEkNASAMIAUgBGsiBToALEJ/IASthkJ/hSAMKQMgIAVBP3GtiIMMAgsgBCAFQbyAwgAQrQIACyAMQRhqIAQQWwshMyAMKAIQIDOnaiIFIAsoAggiBE8NBSArQiiIpyEEIAwgCygCBCAFQQN0aikCADcCECAIKAIUIQUgDCgCKCAMLQAsakEASA0BIAVB/wFNDQALIAVBCHYhCEGLgICAeCESQQAhDgwLCyAFIAooAgBHDQFBzPrBAAsQwgELIAgoAhAgBWogBDoAACAIIAVBAWoiBDYCFAsgCEEANgIgQQAhDiAEIAgoAhhPBEAgCEEYakEAIARBAWpBAUEBEJIBIAgoAiAhDgsgCCgCHCIKIA5qIQVBACELIAQEfyAFQQAgBBBaGiAKIAQgDmoiDmoFIAULQQA6AAAgCCAOQQFqNgIgQYyAgIB4IRICQCAIKAIUIhdFDQAgHUEDdiAdQQdxQQBHaiEdIAgoAhAhCkEAIQ5BACEFAkACQANAIAogDmotAAAiBEELSw0BQQEgBEEBa3RBACAEGyAFaiEFIBcgDkEBaiIORw0ACyAFDQEMAgtBkYCAgHghEgwBC0EBQSAgBWciC2siCnQiDiAFayIEaUEBRgRAIAUgDkYNAyAKQQFqIQ4gBGchEkEAIQQCQAJAAkADQCAEIAgoAhQiGk8NASAEIAgoAiAiGk8NAyAIKAIcIARqIA4gCCgCECAEai0AACIaa0EAIBobOgAAIARBAWoiBCAXRw0ACyAIKAIUIgQgCCgCICIOSQ0BIAQgDkHs+sEAEK0CAAsgBCAaQYj9wQAQrQIACyAIKAIcIARqIAogEmpBH2s6AAAgCCAKOgBkIAVB/w9NDQZBkoCAgHghEkEAIQsgCiEEDAILIAQgGkGY/cEAEK0CAAsgBEGAfnEhC0GNgICAeCESCyAZIBI2AgAgGSALIARB/wFxcjYCBAwICyAFIARBvIDCABCtAgALQfz3wQBBF0H8+MEAEO0CAAsgBEEBaiIFQQh2IQhBioCAgHghEkEAIQ4MBAsgCEEANgIsIAhBJGpBISALayIXEKMBAkACQAJAIAgoAiAiDgRAIAgoAhwhBANAIAgoAiwiCyAELQAAIgVNDQIgCCgCKCAFQQJ0aiIFIAUoAgBBAWo2AgAgBEEBaiEEIA5BAWsiDg0ACwsgCEEBIAgtAGR0Ig4gCCgCCCIESwR/IA4gBCIFayISIAgoAgAgBGtLBEAgCCAEIBJBAUECEJIBIAgoAgghBQsgCCgCBCAFQQF0aiELIBJBAk8EQCAEQX9zIA5qIg5BB3EhBCASQQJrQQdPBEAgDkF4cSEOA0AgC0EAOgAPIAtBADoADiALQQA6AA0gC0EAOgAMIAtBADoACyALQQA6AAogC0EAOgAJIAtBADoACCALQQA6AAcgC0EAOgAGIAtBADoABSALQQA6AAQgC0EAOgADIAtBADoAAiALQQA6AAEgC0EAOgAAIAtBEGohCyAOQQhrIg4NAAsLIAQEQANAIAtBADoAASALQQA6AAAgC0ECaiELIARBAWsiBA0ACwsgBSASakEBayEFCyALQQA6AAEgC0EAOgAAIAVBAWoFIA4LNgIIIAhBADYCOCAIQTBqIBcQowEgCCgCOCIEIApNBEAgCiAEQaz7wQAQrQIACyAIKAI0IApBAnRqQQA2AgAgCCgCOCIOQf4BcUUNAgwBCyAFIAtB+PzBABCtAgALAkACQAJAA0AgCCgCOCIFIA5BAWsiDkH/AXEiBE0NAiAIKAIsIgsgBE0NASAFIARBAWsiC0sEQCAIKAI0IgUgC0ECdGogBEECdCILIAgoAihqKAIAIAogDmt0IAUgC2ooAgBqNgIAIARBAU0NBAwBCwsgCyAFQej8wQAQrQIACyAEIAtB2PzBABCtAgALIAQgBUHI/MEAEK0CAAsgCCgCOCEOCyAOBEAgCCgCCCIEIAgoAjQiBSgCAEYEQCAIKAIgIhcEQEEAIQsDQAJAAkACQCAIKAIgIgQgC0sEQCAIKAIcIAtqLQAAIhJFDQMgCCgCOCIEIBJNDQEgCCgCNCASQQJ0aiIEIAQoAgAiBEEBIAogEmt0IgVqNgIAIARBAXQhDgNAIAQgCCgCCCIaTw0DIAgoAgQgDmogCzoAACAIKAIIIhogBEsEQCAIKAIEIA5qQQFqIBI6AAAgDkECaiEOIARBAWohBCAFQQFrIgVFDQUMAQsLIAQgGkG4/MEAEK0CAAsgCyAEQYj8wQAQrQIACyASIARBmPzBABCtAgALIAQgGkGo/MEAEK0CAAsgC0EBaiILIBdHDQALCyAZQZOAgIB4NgIAIBkgHTYCBAwGCyAMQQI2AhwgDEHo+8EANgIYIAxCAjcCJCAMIAQ2AgwgDCAMQQxqrUKAgICAEIQ3AzggDCAFrUKAgICAEIQ3AzAgDCAMQTBqNgIgIAxBGGpB+PvBABCkAwALQQBBAEG8+8EAEK0CAAsgDCgCNCIEQYB+cSEOIAwvADEgDC0AM0EQdHIMAQsgDCgCNCIEQYB+cSEOIAwvADEgDC0AM0EQdHILIQggDDUCOCErQYaAgIB4IRILIBkgKzcCDCAZIBI2AgAgGSAOIARB/wFxcjYCCCAZIAVB/wFxIAhBCHRyNgIECyAMQUBrJAAgCSgCHCEFIAkoAhgiCEGTgICAeEcNAyAFIBFLDQEMBgtBACEFIA0tAGQNBUGYgICAeCEIDAYLIAUgEUHo7MEAEKoEAAsgBgRAIBAgECgCCCIGIAYgBSgCCCIEaiIFSQR/IBwtAAAhBSAEIBAoAgAgBmtLBEAgECAGIARBAUEBEJIBIBAoAgghBgsgECgCBCILIAZqIQogBEECTwR/IAogBSAEQQFrIgQQWhogCyAEIAZqIgZqBSAKCyAFOgAAIAZBAWoFIAULNgIIIBRCnoCAgBg3AgAMBgtBAEEAQfTrwQAQrQIACyAJKQIkISogCSgCICEGDAMLIAQgBkHk68EAEKsEAAsgESAGQYTswQAQqwQACyAFIBxqIQQgESAFayEFAkACQAJAAkACQAJAAkACQAJAIB5BAWsOBAECAgACCyAFQQZJBEBBmYCAgHghCAwJCyAFQQZrIgUgBC8AACIMIAQtAAJqIAQtAANBCHRqIg4gBC0ABGogBC0ABUEIdGoiBkkEQEGagICAeCEIDAkLIAlCADcDCCAJIA02AhBBACEIIAlBADoALCAJQgA3AyAgCSAEQQZqIhI2AhggCSAMNgIcIAkgDEEDdDYCKCAGIA5rIRlBACEKA0AgCkEITwJ+IAhB/wFxRQRAIAlBGGpBARBbDAELIAkgCEEBayIEOgAsIAkpAyAgBEE/ca2IQgGDCyIqQgFRckUEQCAKQQFqIQogCS0ALCEIDAELCyAKQQdLBEAgCkEBaiEFQZuAgIB4IQgMCQsgCUEIaiAJQRhqELACIAkoAiggCS0ALGoiCkEAIA0tAGRrIgRMDQYgCSkDCCEqIAkoAhAhCwNAIAsoAggiBCAqpyIKTQ0EIApBAXQiCCALKAIEai0AACEXIBAoAggiBCAQKAIARgRAIBBBlOzBABDCAQsgECgCBCAEaiAXOgAAIBAgBEEBajYCCAJAAkAgCiALKAIIIgRJBEAgCS0ALCEKIAsoAgQgCGotAAEiCA0BQgAhKwwCCyAKIARBnPnBABCtAgALIAggCkH/AXFLBEAgCUEYaiAIEFshKyALKAIIIQQgCS0ALCEKDAELIAkgCiAIayIKOgAsQn8gCK2GQn+FIAkpAyAgCkE/ca2IgyErCyAErUIBfSAqIAithoMgK4QhKiAJKAIoIApB/wFxaiIKQQAgDS0AZGsiBEoNAAsMBgsgCUIANwMIIAkgDTYCEEEAIQYgCUEAOgAsIAlCADcDICAJIAQ2AhggCSAFNgIcIAkgBUEDdDYCKEEAIQUMAQtBtOzBAEEiQdjswQAQ7QIACwNAIAVBCE8CfiAGQf8BcUUEQCAJQRhqQQEQWwwBCyAJIAZBAWsiBjoALCAJKQMgIAZBP3GtiEIBgwsiKkIBUXJFBEAgBUEBaiEFIAktACwhBgwBCwsgBUEHSw0CIAlBCGogCUEYahCwAiAJKAIoIAktACxqQQAgDS0AZGtMDQQgCSkDCCEqIAkoAhAhBANAIAQoAggiBSAqpyIGTQ0CIAZBAXQiCiAEKAIEai0AACELIBAoAggiBSAQKAIARgRAIBBBpOzBABDCAQsgECgCBCAFaiALOgAAIBAgBUEBajYCCAJAAkAgBiAEKAIIIghJBEAgCS0ALCEFIAQoAgQgCmotAAEiBg0BQgAhKwwCCyAGIAhBnPnBABCtAgALIAYgBUH/AXFLBEAgCUEYaiAGEFshKyAEKAIIIQggCS0ALCEFDAELIAkgBSAGayIFOgAsQn8gBq2GQn+FIAkpAyAgBUE/ca2IgyErCyAIrUIBfSAqIAathoMgK4QhKiAJKAIoIAVB/wFxakEAIA0tAGRrSg0ACwwECyAKIARBjPnBABCtAgALIAYgBUGM+cEAEK0CAAsgBUEBaiEFQZuAgIB4IQgMAgtBnICAgHghCCAEIApHBEAgBCEGIAohBQwCCyAGIBJqIQogBSAGayEEIAlCADcDCCAJIA02AhBBACEGIAlBADoALCAJQgA3AyAgCSAMIBJqNgIYIAkgDiAMayIFNgIcIAkgBUEDdDYCKEEAIQUDQCAFQQdLAn4gBkH/AXEEQCAJIAZBAWsiBjoALCAJKQMgIAZBP3GtiEIBgwwBCyAJQRhqQQEQWwsiKkIBUXJFBEAgBUEBaiEFIAktACwhBgwBCwsgBUEHSwRAIAVBAWohBUGbgICAeCEIDAILIA4gEmohCyAJQQhqIAlBGGoQsAICQAJAAkAgCSgCKCAJLQAsaiIFQQAgDS0AZGsiBkoEQANAIAkoAhAiBSgCCCIMIAkoAggiBk0NAiAFKAIEIAZBAXRqLQAAIQUgECgCCCIGIBAoAgBGBEAgEEGU7MEAEMIBCyAQKAIEIAZqIAU6AAAgECAGQQFqNgIIIAlBCGogCUEYahDKASAJKAIoIAktACxqIgVBACANLQBkayIGSg0ACwsCQCAFIAZHDQAgCUIANwMIIAkgDTYCEEEAIQYgCUEAOgAsIAlCADcDICAJIAs2AhggCSAZNgIcIAkgGUEDdDYCKEEAIQUDQCAFQQdLAn4gBkH/AXEEQCAJIAZBAWsiBjoALCAJKQMgIAZBP3GtiEIBgwwBCyAJQRhqQQEQWwsiKkIBUXJFBEAgBUEBaiEFIAktACwhBgwBCwsgBUEHSwRAIAVBAWohBUGbgICAeCEIDAYLIAlBCGogCUEYahCwAiAJKAIoIAktACxqIgVBACANLQBkayIGSgRAA0AgCSgCECIFKAIIIgsgCSgCCCIGTQ0EIAUoAgQgBkEBdGotAAAhBSAQKAIIIgYgECgCAEYEQCAQQZTswQAQwgELIBAoAgQgBmogBToAACAQIAZBAWo2AgggCUEIaiAJQRhqEMoBIAkoAiggCS0ALGoiBUEAIA0tAGRrIgZKDQALCyAFIAZHDQAgCUIANwMIIAkgDTYCEEEAIQYgCUEAOgAsIAlCADcDICAJIAo2AhggCSAENgIcIAkgBEEDdDYCKEEAIQUDQCAFQQdLAn4gBkH/AXEEQCAJIAZBAWsiBjoALCAJKQMgIAZBP3GtiEIBgwwBCyAJQRhqQQEQWwsiKkIBUXJFBEAgBUEBaiEFIAktACwhBgwBCwsgBUEHSwRAIAVBAWohBUGbgICAeCEIDAYLIAlBCGogCUEYahCwAiAJKAIoIAktACxqIgVBACANLQBkayIGSgRAA0AgCSgCECIGKAIIIgUgCSgCCCIETQ0FIAYoAgQgBEEBdGotAAAhBiAQKAIIIgQgECgCAEYEQCAQQZTswQAQwgELIBAoAgQgBGogBjoAACAQIARBAWo2AgggCUEIaiAJQRhqEMoBIAkoAiggCS0ALGoiBUEAIA0tAGRrIgZKDQALCyAFIAZGDQQLDAQLIAYgDEGM+cEAEK0CAAsgBiALQYz5wQAQrQIACyAEIAVBjPnBABCtAgALIBYgECgCCCIFRwRAQZ2AgIB4IQggFiEGDAELIBRBnoCAgHg2AgAgFCARNgIEDAELIBQgKjcCDCAUIAY2AgggFCAFNgIEIBQgCDYCAAsgCUEwaiQAIA8oAhAhBCAPKAIMIgZBnoCAgHhHDQ8gDSgC8AIiBiAPKAKggAhHDRAgBCAHRw0RIA9BADoArIAIIA9BADYCqIAIIA9BqIAIaiEKIAcgHGohCwJAIB8gB2siBkUEQCAUQQE6AAggFEEANgIEIBRBAToAAAwBCwJAAkACQAJAIAstAAAiBUH/AUcEQCAFDQEgFEEBOgABIApBADYCACAUQQA6AAAMBQtBAyEEIAZBA00EQCAUQQQ6AAgMBAsgCy8AAUGA/gFqIQVBBCEHDAELAkAgBcBBAE4EQEEBIQQgBkEBRw0BIBRBAjoACCAUQQE2AgQgFEEBOgAADAULQQMhByAGQQNJDQIgCy0AASAFQQh0ckGAgAJrIQVBAiEEDAELQQIhBwsgCiAFNgIAIApBAToABCAUIAc6AAEgCiAEIAtqLQAAOgAFIBRBADoAAAwCCyAUQQM6AAgLIBQgBjYCBCAUQQE6AAALIA8tAAwNEiAGIA8tAA0iBEkNEyAVICFHDRQgBiAEayERIA8oAqiACEUEQCAEIAZGBEAgDUHoAWogDSgC7AIgDSgC8AIQpwEgDUEANgL8AgwMCyAPQYyAgIB4NgKMgAggDyARQQN0NgKQgAhBBSEHDBkLIA9BDGohCiAEIAtqIRYgDUHoAGohBSANQfQCaiELQQAhB0EAIQZCACEqIwBB8ABrIgQkAAJAAkACQAJAAkACQCAPQaiACGoiCS0ABEUEQEGNgICAeCEIDAELAkACQAJAAkACQAJAAkACQAJAAkACQCAJLQAFIhBBwAFxQQZ2QQFrDgMBAgkAC0GF5cIALQAAGkGQAUEEEPUDIgZFDQMgBkHo78EAQZABEDshBkGF5cIALQAAGkGQAUEEEPUDIgdFDQQgByAGQZABEDshByAFKAI0IggEQCAFKAI4IAhBAnRBBBCnBAsgBUEGOgBNIAVBJDYCPCAFIAc2AjggBUEkNgI0IARB0ABqIAVBKGoQKSAEKAJQIghBhYCAgHhHDQIgBkGQAUEEEKcEQQAhBiAFQQA6AHoMCAsgEUUEQEGOgICAeCEIDAoLIBYtAAAiB0EjTQ0FDAgLIARB0ABqIAVBKGogFiARQQkQLSAEKAJUIQcgBCgCUCIIQYWAgIB4Rg0DIARBCGogBEHgAGooAgA2AgAgBCAEKQJYNwMADAgLIARBCGogBEHgAGooAgA2AgAgBCAEKQJYNwMAIAQoAlQhByAGQZABQQQQpwQMBwtBBEGQAUHc6sEAENcDAAtBBEGQAUGQ/8EAENcDAAsgBUEAOgB6DAELIAUgBzoAe0EBIQcgBUEBOgB6CyAHIBFNBEAgByEGDAELIAcgEUHQ88EAEKoEAAsgBiAWaiEHAkACQAJAAkACQAJAAkACQAJAIBBBBHZBA3FBAWsOAwEECAALQYXlwgAtAAAaQfQAQQQQ9QMiB0UNBCAHQfjwwQBB9AAQOyEMQYXlwgAtAAAaQfQAQQQQ9QMiB0UNBSAHIAxB9AAQOyEHIAUoAgwiCARAIAUoAhAgCEECdEEEEKcECyAFQQU6ACUgBUEdNgIUIAUgBzYCECAFQR02AgwgBEHQAGogBRApIAQoAlAiCEGFgICAeEcNASAMQfQAQQQQpwQgBUEAOgB4DAcLIAYgEUcNAUGPgICAeCEIDAgLIARBCGogBEHgAGooAgA2AgAgBCAEKQJYNwMAIAQoAlQhByAMQfQAQQQQpwQMBwsgBy0AACIHQR9LDQUgBSAHOgB5IAVBAToAeCAGQQFqIQYMBAsgBEHQAGogBSAHIBEgBmtBCBAtIAQoAlQhByAEKAJQIghBhYCAgHhGDQIgBEEIaiAEQeAAaigCADYCACAEIAQpAlg3AwAMBQtBBEH0AEHc6sEAENcDAAtBBEH0AEGQ/8EAENcDAAsgBUEAOgB4IAYgB2ohBgsCQAJAAkACQAJAAkACQAJAAkAgBiARTQRAIAYgFmohDCAQQQJ2QQNxQQFrDgMCBQYBCyAGIBFBwPPBABCqBAALQYXlwgAtAAAaQdQBQQQQ9QMiB0UNBiAHQezxwQBB1AEQOyEMQYXlwgAtAAAaQdQBQQQQ9QMiB0UNBSAHIAxB1AEQOyEHIAUoAlwiCARAIAUoAmAgCEECdEEEEKcECyAFQQY6AHUgBUE1NgJkIAUgBzYCYCAFQTU2AlwgBEHQAGogBUHQAGoQKSAEKAJQIghBhYCAgHhHDQEgDEHUAUEEEKcEIAVBADoAfAwEC0GQgICAeCEIIAYgEUcNAQwICyAEQQhqIARB4ABqKAIANgIAIAQgBCkCWDcDACAEKAJUIQcgDEHUAUEEEKcEDAcLIAwtAAAiDEE0Sw0GIAUgDDoAfSAFQQE6AHwgBkEBaiEGDAELIARB0ABqIAVB0ABqIAwgESAGa0EJEC0gBCgCVCEHIAQoAlAiCEGFgICAeEcEQCAEQQhqIARB4ABqKAIANgIAIAQgBCkCWDcDAAwGCyAFQQA6AHwgBiAHaiEGCwJAIAYgEU0EQEEAIQggBEEAOgAkIARCADcDGCAEIAYgFmo2AhAgBCARIAZrIgY2AhQgBCAGQQN0NgIgQQAhBwwBCyAGIBFB8O3BABCqBAALA0AgB0EITwJ+IAhB/wFxRQRAIARBEGpBARBbDAELIAQgCEEBayIGOgAkIAQpAxggBkE/ca2IQgGDC0IBUXJFBEAgB0EBaiEHIAQtACQhCAwBCwsgB0EHTQRAIAUtAHoiEA0DIAUtAHxBAUYNAyAFLQB4DQMgBSgCMARAIAUoAiwpAgAhKgsgCSgCACEJIAQgBUEoajYCKCAEICo3AiwgBSgCWARAIAUoAlQpAgAhLAsgBCAFQdAAajYCNCAEICw3AjggBSgCCAR+IAUoAgQpAgAFQgALISogBCAFNgJAIAQgKjcCRCAEQdAAaiIGIARBKGogBEEQaiIFEOgBIAQtAFAiB0EDRgRAIAYgBEFAayAFEOgBIAQtAFAiB0EDRgRAIAYgBEE0aiAFEOgBIAQtAFAiBkEDRgRAIAtBADYCCCAJIAsoAgBLBEAgC0EAIAlBBEEMEJIBC0F/IQUDQAJ/AkACQCAFQQFqIgUgCUYEQCAEKAIgIAQtACRqIgZBAEoNASAKQZGAgIB4NgIADA4LIAQtAD0hByAELQBJIQYgBCAELQAxIgw6AE8gDEEQSSIQDQEgDEEQa0H/AXEiCEEUTw0OIAhBAnRB9PPBAGooAgAhDCAIQeDzwQBqLQAADAILIAogBjYCBCAKQYyAgIB4NgIADAwLQQALIQggBCAHOgBPAn8gB0EgSSIORQRAIAdBIGtB/wFxIgdBFU8NDiAHQQJ0Qdz0wQBqKAIAIRYgB0HE9MEAai0AAAwBCyAHQQNqQf8BcSEWQQALIRECfgJ+AkAgBkEfTQRAIAYgCGogEWoiFUH/AXEiFEUEQEIAISxCACEqQgAMBAsgBq0hKiAUQThNBEAgFCAELQAkIgdLBEAgBEHQAGogBEEQaiAGIBEgCCAVEDQgBCkDWCEsIAQpA1AhKiAEKQNgDAULQgAhLCAGBH4gBCAHIAZrIgc6ACRCfyAqhkJ/hSAEKQMYIAdBP3GtiIMFQgALISogDkUEQCAEIAcgEWsiBzoAJEJ/IBGthkJ/hSAEKQMYIAdBP3GtiIMhLAtCACAQDQQaIAQgByAIayIHOgAkQn8gCK2GQn+FIAQpAxggB0E/ca2IgwwEC0IAISxCACAGRQ0CGiAELQAkIgcgBkkNASAEIAcgBmsiBzoAJEJ/ICqGQn+FIAQpAxggB0E/ca2IgwwCCyAKIAY6AAQgCkGJgICAeDYCAAwNCyAEQRBqIAYQWwshKgJAIA4NACAELQAkIgcgEUH/AXFJBEAgBEEQaiAREFshLAwBCyAEIAcgEWsiBzoAJEJ/IBGthkJ/hSAEKQMYIAdBP3GtiIMhLAtCACAQDQAaIAQtACQiByAIQf8BcUkEQCAEQRBqIAgQWwwBCyAEIAcgCGsiBzoAJEJ/IAithkJ/hSAEKQMYIAdBP3GtiIMLISsgKqdBASAGdGoiCEUEQCAKQYqAgIB4NgIADAsLIAsoAggiBiALKAIARgRAIAtBkO7BABCyAQsgCygCBCAGQQxsaiIHIAg2AgggByAWICynajYCBCAHIAwgK6dqNgIAIAsgBkEBaiIGNgIIIAYgCUkEQCAEQShqIARBEGoiBhDsASAEQTRqIAYQ7AEgBEFAayAGEOwBCyAEKAIgIAQtACRqQQBODQALIApBi4CAgHg2AgAMCQsgCiAEKQBRNwAFIApBDGogBEHYAGooAAA2AAAgCiAGOgAEIApBhoCAgHg2AgAMCAsgCiAEKQBRNwAFIApBDGogBEHYAGooAAA2AAAgCiAHOgAEIApBhoCAgHg2AgAMBwsgCiAEKQBRNwAFIApBDGogBEHYAGooAAA2AAAgCiAHOgAEIApBhoCAgHg2AgAMBgsgCiAHQQFqNgIEIApBiICAgHg2AgAMBQtBBEHUAUGQ/8EAENcDAAtBBEHUAUHc6sEAENcDAAsgBSgCMARAIAUoAiwpAgAhKgsgCSgCACEJIAQgBUEoajYCKCAEICo3AiwgBSgCWARAIAUoAlQpAgAhLAsgBCAFQdAAajYCNCAEICw3AjggBSgCCAR+IAUoAgQpAgAFQgALISogBCAFNgJAIAQgKjcCRAJAIBANACAEQdAAaiAEQShqIARBEGoQ6AEgBC0AUCIGQQNGDQAgCiAEKQBRNwAFIApBDGogBEHYAGooAAA2AAAgCiAGOgAEIApBhoCAgHg2AgAMAwsCQCAFLQB4Ig4NACAEQdAAaiAEQUBrIARBEGoQ6AEgBC0AUCIGQQNGDQAgCiAEKQBRNwAFIApBDGogBEHYAGooAAA2AAAgCiAGOgAEIApBhoCAgHg2AgAMAwsCQCAFLQB8IhQNACAEQdAAaiAEQTRqIARBEGoQ6AEgBC0AUCIGQQNGDQAgCiAEKQBRNwAFIApBDGogBEHYAGooAAA2AAAgCiAGOgAEIApBhoCAgHg2AgAMAwsgC0EANgIIIAkgCygCAEsEQCALQQAgCUEEQQwQkgELIAUtAHkhHyAFLQB9IR4gBS0AeyEaQX8hFiAEKAJAIRUgBCgCNCESIAQoAighGQNAAn8CQAJAIBZBAWoiFiAJRgRAIAQoAiAgBC0AJGoiBkEASg0BIApBkYCAgHg2AgAMBwsgBC0APSEHIAQtAEkhESAEIBogBC0AMSAQGyIFOgBPIAVB/wFxIgZBEEkiHA0BIAVBEGtB/wFxIgVBFE8NByAFQQJ0QfTzwQBqKAIAIQYgBUHg88EAai0AAAwCCyAKIAY2AgQgCkGMgICAeDYCAAwFC0EACyEFIAQgHiAHIBQbIgc6AE8CfyAHQf8BcUEgSSIXRQRAIAdBIGtB/wFxIgdBFU8NByAHQcT0wQBqLQAAIQggB0ECdEHc9MEAaigCAAwBC0EAIQggB0EDakH/AXELISgCfgJ+AkAgHyARIA4bIhFB/wFxIgxBH00EQCAFIBFqIAhqIilB/wFxIh1FBEBCACEsQgAhKkIADAQLIB1BOE0EQCAdIAQtACQiB0sEQCAEQdAAaiAEQRBqIBEgCCAFICkQNCAEKQNYISwgBCkDUCEqIAQpA2AMBQtCACEsIAwEfiAEIAcgEWsiBzoAJEJ/IBGthkJ/hSAEKQMYIAdBP3GtiIMFQgALISogF0UEQCAEIAcgCGsiBzoAJEJ/IAithkJ/hSAEKQMYIAdBP3GtiIMhLAtCACAcDQQaIAQgByAFayIHOgAkQn8gBa2GQn+FIAQpAxggB0E/ca2IgwwEC0IAISxCACAMRQ0CGiAELQAkIgcgDEkNASAEIAcgEWsiBzoAJEJ/IBGthkJ/hSAEKQMYIAdBP3GtiIMMAgsgCiAROgAEIApBiYCAgHg2AgAMBgsgBEEQaiAREFsLISoCQCAXDQAgBC0AJCIHIAhB/wFxSQRAIARBEGogCBBbISwMAQsgBCAHIAhrIgc6ACRCfyAIrYZCf4UgBCkDGCAHQT9xrYiDISwLQgAgHA0AGiAELQAkIgcgBUH/AXFJBEAgBEEQaiAFEFsMAQsgBCAHIAVrIgc6ACRCfyAFrYZCf4UgBCkDGCAHQT9xrYiDCyErICqnQQEgDHRqIghFBEAgCkGKgICAeDYCAAwECyALKAIIIgUgCygCAEYEQCALQYDuwQAQsgELIAsoAgQgBUEMbGoiByAINgIIIAcgKCAsp2o2AgQgByAGICunajYCACALIAVBAWoiBjYCCAJAIAYgCU8NACAQRQRAAn5CACAELQAwIgZFDQAaIAYgBC0AJCIFTQRAIAQgBSAGayIFOgAkQn8gBq2GQn+FIAQpAxggBUE/ca2IgwwBCyAEQRBqIAYQWwshKiAEKAIsICqnaiIIIBkoAggiBU8NCCAEIBkoAgQgCEEDdGopAgA3AiwLIBRFBEACfkIAIAQtADwiBkUNABogBiAELQAkIgVNBEAgBCAFIAZrIgU6ACRCfyAGrYZCf4UgBCkDGCAFQT9xrYiDDAELIARBEGogBhBbCyEqIAQoAjggKqdqIgggEigCCCIFTw0IIAQgEigCBCAIQQN0aikCADcCOAsgDg0AAn5CACAELQBIIgZFDQAaIAYgBC0AJCIFTQRAIAQgBSAGayIFOgAkQn8gBq2GQn+FIAQpAxggBUE/ca2IgwwBCyAEQRBqIAYQWwshKiAEKAJEICqnaiIIIBUoAggiBU8NByAEIBUoAgQgCEEDdGopAgA3AkQLIAQoAiAgBC0AJGpBAE4NAAsgCkGLgICAeDYCAAwCC0GQgICAeCEICyAKIAc2AgQgCiAINgIAIAogBCkDADcCCCAKQRBqIARBCGooAgA2AgALIARB8ABqJAAMAwsgBEEBNgJUIARB7O7BADYCUCAEQgE3AlwgBCAEQc8Aaq1CgICAgIA5hDcDaCAEIARB6ABqNgJYIARB0ABqQfTuwQAQpAMACyAEQQE2AlQgBEHQ78EANgJQIARCATcCXCAEIARBzwBqrUKAgICAgDmENwNoIAQgBEHoAGo2AlggBEHQAGpB2O/BABCkAwALIAggBUG8gMIAEK0CAAsgDygCDCIEQZGAgIB4Rg0JIA8gDykCEDcCkIAIIA8gBDYCjIAIIA8pAhghLUEFIQcMGAtBpITBAEHbAEGAhcEAEO0CAAsgDyAFLQAAOgAMCyAEIAc2AgQgBCALNgIADBMLIARBADYCBCAEIAUgBmo2AgAMAQsgBEEANgIEIAQgBSAHajYCAEHw/8AAKQMAIi1C/wGDQgRRDRELIBhBADoADCAYIC03AgQgGEEJNgIADBMLQfD/wAApAwAiKkL/AYNCBFINDgsgIkEAOgAAIA9BDWogBUH/AxBaGiAHQYAETwRAIAdBCXYhBiANQegBaiEEA0AgBCAPQQxqQYAEEKcBIAZBAWsiBg0ACwsgDUHoAWogD0EMaiAHQf8DcRCnASAYQQo2AgAgGEIBNwMIDBELIBhBCDYCAAwQCyAPQQxqIQxBACEGQQAhB0EAIQhBACEWIwBBMGsiESQAIA0oAuwBIQsgDSgC8AEhHCANKAL0ASEKIBFBADYCACANQegBaiEUIAshBSAKIQQCQCANKAL8AiIdBEAgDUGIA2ohHyANQYwDaiEQQQghEgNAAkACQAJAAkACQAJAAkACfwJAIA0oAvwCIgQgCEsEQCANKAL4AiASaiIFKAIAIQQgBUEEaygCACEZIAVBCGsoAgAiCQ0HIARBAWsiB0ECTw0BIBAgBEECdGooAgAMAgsgCCAEQaDnwQAQrQIACyAEQQNGBEAgECgCACIEQQFrIQUMAgsgBEEDawshBQJAIAcOAgIDAAsgECgCACEECyANIA0oApADNgKUAwwCCyAQKAIAIQQMAQsgDSANKAKQAzYClAMgDSgCjAMhBAsgBiEHDAELAkAgBiAJaiIHIA0oAvACIgVNBEAgBiAHTQ0BIAYgB0Gw58EAEKwEAAsgDCAFNgIIIAwgBzYCBCAMQQI2AgAMBQsgDSgC7AIhFyANKALwASIOIA0oAuwBIhUgDSgC9AEiBSAOSSIeGyAFa0EAIA4gHhtqIh5BAWsiGkEAIBogHk0bIh4gCUkEQCAUIAkgHmsQgAEgDSgC7AEhFSANKALwASEOIA0oAvQBIQULIAYgF2ohFyAOIBUgBSAOSRsiHiAFayIGIAkgBiAJSSIaGyEGIBQoAgAhDiAFIB5HBEAgBSAOaiAXIAYQOxoLIBoEQCAOIAYgF2ogCSAGaxA7GgsCQCAVBEAgDSAFIAlqIBVwNgL0ASANIA0pA/gBIAmtfDcD+AEgBEEBayIGQQNPBEAgBEEDayEFDAILIB8gBEECdGooAgAhBQwBC0Gw6cEAEJQDAAsCQAJAIAYOAgMBAAsgDSANKAKQAzYClAMgDSgCjAMhBAwBCyAQKAIAIQQLIA0gBTYCjAMgDSAENgKQAwsgBUUEQCAMQQM2AgAMAwsCQCAZRQ0AIBFBCGogFCAFIBkQsQEgESgCCCIEQQJGDQAgDCARKQIMNwIEIAwgBDYCAAwDCyARIAkgFmogGWoiFjYCACASQQxqIRIgByEGIB0gCEEBaiIIRw0ACyANKALsASEFIA0oAvQBIQQLAkAgDSgC8AIiBiAHTQ0AIA0oAuwCIAdqIQggBiAHayIHIA0oAvABIgYgBSAEIAZJIgkbIARrQQAgBiAJG2oiCUEBayIQQQAgCSAQTxsiCUsEQCANQegBaiAHIAlrEIABIA0oAuwBIQUgDSgC8AEhBiANKAL0ASEECyAGIAUgBCAGSRsiECAEayIGIAcgBiAHSSIOGyEGIBQoAgAhCSAEIBBHBEAgBCAJaiAIIAYQOxoLIA4EQCAJIAYgCGogByAGaxA7GgsgBQRAIA0gBCAHaiAFcCIENgL0ASANIA0pA/gBIAetfDcD+AEgESAHIBZqIhY2AgAgDSgC7AEhBQwBC0Gw6cEAEJQDAAsgESAEIBxqIA0oAvABIgYgCiALQQAgCiAcSRtqamsgBUEAIAQgBkkbaiIENgIEIAQgFkcEQCARQQI2AgwgEUGM5sEANgIIIBFCAjcCFCARIBFBBGqtQoCAgIAQhDcDKCARIBGtQoCAgIAQhDcDICARIBFBIGo2AhAgEUEIakGQ58EAEKQDAAsgDEEENgIACyARQTBqJAAgDygCDCIEQQRHDQ0LIBggIa03AwggIkEAOgAAIBhBCjYCAAwOCyAPQZOACGogLUI4iDwAACAPQZGACGogLUIoiD0AACAPIAQ6AIyACCAPIC1CCIg+AI2ACAwMCyAPQZaACGogD0EWai8BADsBACAPIA8pAQ43AY6ACCAPIAQ6AI2ACCAPIAU6AIyACEEDIQcMCwsgBCAVQZSEwQAQqgQACyAPIB82ApCACCAPIAc2AoyACEEBIQcMCQsgDyAPKAIUNgKUgAggDyAENgKQgAggDyAGNgKMgAggDykCGCEtQQIhBwwICyAPQQI2AhAgD0G4gcEANgIMIA9CAjcCGCAPIAY2AryACCAPIA9BoIAIaq1CgICAgBCENwOwgAggDyAPQbyACGqtQoCAgIAQhDcDqIAIIA8gD0GogAhqNgIUIA9BDGpByIHBABCkAwALQdiBwQBB0wBBrILBABDtAgALIA8oAhAhBCAPIA8tABQ6AJCACCAPIAQ2AoyACEEEIQcMBQsgBCAGQYSEwQAQqgQAC0G8gsEAQbYBQfSDwQAQ7QIACyAYQQE6AAwgGCAqNwIEIBhBCTYCAAwDCyANQegBaiAPQQxqIAYQpwEgGCAKrTcDCCAiQQA6AAAgGEEKNgIADAILIA8gDykCEDcCkIAIIA8gBDYCjIAIQQYhBwsgGCAHNgIAIBggDykCjIAINwIEIBggLTcDECAYQQxqIA9BlIAIaigCADYCAAsgD0HAgAhqJAAgEygCSCIEQQpHDQMgASABKQPAAyATKQNQfDcDwAMgASABKALIA0EBajYCyAMCQCATLQB5BEAgIEEBOgDMAyAgLQAQQQRxRQ0BIBMoAkQiBigCACEFAkACQCAGKAIEIgdBBE8EQCAGIAdBBGs2AgQgBiAFQQRqNgIAIAUoAAAhBAwBC0EAIQQgBkEANgIEIAYgBSAHajYCACAwQgRSDQELIAEgASkDwANCBHw3A8ADICAgBDYCHCAgQQE2AhgMAgsgEyAvNwMQQQYMBwsgJCAnIAEoApgCIgZqayABKAKUAiABKAKcAiIEIAQgBkkiBhtqIARBACAGG2ogJkkNAQsLIAEQvwEgA08NBSABKAIAQQJHDQEMBQsLIBMgLjcDEEEEDAILIBNBCGogE0HcAGooAgA2AgAgEyATKQJUNwMAIBMgEykCTDcCFCATIAQ2AhBBBQwBC0EHCyEBIBNBLGogE0EYaigCADYCACATQThqIBNBCGooAgA2AgAgEyABNgIgIBMgEykDEDcCJCATIBMpAwA3AzBBheXCAC0AABpBIEEIEPUDIgFFBEBBCEEgENMEAAsgASATQSBqIgIpAwA3AwAgAUEYaiACQRhqKQMANwMAIAFBEGogAkEQaikDADcDACABQQhqIAJBCGopAwA3AwBBheXCAC0AABpBDEEEEPUDIgJFBEBBBEEMENMEAAsgAkEoOgAIIAJBwNvAADYCBCACIAE2AgAgACACrUIghkIDhDcCAAwBCwJAIAEoAgBBAkYEQCAAQQQ6AAAgAEEANgIEDAELIAFBkAJqIQQgAS0AzANFBEACQAJAAkAgBCgCDCIGQQAgBiAEKAIIIgFJIgcbIgUgBCgCBCAGIAcbIgdqIAEgBCgCcCIGamtBACAHIAFrIg0gBWogBksbIgYgAyADIAZLGyIGRSABIAdGcg0AIAIgBCgCACIHIAFqIgIgDSAGIAYgDUsbIgEQOyENIARBGGoiCiACIAEQVyAGIAFrIgIgBSACIAVJGyICBEAgAyABayIDIAJJDQIgASANaiAHIAIQOxogCiAHIAIQVyABIAJqIgFFDQELIAQoAgQiAkUNAiAEIAIgBCgCDCIDIAMgBCgCCCIESSIFGyAEayADQQAgBRtqIgMgASABIANLGyAEaiACcDYCCAsgAEEEOgAAIAAgBjYCBAwDCyACIANBkPfBABCrBAALQcDpwQAQlAMACwJAAkACQAJAIAQoAgQgBCgCDCIGIAYgBCgCCCIBSSIHGyINIAFrIgUgBkEAIAcbIgdqIgYgAyADIAZLGyIGRSABIA1Gcg0AIAIgBCgCACINIAFqIgIgBSAGIAUgBkkbIgEQOyEFIARBGGoiCiACIAEQVyAGIAFrIgIgByACIAdJGyICBEAgAyABayIDIAJJDQIgASAFaiANIAIQOxogCiANIAIQVyABIAJqIgFFDQELIAQoAgQiAkUNAiAEIAIgBCgCDCIDIAMgBCgCCCIESSIFGyAEayADQQAgBRtqIgMgASABIANLGyAEaiACcDYCCAsgAEEEOgAAIAAgBjYCBAwCCyACIANBsPfBABCrBAALQcDpwQAQlAMACwsLIBNBgAFqJAALtwgBEH8CQAJAIAEoAhQiBCABLQAkQQFqTQRAIAFBADYCCCABAn9BASABLQAldCIHIAEoAgBLBEAgAUEAIAdBBEEIEJIBIAcgASgCCCICIAdPDQEaCyACIQQgByACayIGIAEoAgAgAmtLBEAgASACIAZBBEEIEJIBIAEoAgghBAsgASgCBCIFIARBA3RqIQMgBkECTwRAIANBACAHIAJBf3NqQQN0EFoaIAQgB2pBA3QgAkEDdGsgBWpBCGshAyAEIAZqQQFrIQQLIANCADcCACAEQQFqCyIGNgIIIAEoAhQiCA0BIAEoAgQhCyABKAIQIQogByEEDAILIAAgBDYCBCAAQYSAgIB4NgIADwsgAS0AJSEJIAEoAgQhCyABKAIQIgohAiAHIQRBACEDA0ACQCACKAIAQX9GBEAgBEEBayIEIAZPDQEgCyAEQQN0aiIFIAk6AAQgBUEANgIAIAUgAzoABQsgAkEEaiECIANBAWoiAyAIRw0BDAILCyAEIAZB6IHCABCtAgALIAdBA3YgB0EBdmpBA2ohDSAHQQFrIQ5BACEFQQAhAgNAIAUgCCAFIAhLGyEMIAogBUECdGohAwNAIAUgDEYEQEEAIQogAUEANgIgIAgEQEEAIQIgCCABKAIYSwRAIAFBGGpBACAIQQRBBBCSASABKAIgIQILIAEoAhwiBiACQQJ0aiEDIAhBAUcEfyADQQAgCEECdEEEaxBaGiACIAhqIgNBAWshAiAGIANBAnRqQQRrBSADC0EANgIAIAJBAWohCgsgASAKNgIgIAQEQCABKAIQIQ0gASgCHCEOIAEoAhQhCyABKAIEIQIgASgCCCEIIAEtACUhDEEAIQUDQAJAAkACQAJAAkACQCAFIAhHBEAgCyACQQVqLQAAIgFNDQEgASAKTw0DIA4gAUECdCIBaiIPKAIAIQYgASANaigCACIBDQJBACEDQQAhCQwGCyAIIAhB7IDCABCtAgALIAEgC0H8gMIAEK0CAAsgAUEBQQAgAWciA2t0QQEgA0Efc3QgAUYbIgMgB0sNAkEgIAcgA24iEGciCWsgCUEfcyADIAFrIgMgBksiERsiCUH/AXEgDEsNASAQIAZBAXQgAWogBiARGyADa2whAwwDCyABIApBjIHCABCtAgALQZyBwgBBKUHIgcIAEO0CAAtBoP/BAEEXQZyAwgAQ7QIACyAPIAZBAWo2AgAgAkEEaiAJOgAAIAIgAzYCACACQQhqIQIgBCAFQQFqIgVHDQALCyAAQYWAgIB4NgIADwsgBUEBaiEFIAMoAgAhCSADQQRqIQMgCUEATA0ACyAFQQFrIQxBACEDA0ACQCACIAZJBEAgA0EBaiEDIAsgAkEDdGogDDoABQNAIAIgDWogDnEiAiAETw0ACwwBCyACIAZB2IHCABCtAgALIAMgCUcNAAsMAAsAC9IHAQN/AkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAgAOCgAHBwECAwQHBwUHCwJAAkACQAJAAkACQCAALQAEDgcADAEMAgMEDAsgAC0ACEEDRw0LIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQQgASADIAIoAggQpwQMBAsgAC0ACEEDRw0KIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQMgASADIAIoAggQpwQMAwsgAC0ACEEDRw0JIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQIgASADIAIoAggQpwQMAgsgAC0ACEEDRw0IIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQEgASADIAIoAggQpwQMAQsgAC0ACEEDRw0HIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQAgASADIAIoAggQpwQLIABBDEEEEKcEDwsCQAJAIAAtAAQOAgcBAAsgACgCCCIBQfv///8HaiICQQ1NIAJBAkdxDQYgAUGEgICAeEoNBSABQYOAgIB4Rw0GDAULIAAoAggiAUGEgICAeEogAUGDgICAeEZyDQQMBQsgAC0ABEEDRw0EDAULAkACQEEDIAAoAgQiAUEHayICIAJBA08bQQJrDgIBAAULAkACQAJAIAEOBgAHAQcHAgcLIAAtAAhBA0cNBgwICyAAKAIIIgFB7f///wdqIgJBCk0gAkEDR3ENBSABRSABQfv///8HaiICQQ1NIAJBAkdxIAFBg4CAgHhHIAFBhICAgHhMcXJyDQUMCQsgACgCCCIBQfv///8HaiICQQtNIAJBAkdxIAFBg4CAgHhHIAFBhICAgHhMcXIgAUVyDQQMCAsgAC0ACEEDRw0DDAULIAAtAARBA0cNAgwDCyAALQAEQQNHDQEgACgCCCIAKAIAIQEgAEEEaigCACICKAIAIgMEQCABIAMRAwALIAIoAgQiAwRAIAEgAyACKAIIEKcECyAAQQxBBBCnBAwBCyABRQ0AIAAoAgwgAUECdEEEEKcECw8LIAAoAggiACgCACEBDAELIAAoAgwiACgCACEBCyAAQQRqKAIAIgIoAgAiAwRAIAEgAxEDAAsgAigCBCIDBEAgASADIAIoAggQpwQLIABBDEEEEKcEDwsgACgCDCABQQJ0QQQQpwQLvQgBB38gACgCACICBEAgACgCBCEDAkAgACgCCCIHBEBBACEAA0ACQCAABEAgAiEBDAELQQAhAQJAIANFDQAgAyIAQQdxIgQEQANAIABBAWshACACKALgFiECIARBAWsiBA0ACwsgA0EISQ0AA0AgAigC4BYoAuAWKALgFigC4BYoAuAWKALgFigC4BYoAuAWIQIgAEEIayIADQALCyACIQBBACEDCwJAIAAvAd4WIANLBEAgAyEGIAAhAgwBCwNAIAAoAgAiAgRAIAAvAdwWIQYgAEGQF0HgFiABG0EEEKcEIAFBAWohASACIgAvAd4WIAZNDQEMAgsLIABBkBdB4BYgARtBBBCnBEHIpcEAEK4EAAsgBkEBaiEDAkAgAUUEQCACIQAMAQsgAiADQQJ0akHgFmohBAJAIAFBB3EiA0UEQCABIQUMAQsgASEFA0AgBUEBayEFIAQoAgAiAEHgFmohBCADQQFrIgMNAAsLQQAhAyABQQhJDQADQCAEKAIAKALgFigC4BYoAuAWKALgFigC4BYoAuAWKALgFiIAQeAWaiEEIAVBCGsiBQ0ACwsgAiAGQYQCbGpBMGoiAigCACIBBEAgAigCBCABQQN0QQQQpwQLIAIoAgwiAQRAIAIoAhAgAUECdEEEEKcECyACKAIYIgEEQCACKAIcIAFBAnRBBBCnBAsgAigCKCIBBEAgAigCLCABQQN0QQQQpwQLIAIoAjQiAQRAIAIoAjggAUECdEEEEKcECyACKAJAIgEEQCACKAJEIAFBAnRBBBCnBAsgAigCUCIBBEAgAigCVCABQQN0QQQQpwQLIAIoAlwiAQRAIAIoAmAgAUECdEEEEKcECyACKAJoIgEEQCACKAJsIAFBAnRBBBCnBAsgAigCgAEiAQRAIAIoAoQBIAFBAXRBARCnBAsgAigCjAEiAQRAIAIoApABIAFBARCnBAsgAigCmAEiAQRAIAIoApwBIAFBARCnBAsgAigCpAEiAQRAIAIoAqgBIAFBAnRBBBCnBAsgAigCsAEiAQRAIAIoArQBIAFBAnRBBBCnBAsgAigCvAEiAQRAIAIoAsABIAFBA3RBBBCnBAsgAigCyAEiAQRAIAIoAswBIAFBAnRBBBCnBAsgAigC1AEiAQRAIAIoAtgBIAFBAnRBBBCnBAsgAigC6AEiAQRAIAIoAuwBIAFBARCnBAtBACECIAdBAWsiBw0ACwwBCyADRQRAIAIhAAwBCwJAIANBB3EiBEUEQCACIQAgAyEBDAELIAIhACADIQEDQCABQQFrIQEgACgC4BYhACAEQQFrIgQNAAsLIANBCEkNAANAIAAoAuAWKALgFigC4BYoAuAWKALgFigC4BYoAuAWKALgFiEAIAFBCGsiAQ0ACwtBACEBA0AgACgCACAAQZAXQeAWIAEbQQQQpwQgAUEBayEBIgANAAsLC/kHAhR/AX4CQAJAAkACQAJAIAEoAgBFBEAgAS0ADg0BIAEgAS0ADCIGQQFzOgAMIAEoAjQhAyABKAIwIQQCQCABKAIEIgJFDQAgAiADTwRAIAIgA0YNAQwHCyACIARqLAAAQb9/TA0GCwJAIAIgA0cEQAJ/IAIgBGoiBCwAACIDQQBOBEAgA0H/AXEMAQsgBC0AAUE/cSEHIANBH3EhBSAFQQZ0IAdyIANBX00NABogBC0AAkE/cSAHQQZ0ciEHIAcgBUEMdHIgA0FwSQ0AGiAFQRJ0QYCA8ABxIAQtAANBP3EgB0EGdHJyCyEDQQEhBSAGQQFxDQECQCADQYABSQ0AQQIhBSADQYAQSQ0AQQNBBCADQYCABEkbIQULIAAgAjYCBCAAQQE2AgAgACACIAVqIgA2AgggASAANgIEDwsgBkEBcUUNBQsgACACNgIIIAAgAjYCBCAAQQA2AgAPCyABKAIcIgYgASgCNCIERg0BIAEoAjAhCgJAIAQiAyAGIAEoAjwiCEEBayIQaiICTQ0AIAEoAjghDSAGIApqIREgBiAIaiEHIAYgASgCECILayESIAEoAhgiAyAGaiEOIAggA2shEyABKQMIIRYgASgCJCIPQX9GIQkgDyEFIAYhAwNAIAMgBkcNAQJAAkAgFiACIApqMQAAiKdBAXFFBEAgASAHNgIcIAchAyAJDQJBACECDAELIAsgBSALIAUgC0sbIAkbIgMgCCADIAhLGyEMIAMhAgJAAkACQANAIAIgDEYEQEEAIAUgCRshDCALIQIDQCACIAxNBEAgASAHNgIcIA9Bf0cEQCABQQA2AiQLIAAgBzYCCCAAIAY2AgQgAEEANgIADwsgAkEBayICIAhPDQUgAiAGaiIDIARPDQMgAiANai0AACADIApqLQAARg0ACyABIA42AhwgEyECIA4hAyAJRQ0FDAYLIAIgBmogBE8NAiACIBFqIRQgAiANaiACQQFqIQItAAAgFC0AAEYNAAsgAiASaiEDIAkNBEEAIQIMAwsgAyAEQcCvwgAQrQIACyAEIAMgBmoiACAAIARJGyAEQdCvwgAQrQIACyACIAhBsK/CABCtAgALIAEgAjYCJCACIQULIAMgEGoiAiAESQ0ACyAEIQMLQQAhBSADRQ0CIAMhAgNAAkAgAiAETwRAIAIgBEcNASAEIQUMBQsgAiAKaiwAAEG/f0wNACACIQUMBAsgAkEBaiICDQALDAILIABBAjYCAA8LIABBAjYCAA8LIAAgBTYCCCAAIAY2AgQgAEEBNgIAIAEgAyAFIAMgBUsbNgIcDwsgAEECNgIAIAFBAToADg8LIAQgAyACIANBmLHCABDsAwAL1wgCBn8BfiMAQTBrIgUkACABQQA6ACUgAUEANgIUIAUgAzYCGCAFIAI2AhQgBUEANgIcIAVBIGogBUEUakEEEE8CQAJAAkACQAJAAkAgBSgCIEUEQCABIAUtAChBBWoiAjoAJQJAIAJB/wFxIgMgBEH/AXFNBEAgAw0BQYCAgIB4IQMMBgsgBSAEOgAFIAUgAjoABEGBgICAeCEDDAULIAFBDGohB0EBIAJ0IQlBACECA0ACQAJAAkACQCAJIAJrQQFqIgMEQCAFQSBqIAVBFGpBICADZyIGayIIEE8gBSkDKCELAkACQCAFKAIgRQRAIAunIgRBfyAGQR9zdEF/cyIKcSIGQX8gCHRBf3MgA2siA0kNASAEIANBACAEIApLG2shBgwCCyAFKAIkIQEgBSALNwIIIAUgATYCBAwJCyAFKAIcIgNFDQIgBSADQQFrNgIcCyAGQQFrIQMgASgCFCIEIAEoAgxGBEAgB0GIgsIAELQBCyABKAIQIARBAnRqIAM2AgAgASAEQQFqIgQ2AhQgA0UEQANAIAVBIGogBUEUakECEE8gBSkDKCELIAUoAiANBCABKAIUIgMgAyALpyIGaiIESQRAIAYgBygCACADa0sEQCAHIAMgBkEEQQQQkgEgASgCFCEDCyABKAIQIgggA0ECdGohBCAGQQJPBH8gBEEAIAZBAnRBBGsQWhogAyAGaiIEQQFrIQMgCCAEQQJ0akEEawUgBAtBADYCACADQQFqIQQLIAEgBDYCFCAGQQNGDQAMBgsACyADQQBKDQMgBkUEQCACQQFqIQIMBQtBmILCAEEcQbSCwgAQ7QIAC0Gg/8EAQRdBnIDCABDtAgALQdDiwQBBGkHU48EAEO0CAAsgBSgCJCEBIAUgCzcCCCAFIAE2AgQMBAsgAiADaiECCyACIAlJDQALIAIgCUYNAkEAIQYgBygCCCIEQQJ0IQMCQAJAIARB/////wNLIANB/P///wdLcg0AIAcoAgQhCAJ/IANFBEBBBCEHQQAMAQtBheXCAC0AABpBBCEGIANBBBD1AyIHRQ0BIAQLIQYgByAIIAMQOyEDIAUgBDYCCCAFIAM2AgQgBSAGNgIADAELIAYgA0GU/sEAENcDAAsgBSAJNgIQIAUgAjYCDCAFKAIAIgNBhYCAgHhHDQQgBSgCBCEDDAMLIAUgBSkDKDcCCCAFIAUoAiQ2AgQLQYKAgIB4IQMMAgsgAS0AJEEBaiAETwRAIAUoAhwiAkEDdiACQQdxQQBHaiEDDAELIAUgBDYCBEGEgICAeCEDDAELIAUgARApIAUoAgBBhYCAgHhHDQEgAEGFgICAeDYCACAAIAM2AgQMAgsgACAFKQIINwIIIABBEGogBUEQaigCADYCACAAIAUoAgQ2AgQgACADNgIADAELIAAgBSkCADcCACAAQRBqIAVBEGooAgA2AgAgAEEIaiAFQQhqKQIANwIACyAFQTBqJAAL0QYBCn8CQAJAAkACQAJAAkACQAJAAkACQCAAKAIIIgcgACgCDCIITwRAIAAoAgQiCyABIAdqIglJDQQgCyAJayIGIAIgAiAGSxshCiAAKAIAIgUgCGohBCAFIAdqIAFqIQMgCkEFSSAHIAhrIgcgBiAGIAdLGyIMQQRPcQ0BIAwgCkEDakF8cSIBTw0CIAQgAyAKEDsaDAMLIAAoAgQiCyAIayIGIAIgAiAGSxshCSAAKAIAIgUgCGohAyABIAdqIgEgBWohBCAJQQVJIAYgCCABayIKIAYgCkkbIgFBBE9xDQYgASAJQQNqQXxxIgFJBEAgAyAEIAkQOxoMCAsgAUEATA0HIAEgBGohCSAEIQEDQCADIAEoAAA2AAAgA0EEaiEDIAFBBGoiASAJSQ0ACwwHCyAEIAMoAAA2AAAMAQsgAUEATA0AIAEgA2ohCiAEIQEDQCABIAMoAAA2AAAgAUEEaiEBIANBBGoiAyAKSQ0ACwsgAiAGTQ0FIAQgBmohBCACIAZrIgNBBE0gByAGayIBIAggASAISRsiAUEDS3ENASABIANBA2pBfHEiAUkEQCAEIAUgAxA7GgwGCyABQQBMDQUgASAFaiEBIAggC2ogCWshBANAIAQgBWogBSgAADYAACAFQQRqIgUgAUkNAAsMBQsgCwRAIAcgCGsiASAIIAkgC3AiA2siBCABIARJGyEEIAAoAgAiBSAIaiEBIAMgBWohAyACQQRNIARBA0txDQIgBCACQQNqQXxxIgRJBEAgASADIAIQOxoMBwsgBEEATA0GIAMgBGohBANAIAEgAygAADYAACABQQRqIQEgA0EEaiIDIARJDQALDAULQdDpwQAQlAMACyAEIAUoAAA2AAAMAwsgASADKAAANgAADAMLIAMgBCgAADYAAAsgAiAGTQ0AIAQgBmohAwJAIAIgBmsiBEEETSAHIAogBmsiASABIAdLGyIBQQNLcUUEQCABIARBA2pBfHEiB08NASAFIAMgBBA7GgwCCyAFIAMoAAA2AAAMAQsgB0EATA0AIAMgB2ohAQNAIAUgAygAADYAACAFQQRqIQUgA0EEaiIDIAFJDQALCyALDQBB4OnBABCUAwALIAAgAiAIaiALcDYCDAvGBgEIfwJAAkAgASAAQQNqQXxxIgMgAGsiCEkNACABIAhrIgZBBEkNACAGQQNxIQdBACEBAkAgACADRiIJDQACQCAAIANrIgVBfEsEQEEAIQMMAQtBACEDA0AgASAAIANqIgIsAABBv39KaiACQQFqLAAAQb9/SmogAkECaiwAAEG/f0pqIAJBA2osAABBv39KaiEBIANBBGoiAw0ACwsgCQ0AIAAgA2ohAgNAIAEgAiwAAEG/f0pqIQEgAkEBaiECIAVBAWoiBQ0ACwsgACAIaiEAAkAgB0UNACAAIAZBfHFqIgMsAABBv39KIQQgB0EBRg0AIAQgAywAAUG/f0pqIQQgB0ECRg0AIAQgAywAAkG/f0pqIQQLIAZBAnYhBSABIARqIQQDQCAAIQMgBUUNAkHAASAFIAVBwAFPGyIGQQNxIQcgBkECdCEIQQAhAiAFQQRPBEAgACAIQfAHcWohCSAAIQEDQCABKAIAIgBBf3NBB3YgAEEGdnJBgYKECHEgAmogASgCBCIAQX9zQQd2IABBBnZyQYGChAhxaiABKAIIIgBBf3NBB3YgAEEGdnJBgYKECHFqIAEoAgwiAEF/c0EHdiAAQQZ2ckGBgoQIcWohAiABQRBqIgEgCUcNAAsLIAUgBmshBSADIAhqIQAgAkEIdkH/gfwHcSACQf+B/AdxakGBgARsQRB2IARqIQQgB0UNAAsCfyADIAZB/AFxQQJ0aiIAKAIAIgFBf3NBB3YgAUEGdnJBgYKECHEiASAHQQFGDQAaIAEgACgCBCIBQX9zQQd2IAFBBnZyQYGChAhxaiIBIAdBAkYNABogACgCCCIAQX9zQQd2IABBBnZyQYGChAhxIAFqCyIBQQh2Qf+BHHEgAUH/gfwHcWpBgYAEbEEQdiAEag8LIAFFBEBBAA8LIAFBA3EhAwJAIAFBBEkEQAwBCyABQXxxIQUDQCAEIAAgAmoiASwAAEG/f0pqIAFBAWosAABBv39KaiABQQJqLAAAQb9/SmogAUEDaiwAAEG/f0pqIQQgBSACQQRqIgJHDQALCyADRQ0AIAAgAmohAQNAIAQgASwAAEG/f0pqIQQgAUEBaiEBIANBAWsiAw0ACwsgBAvOBgEOfyMAQRBrIgYkAEEBIQwCQCACKAIcIglBIiACKAIgIg0oAhAiDhEAAA0AAkAgAUUEQEEAIQIMAQtBACABayEPIAAhByABIQMCQAJ/AkACQANAIAMgB2ohEEEAIQICQANAIAIgB2oiCi0AACIFQf8Aa0H/AXFBoQFJIAVBIkZyIAVB3ABGcg0BIAMgAkEBaiICRw0ACyADIAhqDAQLIApBAWohBwJAIAosAAAiC0EATgRAIAtB/wFxIQMMAQsgBy0AAEE/cSEDIAtBH3EhBSAKQQJqIQcgC0FfTQRAIAVBBnQgA3IhAwwBCyAHLQAAQT9xIANBBnRyIQMgCkEDaiEHIAtBcEkEQCADIAVBDHRyIQMMAQsgBUESdEGAgPAAcSAHLQAAQT9xIANBBnRyciEDIApBBGohBwsgBkEEaiADQYGABBA5AkACQCAGLQAEQYABRg0AIAYtAA8gBi0ADmtB/wFxQQFGDQAgBCACIAhqIgVLDQECQCAERQ0AIAEgBE0EQCABIARHDQMMAQsgACAEaiwAAEG/f0wNAgsCQCAFRQ0AIAEgBU0EQCAFIA9qRQ0BDAMLIAAgCGogAmosAABBv39MDQILIAkgACAEaiAIIARrIAJqIA0oAgwiBRECAA0DAkAgBi0ABEGAAUYEQCAJIAYoAgggDhEAAEUNAQwFCyAJIAYtAA4iBCAGQQRqaiAGLQAPIARrIAURAgANBAsCf0EBIANBgAFJDQAaQQIgA0GAEEkNABpBA0EEIANBgIAESRsLIAhqIAJqIQQLAn9BASADQYABSQ0AGkECIANBgBBJDQAaQQNBBCADQYCABEkbCyAIaiIFIAJqIQggECAHayIDRQ0DDAELCyAAIAEgBCAFQYDGwgAQ7AMACwwECyACIAVqCyICIARJDQBBACEDAkAgBEUNACABIARNBEAgBCIDIAFHDQIMAQsgBCIDIABqLAAAQb9/TA0BCyACRQRAQQAhAgwCCyABIAJNBEAgAyEEIAEgAkYNAgwBCyADIQQgACACaiwAAEG/f0oNAQsgACABIAQgAkGQxsIAEOwDAAsgCSAAIANqIAIgA2sgDSgCDBECAA0AIAlBIiAOEQAAIQwLIAZBEGokACAMC8EHAQF/IwBBMGsiAiQAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIAQQFrDgwBAgMEBQYHCAkKCwwACyACIABBBGo2AhQgAkEBNgIcIAJB8KfBADYCGCACQgE3AiQgAiACQRRqrUKAgICAsDeENwMAIAIgAjYCICABKAIcIAEoAiAgAkEYahBFDAwLIAIgAEEIajYCFCACQQE2AhwgAkHwp8EANgIYIAJCATcCJCACIAJBFGqtQoCAgIDAN4Q3AwAgAiACNgIgIAEoAhwgASgCICACQRhqEEUMCwsgAiAAQQhqNgIUIAJBAjYCHCACQeC0wQA2AhggAkICNwIkIAJCsKbBgMA1NwMIIAIgAkEUaq1CgICAgNA1hDcDACACIAI2AiAgASgCHCABKAIgIAJBGGoQRQwKCyACIABBBGo2AhQgAkEBNgIcIAJB8KfBADYCGCACQgE3AiQgAiACQRRqrUKAgICA0DeENwMAIAIgAjYCICABKAIcIAEoAiAgAkEYahBFDAkLIAIgAEEEajYCFCACQQE2AhwgAkGUtcEANgIYIAJCATcCJCACIAJBFGqtQoCAgIDgN4Q3AwAgAiACNgIgIAEoAhwgASgCICACQRhqEEUMCAsgAiAAQQRqNgIUIAJBATYCHCACQby1wQA2AhggAkIBNwIkIAIgAkEUaq1CgICAgPA3hDcDACACIAI2AiAgASgCHCABKAIgIAJBGGoQRQwHCyACIABBBGo2AhQgAkEBNgIcIAJB4LXBADYCGCACQgE3AiQgAiACQRRqrUKAgICAkDWENwMAIAIgAjYCICABKAIcIAEoAiAgAkEYahBFDAYLIAEoAhxB6LXBAEExIAEoAiAoAgwRAgAMBQsgAiAAQQhqNgIUIAJBATYCHCACQci2wQA2AhggAkIBNwIkIAIgAkEUaq1CgICAgIA4hDcDACACIAI2AiAgASgCHCABKAIgIAJBGGoQRQwECyACIABBBGo2AhQgAkEBNgIcIAJBjLfBADYCGCACQgE3AiQgAiACQRRqrUKAgICAkDWENwMAIAIgAjYCICABKAIcIAEoAiAgAkEYahBFDAMLIAEoAhxBlLfBAEE9IAEoAiAoAgwRAgAMAgsgASgCHEHRt8EAQc8AIAEoAiAoAgwRAgAMAQsgAiAAQQRqNgIUIAJBAjYCHCACQYC5wQA2AhggAkIBNwIkIAIgAkEUaq1CgICAgJA2hDcDACACIAI2AiAgASgCHCABKAIgIAJBGGoQRQsgAkEwaiQAC/0GAgJ/AX4jAEEwayICJAACfwJAAkACQAJAAkACQAJAAkACQAJAAkBBAyAAKAIAQe3///8HaiIDIANBC08bQQFrDgoBAgMEBQYHCAkKAAsgASgCHEGQucEAQdgAIAEoAiAoAgwRAgAMCgsgASgCHEHoucEAQd0AIAEoAiAoAgwRAgAMCQsgAiAAQQRqNgIEIAJBATYCDCACQfCnwQA2AgggAkIBNwIUIAIgAkEEaq1CgICAgJA4hDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQRQwICyACIAA2AgQgAkEBNgIMIAJB8KfBADYCCCACQgE3AhQgAiACQQRqrUKAgICAoDeENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahBFDAcLIAIgAEEEajYCBCACQQE2AgwgAkHwp8EANgIIIAJCATcCFCACIAJBBGqtQoCAgICgOIQ3AyAgAiACQSBqNgIQIAEoAhwgASgCICACQQhqEEUMBgsgASgCHEHFusEAQTkgASgCICgCDBECAAwFCyACIABBBGo2AgQgAkECNgIMIAJBqLvBADYCCCACQgE3AhQgAiACQQRqrUKAgICA8DWENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahBFDAQLIAIgAEEEajYCACACIABBCGo2AgQgAkEDNgIMIAJB6LvBADYCCCACQgI3AhQgAkKAgICA8DUiBCACrYQ3AyggAiAEIAJBBGqthDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQRQwDCyACIABBBGo2AgQgAkECNgIMIAJB8LzBADYCCCACQgE3AhQgAiACQQRqrUKAgICAsDiENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahBFDAILIAIgAEEEajYCACACIABBCGo2AgQgAkECNgIMIAJBsL3BADYCCCACQgI3AhQgAkKAgICAwDgiBCACQQRqrYQ3AyggAiAEIAKthDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQRQwBCyACIABBBGo2AgAgAiAAQQhqNgIEIAJBAjYCDCACQfS9wQA2AgggAkICNwIUIAJCgICAgPA1IgQgAkEEaq2ENwMoIAIgBCACrYQ3AyAgAiACQSBqNgIQIAEoAhwgASgCICACQQhqEEULIAJBMGokAAuXBgEIfyMAQTBrIgEkAAJAAn8CQAJAAkAgACgCACIFBEAgACgCCCIEIAQgACgCBCIHIAQgB0sbayEIIAUhAwNAIAIgCGpFDQMgACACIARqQQFqNgIIIAJBAWohAiADIARqIANBAWohAy0AACIGQTBrQf8BcUEKSSAGQeEAa0H/AXFBBklyDQALIAZB3wBHDQIgAiAEakEBayEGAkAgBARA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IABBABAgDAELIAAQJwsgBEEQaiQAC5QDAQR/AkAgAkEQSQRAIAAhAwwBCwJAIABBACAAa0EDcSIFaiIEIABNDQAgACEDIAUEQCAFIQYDQCADIAE6AAAgA0EBaiEDIAZBAWsiBg0ACwsgBUEBa0EHSQ0AA0AgAyABOgAAIANBB2ogAToAACADQQZqIAE6AAAgA0EFaiABOgAAIANBBGogAToAACADQQNqIAE6AAAgA0ECaiABOgAAIANBAWogAToAACADQQhqIgMgBEcNAAsLIAQgAiAFayICQXxxaiIDIARLBEAgAUH/AXFBgYKECGwhBQNAIAQgBTYCACAEQQRqIgQgA0kNAAsLIAJBA3EhAgsCQCADIAIgA2oiBU8NACACQQdxIgQEQANAIAMgAToAACADQQFqIQMgBEEBayIEDQALCyACQQFrQQdJDQADQCADIAE6AAAgA0EHaiABOgAAIANBBmogAToAACADQQVqIAE6AAAgA0EEaiABOgAAIANBA2ogAToAACADQQJqIAE6AAAgA0EBaiABOgAAIANBCGoiAyAFRw0ACwsgAAudAwIGfwF+QTggAUH/AXEiASABQThPGyECAkAgACgCECIEIAAtABQiAWoiA0EASgRAIAIgA0sNAQJAIARBAEwgASACT3INAANAIARBAWsiBUEDdiEGQcAAIAFBB2oiB0F4cWshAwJAIAVBP00EQCAAIAYgAxCIASAAKAIQIQQgAC0AFCEBDAELAkAgACgCBCIFIAYgB0H4AXFBA3ZqQQdrIgZPBEAgBSAGayIFQQdLDQFBCCAFQcTewQAQqwQACyAGIAVB1N7BABCqBAALIAAgASADaiIBOgAUIAAgBCADQf8BcWsiBDYCECAAIAAoAgAgBmopAAA3AwgLIAFB/wFxIAJPDQEgBEEASg0ACwsgACABIAJrIgE6ABRCfyACrYZCf4UgACkDCCABQT9xrYiDDwsgACAEIAJrNgIQQgAPCyACIANrIQICQCADQf8BcSABSwRAIAAgAxBbIQggACgCECEEDAELIAAgASADayIBOgAUQn8gA62GQn+FIAApAwggAUE/ca2IgyEICyAAIAQgAms2AhAgCCACQT9xrYYLnAMBBX8CQEERQQAgAEGvsARPGyIBIAFBCHIiASAAQQt0IgIgAUECdEH82sIAaigCAEELdEkbIgEg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AEEEaiACKAIEIAIoAggQPUHcoMIAIAAoAgggACgCBCICGyEDQQkgACgCDCACGwshAiADIAIgARDaASAAQRBqJAALZgAjAEEwayIAJABBhOXCAC0AAARAIABBAjYCDCAAQYyhwgA2AgggAEIBNwIUIAAgATYCLCAAIABBLGqtQoCAgIAQhDcDICAAIABBIGo2AhAgAEEIakG0ocIAEKQDAAsgAEEwaiQAC2EBAX8jAEEwayICJAAgAiAANgIMIAJBAjYCFCACQZymwQA2AhAgAkIBNwIcIAIgAkEMaq1CgICAgOA0hDcDKCACIAJBKGo2AhggASgCHCABKAIgIAJBEGoQRSACQTBqJAALYQEBfyMAQTBrIgIkACACIAA2AgwgAkECNgIUIAJB5K7BADYCECACQgE3AhwgAiACQQxqrUKAgICA4DSENwMoIAIgAkEoajYCGCABKAIcIAEoAiAgAkEQahBFIAJBMGokAAthAQF/IwBBMGsiAiQAIAIgADYCDCACQQE2AhQgAkHwp8EANgIQIAJCATcCHCACIAJBDGqtQoCAgICQOIQ3AyggAiACQShqNgIYIAEoAhwgASgCICACQRBqEEUgAkEwaiQAC18BAn8CQCAAKAIAIgFB7f///wdqIgJBCk0gAkEDR3ENACABRSABQfv///8HaiICQQ1NIAJBAkdxIAFBg4CAgHhHIAFBhICAgHhMcXJyDQAgACgCBCABQQJ0QQQQpwQLC1wBA38gAC0AACIBQQNLIAFBA0dyRQRAIAAoAgQiACgCACEBIABBBGooAgAiAygCACICBEAgASACEQMACyADKAIEIgIEQCABIAIgAygCCBCnBAsgAEEMQQQQpwQLC2sBAn9BqJbAACECAkACQAJAAkAgAS0AACIDQQNrQQAgA0EEa0H/AXFBA0kbQQFrDgMAAQIDC0EAIQEMAgsgAUEBaiEBQdStwAAhAgwBCyABQQRqIQFBkK7AACECCyAAIAI2AgQgACABNgIAC2gBA38CQAJAAkACQEEDIAEoAgBB7f///wdqIgQgBEELTxtBAmsOAwABAgMLIAFBBGohAkGcm8AAIQMMAgtB2LPAACEDIAEhAgwBCyABQQRqIQJBjLXAACEDCyAAIAM2AgQgACACNgIAC2sBAn9B1LfAACECAkACQAJAAkAgAS0AACIDQQNrQQAgA0EE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AX8jAEEQayICJAAgAiAANgIMIAFB8b3AAEEWQYe+wABBAyACQQxqQay7wAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBic7AAEEbQcC8wABBAyACQQxqQay7wAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBrODAAEERQb3gwABBBCACQQxqQZzgwAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBweDAAEEWQdfgwABBAyACQQxqQfjawAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFB8fDAAEEbQZDfwABBAyACQQxqQfjawAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFB8IjBAEERQYGJwQBBBCACQQxqQeCIwQAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBhYnBAEEWQZuJwQBBAyACQQxqQcCGwQAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBhZfBAEEbQdSHwQBBAyACQQxqQcCGwQAQyQEgAkEQaiQACzwBAX8jAEEQayICJAAgAkGQksIANgIMIAIgADYCCCACQQhqQZSSwgAgAkEMakGUksIAIAFB5J/CABBrAAs4AQF/IwBBEGsiAiQAIAIgADYCDCABQeywwgBBDUH5sMIAQQQgAkEMakHcsMIAEMkBIAJBEGokAAs5AQF/IwBBEGsiAyQAIAMgATYCDCADIAA2AgggA0EIakGswsIAIANBDGpBrMLCACACQeyOwgAQawALMAEBfyMAQRBrIgIkACACQQhqIAAQ8wIgAigCCCABIAIoAgwoAhARAAAgAkEQaiQACzIBAX8gASgCFCICQRBxRQRAIAJBIHFFBEAgACABEMUBDwsgACABEPwBDwsgACABEP0BCzIBAX8gASgCFCICQRBxRQRAIAJBIHFFBEAgACABEK0EDwsgACABEIQCDwsgACABEIMCCzIBAX8gASgCFCICQRBxRQRAIAJBIHFFBEAgACABEKkDDwsgACABEIQCDwsgACABEIMCCzMBAX8jAEEQayICJAAgAiAAKAIANgIMIAFB7IfBAEEMIAJBDGpB3IfBABB/IAJBEGokAAszAQF/IwBBEGsiAiQAIAIgACgCADYCDCABQejUwQBBDCACQQxqQdjUwQAQfyACQRBqJAALLQACQCAAIAEQrANFDQAgAARAQYXlwgAtAAAaIAAgARD1AyIBRQ0BCyABDwsACzcBAX8jAEEgayIBJAAgAUEANgIYIAFBATYCDCABQdzZwgA2AgggAUIENwIQIAFBCGogABCkAwALMwEBfyAAKAIAIgFBhICAgHhMIAFBg4CAgHhHcSABRXJFBEAgACgCBCABQQJ0QQQQpwQLCzABAX8jAEEQayICJAAgAiAANgIMIAFBxJnAAEEMIAJBDGpBtJnAABB/IAJBEGokAAsvACAAQZybwAA2AgQgACABIAFBACABLQAAQQJrQf8BcSIAQQFGGyAAQQJLGzYCAAswAQF/IwBBEGsiAiQAIAIgADYCDCABQdi8wABBDCACQQxqQci8wAAQfyACQRBqJAALLwAgAEGwvsAANgIEIAAgASABQQAgAS0AAEECa0H/AXEiAEEBRhsgAEECSxs2AgALMAEBfyMAQRBrIgIkACACIAA2AgwgAUGo38AAQQwgAkEMakGY38AAEH8gAkEQaiQACy8AIABBgOHAADYCBCAAIAEgAUEAIAEtAABBAmtB/wFxIgBBAUYbIABBAksbNgIACy8AIABBxInBADYCBCAAIAEgAUEAIAEtAABBAmtB/wFxIgBBAUYbIABBAksbNgIACzABAX8jAEEQayICJAAgAiAANgIMIAFB7IfBAEEMIAJBDGpB3IfBABB/IAJBEGokAAssAQF/IwBBEGsiACQAIABBCGoiAiABQfyVwgBBCxCmAyACEK4CIABBEGokAAuEAQEDfyMAQSBrIgQkACAEQQhqIgMQ8AECf0GF5cIALQAAGkEkQQQQ9QMiAgRAIAJB5LrAADYCACACIAE2AiAgAiAANgIcIAIgAykCADcCBCACQQxqIANBCGopAgA3AgAgAkEUaiADQRBqKQIANwIAIAIMAQtBBEEkENMEAAsgBEEgaiQACzgBAX9BASEBIAAtAARFBEAgACgCACIBKAIcQY7EwgBBASABKAIgKAIMEQIAIQELIAAgAToABCABC5ABAQN/IwBBIGsiAyQAIANBCGoiAhDwAQJ/QYXlwgAtAAAaQShBBBD1AyIBBEAgAUGcgsAANgIAIAEgAikCADcCBCABIAApAgA3AhwgAUEMaiACQQhq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NgIMIABBhKLCACABKAIEIAEoAggiAC0ACCAALQAJEMEBAAsgACADNgIEIAAgAjYCACAAQeihwgAgASgCBCABKAIIIgAtAAggAC0ACRDBAQALKgAgAEH/AXFFBEBDAAAAAA8LIABBAWtB/wFxs0NFIpE9lEMAABDBkhBSCy0AIAEoAhwgAiADIAEoAiAoAgwRAgAhAiAAQQA6AAUgACACOgAEIAAgATYCAAsyAQF/IAEoAhxBvMHCAEEBIAEoAiAoAgwRAgAhAiAAQQA6AAUgACACOgAEIAAgATYCAAshAAJAIAEgAxCsAwRAIAAgASADIAIQ3wMiAA0BCwALIAALIgEBfyAAKAIAIgAgAEEfdSICcyACayAAQX9zQR92IAEQbAslACAARQRAQfiPwgBBMhDIBAALIAAgAiADIAQgBSABKAIQEQsACygAIAEgACgCAC0AAEECdCIAQeC8wgBqKAIAIABBzLzCAGooAgAQ5QMLGQEBf0GAgICAeCABayAATyACIAFpQQFGGwslACABIAAtAABBAnQiAEH8tcAAaigCACAAQey1wABqKAIAEOUDCyUAIABBnJvAADYCBCAAIAFBBGpBACABKAIAQYKAgIB4Rhs2AgALIQAgAEHwosAANgIEIAAgAUEBakEAIAEtAABBAkYbNgIACyUAIAEgAC0AAEECdCIAQZDZwABqKAIAIABBgNnAAGooAgAQ5QMLJQAgAEGwvsAANgIEIAAgAUEEakEAIAEoAgBBgoCAgHhGGzYCAAshACAAQYTGwAA2AgQgACABQQFqQQAgAS0AAEECRhs2AgALJQAgASAALQAAQQJ0IgBB+PvAAGooAgAgAEHo+8AAaigCABDlAwslACAAQYDhwAA2AgQgACABQQRqQQAgASgCAEGCgICAeEYbNgIACyEAIABBsOjAADYCBCAAIAFBAWpBACABLQAAQQJGGzYCAAshACAAQbSOwQA2AgQgACABQQFqQQAgAS0AAEECRhs2AgALJQAgAEHEicEANgIEIAAgAUEEakEAIAEoAgBBgoCAgHhGGzYCAAslACABIAAtAABBAnQiAEGMosEAaigCACAAQfyhwQBqKAIAEOUDCyMAIABFBEBB+I/CAEEyEMgEAAsgACACIAMgBCABKAIQEQcACyMAIABFBEBB+I/CAEEyEMgEAAsgACACIAMgBCAB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BBD1AyILBEACQEGF5cIALQAAGkGACEEEEPUDIghFDQJBheXCAC0AABpBgAhBBBD1AyIERQ0AQYXlwgAtAAAaQYAIQQQQ9QMiDkUNAkGF5cIALQAAGkGACEEEEPUDIgxFDQBBheXCAC0AABpBgAhBBBD1AyISRQ0CIANCADcDqAIgA0EBNgLoASADQQA6AOQBIANBADoA4gEgA0EAOgDgASADQTQ7AdwBIANBADYC2AEgAyASNgLUASADQoCAgICAIDcCzAEgAyAMNgLIASADQoCAgICAIDcDwAEgA0KAgICAwAA3A7gBIANBIzsBtAEgA0EANgKwASADIA42AqwBIANCgICAgIAgNwKkASADIAQ2AqABIANCgICAgIAgNwOYASADQoCAgIDAADcDkAEgA0EfOwGMASADQQA2AogBIAMgCDYChAEgA0KAgICAgCA3AnwgAyALNgJ4IANCgICAgIAgNwNwIANCgICAgMAANwNoIANBwAJqQgA3AwAgA0G4AmpCADcDACADQbACakIANwMAIANB/AFqQQA2AgAgA0H0AWpCADcCACADQgA3AuwBIANC1uuC7ur9ifXgADcDgAIgA0LP1tO+0ser2UI3A4gCIANCADcDkAIgA0L56tDQ58mh5OEANwOYAiADQgA3A6ACIANBADYCyAIgA0IANwPQAiADIAY2AtgCIANBADYC5AIgA0EINgKUAyADQoCAgIAQNwLcAiADQoGAgIDAADcCjAMgA0EANgKIAyADQoCAgIAQNwPoAiADQgA3A/ACIANCBDcD+AIgA0KAgICAEDcDgAMMAwsLQQRBgAhBzIDCABDXAwALQQRBgAhB3IDCABDXAwALIAdBADYCqAcgB0EANgKwByAHQQA6ANwKIAdBADYC2AogByAjNwPQCiAHKQOoByEgIAcpA7AHISMgB0HoA2oiBiADQagDEDsaIAdBCGoQSSAHICM3AyggByAgNwMgIAcgITcDGCAHIA02AgwgByAiPgIQIAcgIkIgiD4CFCAHIAU2AgggB0EwaiAGQagDEDshCCAFQQFxBEBBDCEQIAcoAtgDIhJFDQEgBygC3AMhFwNAIBJB1AFrIQQgEkEEaiEGIBIvAd4WIgNBAnQhC0F/IQUCQAJAA0AgC0UEQCADIQUMAgsgBigCACEOIAVBAWohBSAEQYQCaiEEIAtBBGsh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EwAgAEHMuMAANgIEIAAgATYCAAsTACAAQYi5wAA2AgQgACABNgIACxMAIABBxLnAADYCBCAAIAE2AgALEwAgAEGAusAANgIEIAAgATYCAAsTACAAQbC+wAA2AgQgACABNgIACxMAIABBKDYCBCAAQYjbwAA2AgALEwAgAEGA4cAANgIEIAAgATYCAAshACAAQqTFo/yfjvDjADcDCCAAQqqooLmusOaw6QA3AwALEAAgACgCACAAKAIEIAEQMAsRACAAKAIAIAAoAgQgARDVBAsiACAAQsuH6/rgqLu20AA3AwggAELEr9zF2tKv9bh/NwMACxMAIABBKDYCBCAAQcCFwQA2AgALEwAgAEHEicEANgIEIAAgATYCAAsgACAAQrz8k7Ko16DsTDcDCCAAQuuYqJm2gbKefzcDAAshACAAQriynYTMrpfUQjcDCCAAQu/Dv6KOjcrEoH83AwALIAAgAEKcnaLxgrvwoHU3AwggAELRqsqvpcqt8kA3AwALIQAgAEL7wqCWlfy/yHo3AwggAELmsfLlkYe/ybF/NwMACyIAIABC9auQ77TsvKaWfzcDCCAAQrHh7P30uYbLwgA3AwALIAAgAELNnq77nqC2sEE3AwggAELxps+Y0aSn/gE3AwALIAAgAEK3v8ue+N2SoEM3AwggAEKvuaX0x5vV+zA3AwALIQAgAEKWl7rs79nZo3Q3AwggAEKH+OXLhuPSwtQANwMACyEAIABC/O6Qyq7osdU1NwMIIABC2OvVj+a1zN2OfzcDAAshACAAQrzprN2Y1v7ui383AwggAEKk3Nqt0/nNwEU3AwALIQAgAELl6obQ6cP/7Xk3AwggAEL30OLk1cPQ6ad/NwMACyEAIABC5sHsgPKk3YtlNwMIIABChu7u8+efmIeefzcDAAshACAAQs7Is8mT6a+2pX83AwggAELt66KMv7HLkg83AwALIgAgAEKcrtGn56WAwMIANwMIIABC16rLiaf+wYLHADcDAAsiACAAQt3+weC9o+rogn83AwggAEKX2/aYrfP7zY5/NwMACyEAIABCgsDc4LCv07mnfzcDCCAAQpbk17fDtcOKAzcDAAshACAAQrvV0cb1jfDEkH83AwggAELVi9bpuKS4kXk3AwALIQAgAEKynOer2rGju98ANwMIIABCvfif/8L+hsNVNwMACyIAIABC9tzrg9PWkOr2ADcDCCAAQuamkMP/nOzgtn83AwALIQAgAEKv1ajhhPu04u0ANwMIIABCjM/Fj7KFi+lnNwMACyEAIABCoKPa7PvI3KZuNwMIIABC7fH6/5z2yOa9fzcDAAsRACABIAAoAgAgACgCBBDlAwsWAEGM5cIAIAA2AgBBiOXCAEEBNgIACyAAIABC4+DWofail51WNwMIIABC0Jamw5Le7cA3NwMACyIAIABC7bqtts2F1PXjADcDCCAAQviCmb2V7sbFuX83AwALEwAgAEHYocIANgIEIAAgATYCAAsQACABIAAoAgAgACgCBBA2CxAAIAEoAhwgASgCICAAEEULDgAgACUBIAElASACEA4LYQEBfwJAAkAgAEEEaygCACICQXhxIgNBBEEIIAJBA3EiAhsgAWpPBEAgAkEAIAMgAUEnaksbDQEgABA+DAILQf2UwgBBLkGslcIAEO0CAAtBvJXCAEEuQeyVwgAQ7QIACwsOACAAKAIAJQEQE0EARwsdAQFvIAAoAgAlASABIAIQFyEDEGkiACADJgEgAAtpAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0ECNgIMIANBmNrCADYCCCADQgI3AhQgAyADQQRqrUKAgICAEIQ3AyggAyADrUKAgICAEIQ3AyAgAyADQSBqNgIQIANBCGogAhCkAwALaQEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQbjawgA2AgggA0ICNwIUIAMgA0EEaq1CgICAgBCENwMoIAMgA61CgICAgBCENwMgIAMgA0EgajYCECADQQhqIAIQpAMAC2kBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQQI2AgwgA0Hs2sIANgIIIANCAjcCFCADIANBBGqtQoCAgIAQhDcDKCADIAOtQoCAgIAQhDcDICADIANBIGo2AhAgA0EIaiACEKQDAAsNACAAKAIAQQEgARBsCw8AQb3BwgBBKyAAEO0CAAvxAgIFfwN+IAApAwAhCSMAQSBrIgMkAEEUIQAgCSIHQugHWgRAIAchCANAIANBDGogAGoiAkEDayAIIAhCkM4AgCIHQpDOAH59pyIEQf//A3FB5ABuIgVBAXQiBkGSxMIAai0AADoAACACQQRrIAZBkcTCAGotAAA6AAAgAkEBayAEIAVB5ABsa0H//wNxQQF0IgRBksTCAGotAAA6AAAgAkECayAEQZHEwgBqLQAAOgAAIABBBGshACAIQv+s4gRWIAchCA0ACwsgB0IJVgRAIAAgA2pBC2ogB6ciAiACQf//A3FB5ABuIgJB5ABsa0H//wNxQQF0IgRBksTCAGotAAA6AAAgAEECayIAIANBDGpqIARBkcTCAGotAAA6AAAgAq0hBwsgCVBFIAdQcUUEQCAAQQFrIgAgA0EMamogB6dBAXRBHnFBksTCAGotAAA6AAALIAFBAUEBQQAgA0EMaiAAakEUIABrEDUgA0EgaiQACw4AIAFBiP3AAEEUEOUDCwwAIAAoAgAgARDZBAsLACAAKAIAIAEQfAsMACAAKAIAIAEQngELDAAgACgCACABEIYBCwwAIAAoAgAgARCXAQsLACAAKAIAIAEQZAsLACAAKAIAIAEQTgsMACAAKAIAIAEQsAELDAAgACgCACABEKIBCwwAIAAoAgAgARCRAQsLACAAKAIAIAEQQAsMACAAKAIAIAEQrQQLDAAgACgCACABEKkDCwwAIAAoAgAgARDFAQsMACAAKAIAIAEQrwQLDAAgACgCACABEIQCCwsAIAAoAgAgARBqCw0AIABBxIPCACABEEULDQAgAEHQiMIAIAEQRQsKACAAIAEgAhBFCw4AIAFBxIrCAEEFEOUDC6gDAgd/AX4gACgCACEAIwBB0ABrIgIkACACQSBqIAAgACgCACgCBBEBACACIAJByABqrUKAgICAsDuENwMoQQEhAyACQQE2AjQgAkG4jMIANgIwIAJCATcCPCACIAIpAyA3AkggAiACQShqNgI4AkAgASgCHCIHIAEoAiAiCCACQTBqEEUNACABLQAUQQRxRQRAQQAhAwwBCyACQRhqIAAgACgCACgCBBEBACACQShqrUKAgICAsDuEIQkgAigCHCEEIAIoAhghBUEAIQBBASEGA0ACQCAAQQFxBEAgBCEBIAUhAAwBCyAFIQAgBCEBA0AgAEUEQEEAIQMMBAsgAkEQaiAAIAEoAhgRAQAgAigCFCEBIAIoAhAhACAGQQFrIgYNAAsLIABBAEchAyAARQ0BIAJBCGogACABKAIYEQEAIAIoAgwhBCACKAIIIQUgAiABNgIsIAIgADYCKEEBIQAgAkEBNgI0IAJBxIzCADYCMCACQgE3AjwgAiAJNwNIIAIgAkHIAGo2AjhBACEGIAcgCCACQTBqEMQERQ0ACwsgAkHQAGokACADCxsBAW8gACgCACUBIAEQAiECEGkiACACJgEgAAsJACAAIAEQGwALKQACfyAAKAIALQAARQRAIAFB9MXCAEEFEDYMAQsgAUH5xcIAQQQQNgsLDQAgAEG8lMIAIAEQRQvOAQEGfyAAKAIAIQIjAEGAAWsiBCQAIAEoAgQhByABKAIAIQYgASgCFCIFIQACQCAFQQRxRQ0AIAVBCHIhACAGDQAgAUKBgICAoAE3AgALIAEgAEEEcjYCFEEAIQADQCAAIARqQf8AaiACQQ9xIgNBMHIgA0HXAGogA0EKSRs6AAAgAEEBayEAIAJBD0sgAkEEdiECDQALIAFBAUGPxMIAQQIgACAEakGAAWpBACAAaxA1IAEgBTYCFCABIAc2AgQgASAGNgIAIARBgAFqJAALDAAgACABKQIANwMACw0AIAFB7K3CAEECEDYLDQAgAEGAscIAIAEQRQsOACABQauwwgBBBRDlAwsOACABQbi8wgBBEhDlAwsNACAAQcy+wgAgARBFCw4AIAFBxL7CAEEFEOUDCxoAIAAgAUGU5cIAKAIAIgBB9QMgABsRAQAACw0AIABB4MPCACABEEULCgAgAiAAIAEQNgu3CQEHfwJAAkAgAiIFIAAiAyABa0sEQCABIAJqIQAgAiADaiEDIAJBEEkNAUEAIANBA3EiBmshCAJAIANBfHEiBCADTw0AIAZBAWsCQCAGRQRAIAAhAgwBCyAGIQcgACECA0AgA0EBayIDIAJBAWsiAi0AADoAACAHQQFrIgcNAAsLQQNJDQAgAkEEayECA0AgA0EBayACQQNqLQAAOgAAIANBAmsgAkECai0AADoAACADQQNrIAJBAWotAAA6AAAgA0EEayIDIAItAAA6AAAgAkEEayECIAMgBEsNAAsLIAQgBSAGayICQXxxIgVrIQNBACAFayEGAkAgACAIaiIAQQNxRQRAIAMgBE8NASABIAJqQQRrIQEDQCAEQQRrIgQgASgCADYCACABQQRrIQEgAyAESQ0ACwwBCyADIARPDQAgAEEDdCIFQRhxIQcgAEF8cSIIQQRrIQFBACAFa0EYcSEJIAgoAgAhBQNAIARBBGsiBCAFIAl0IAEoAgAiBSAHdnI2AgAgAUEEayEBIAMgBEkNAAsLIAJBA3EhBSAAIAZqIQAMAQsgBUEQTwRAAkAgA0EAIANrQQNxIgZqIgIgA00NACABIQQgBgRAIAYhAANAIAMgBC0AADoAACAEQQFqIQQgA0EBaiEDIABBAWsiAA0ACwsgBkEBa0EHSQ0AA0AgAyAELQAAOgAAIANBAWogBEEBai0AADoAACADQQJqIARBAmotAAA6AAAgA0EDaiAEQQNqLQAAOgAAIANBBGogBEEEai0AADoAACADQQVqIARBBWotAAA6AAAgA0EGaiAEQQZqLQAAOgAAIANBB2ogBEEHai0AADoAACAEQQhqIQQgA0EIaiIDIAJHDQALCyACIAUgBmsiBEF8cSIHaiEDAkAgASAGaiIAQQNxRQRAIAIgA08NASAAIQEDQCACIAEoAgA2AgAgAUEEaiEBIAJBBGoiAiADSQ0ACwwBCyACIANPDQAgAEEDdCIFQRhxIQYgAEF8cSIIQQRqIQFBACAFa0EYcSEJIAgoAgAhBQNAIAIgBSAGdiABKAIAIgUgCXRyNgIAIAFBBGohASACQQRqIgIgA0kNAAsLIARBA3EhBSAAIAdqIQELIAMgAyAFaiIATw0BIAVBB3EiBARAA0AgAyABLQAAOgAAIAFBAWohASADQQFqIQMgBEEBayIEDQALCyAFQQFrQQdJDQEDQCADIAEtAAA6AAAgA0EBaiABQQFqLQAAOgAAIANBAmogAUECai0AADoAACADQQNqIAFBA2otAAA6AAAgA0EEaiABQQRqLQAAOgAAIANBBWogAUEFai0AADoAACADQQZqIAFBBmotAAA6AAAgA0EHaiABQQdqLQAAOgAAIAFBCGohASADQQhqIgMgAEcNAAsMAQsgAyAFayICIANPDQAgBUEDcSIBBEADQCADQQFrIgMgAEEBayIALQAAOgAAIAFBAWsiAQ0ACwsgBUEBa0EDSQ0AIABBBGshAQNAIANBAWsgAUEDai0AADoAACADQQJrIAFBAmotAAA6AAAgA0EDayABQQFqLQAAOgAAIANBBGsiAyABLQAAOgAAIAFBBGshASACIANJDQALCwsJACAAQQA2AgAL3zYCHX8BfiMAQYABayIGJAAgBkEoaiAAIAAoAgAoAgQRAQAgBiAGKAIsIgI2AjQgBiAGKAIoIgQ2AjACQAJAAkACQAJAIAEiDi0AFEEEcUUEQEEBIRUgBkEBNgJgIAZBuIzCADYCXCAGQgE3AmggBiAGQTBqrUKAgICAsDuENwNAIAYgBkFAazYCZCABKAIcIAEoAiAgBkHcAGoQRQ0FIAZBIGogBigCMCAGKAI0KAIYEQEAIAYoAiAiAgRAIAYoAiQhASAOKAIcQcyMwgBBDCAOKAIgKAIMEQIADQYgBkEYaiACIAEoAhgRAQAgBkE4aq1CgICAgLA7hCEfIAYoAhhBAEchBwNAIAZBEGogAiABKAIYEQEAIAYoAhQgBigCECEIIAYgATYCPCAGIAI2AjggDigCHEHYjMIAQQEgDigCICgCDBECAA0HIAZBADoATCAGIAM2AkQgBiAHNgJAIAYgDjYCSCAGQQE2AmAgBkG4jMIANgJcIAZCATcCaCAGIB83A1AgBiAGQdAAajYCZCAGQUBrQZyLwgAgBkHcAGoQRQ0HIANBAWohAyEBIAgiAg0ACwsCQCAAKAIEIgJBA0cEQCAAQQRqIQAMAQsgACAAKAIAKAIYEQQAIgBFDQIgACgCACECCyACQQJHDQQgBkEANgJIIAZCgICAgBA3AkAgBkHoiMIANgJ8IAZBAzoAdCAGQiA3AmwgBkEANgJkIAZBADYCXCAGIAZBQGs2AnggBkHcAGohAiMAQaABayIDJAACfwJAAkACQAJAAkACfwJAAkACQAJAIAAoAgBBAWsOAgABAgsgAkHFl8IAQRIQ5QMMCQsgAC0AFEEDRwRAIAMgAEEEajYCOCADQThqIQQjAEEgayIBJAACQAJAAkACQAJAAkACQAJAIABBFGoiCC0AAEEBaw4DAgUBAAsgCEECOgAAIAQoAgAgBEEANgIARQ0CQZHlwgAtAAAhBEGR5cIAQQE6AAAgASAEOgAHIARBAUYNA0GR5cIAQQA6AAAgCEEDOgAACyABQSBqJAAMBQsgAUEANgIYIAFBATYCDCABQYSowgA2AggMAwtBmKDCABCuBAALIAFCADcCFCABQoGAgIDAADcCDCABQbCfwgA2AgggAUEHaiABQQhqEIoDAAsgAUEANgIYIAFBATYCDCABQcSowgA2AggLIAFCBDcCECABQQhqQcygwgAQpAMACwsgACgCDCEBIAIoAhRBBHEiCEUNASAAKAIIDAILIAJBsJfCAEEVEOUDDAcLIAEgACgCECIESQ0BIAEgBGshASAAKAIIIARBDGxqCyERIANBgICAgHg2AgwgA0Gol8IAKQMANwIQIAMgCEECdiIAOgAYIAMgADoALCADQQA2AiggAyACNgIcIANB6JfCADYCJCADIANBDGo2AiAgAUUNAiARIAFBDGxqIRggA0E8aiETIANBhAFqIRQDQAJAIBEoAggiAEUEQCADQQA2AmQgAyADQRxqNgJgIANBAzYCOCADQQI2AoABIANB4ABqIANBOGogA0GAAWpBACADQQAgAxAiIAMoAmAiASABKAIMQQFqNgIMRQ0BDAcLIABBLGwhGSARKAIEIRpBACEWA0AgA0EANgI0IAMgA0EcajYCMAJAIBYgGmoiD0EgaigCAEGAgICAeEYEQCADQQM2AjgMAQsgA0GAAWoiEiAPQSRqKAIAIhsgD0EoaigCACIcED1BAiEAAkAgAygCgAENACADKAKEASEJIAMoAogBIQEjAEEgayILJAAjAEHgAGsiByQAIAdBEGogCSABQfC6wgBBBhAhAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBygCEEUEQANAIAdB1ABqIAdBEGoQLCAHKAJUIgBBAUYNAAsCQAJAIABBAWsOAgQBAAsgByAHKQJYNwIIIAdBATYCBAwCCyAHQQA2AgQMAQsgB0EYaiEAIAcoAkwhAiAHKAJIIQQgBygCRCEIIAcoAkAhBSAHKAI0QX9HBEAgB0EEaiAAIAUgCCAEIAJBABBWDAELIAdBBGogACAFIAggBCACQQEQVgsgBygCBEUNAgJAIAcoAggiBEEGaiIARQ0AIAAgAU8EQCAAIAFGDQEMEQsgACAJaiwAAEG/f0wNEAsgASAJaiEKIAAgCWohAANAAkAgACAKRg0AAn8gACwAACICQQBOBEAgAkH/AXEhAiAAQQFqDAELIAAtAAFBP3EhBSACQR9xIQggAkFfTQRAIAhBBnQgBXIhAiAAQQJqDAELIAAtAAJBP3EgBUEGdHIhBSACQXBJBEAgBSAIQQx0ciECIABBA2oMAQsgCEESdEGAgPAAcSAALQADQT9xIAVBBnRyciICQYCAxABGDQEgAEEEagshACACQUBqQQdJIAJBMGtBCklyDQEMBAsLIARFBEBBACEBDAQLIAEgBE0EQCABIARGDQMMAgsgBCAJaiwAAEG/f0wNASAEIQEMAgsACyAJIAFBACAEQbS7wgAQ7AMACwJAAkAgAUEDTwRAAkACQAJAQbixwgAgCUEDENQCBEAgCS8AAEHanAFGDQEgAUEDRg0GIAkoAABB377p8gRHDQZBfCECQQQhACABQQVPDQJBBCEBDAULQQMhAEF9IQIgAUEDRgRAQQMhAQwFCyAJLAADQb9/Sg0EIAkgAUEDIAFBjLLCABDsAwALIAksAAJBv39MDQFBAiEAQX4hAgwDCyAJLAAEQb9/Sg0CIAkgAUEEIAFB7LHCABDsAwALIAkgAUECIAFB/LHCABDsAwALQQIhACABQQJHDQIgCS8AAEHanAFHBEBBAiEBDAMLQX4hAkECIQELIAAgCWoiBCABIAJqIghqIRAgCCEAIAQhAgJAA0AgAARAIABBAWshACACLAAAIAJBAWohAkEATg0BDAILCyAIRQ0AAn8gBCwAACIAQQBOBEAgAEH/AXEhACAEQQFqDAELIAQtAAFBP3EhBSAAQR9xIQIgAEFfTQRAIAJBBnQgBXIhACAEQQJqDAELIAQtAAJBP3EgBUEGdHIhBSAAQXBJBEAgBSACQQx0ciEAIARBA2oMAQsgAkESdEGAgPAAcSAELQADQT9xIAVBBnRyciEAIARBBGoLIQICQCAAQcUARgRAQQAhCgwBCyAAQYCAxABGDQFBACEKA0AgAEEwa0EJSw0CQQAhBQNAIABBMGsiDUEKTwRAIAUEQANAIAIgEEYNBgJ/IAIsAAAiAEEATgRAIABB/wFxIQAgAkEBagwBCyACLQABQT9xIQwgAEEfcSENIABBX00EQCANQQZ0IAxyIQAgAkECagwBCyACLQACQT9xIAxBBnRyIQwgAEFwSQRAIAwgDUEMdHIhACACQQNqDAELIA1BEnRBgIDwAHEgAi0AA0E/cSAMQQZ0cnIiAEGAgMQARg0HIAJBBGoLIQIgBUEBayIFDQALCyAKQQFqIQogAEHFAEcNAgwDCyAFrUIKfiIfQiCIpw0DIAIgEEYgH6ciACANaiIFIABJcg0DAn8gAiwAACIAQQBOBEAgAEH/AXEhACACQQFqDAELIAItAAFBP3EhDCAAQR9xIQ0gAEFfTQRAIA1BBnQgDHIhACACQQJqDAELIAItAAJBP3EgDEEGdHIhDCAAQXBJBEAgDCANQQx0ciEAIAJBA2oMAQsgDUESdEGAgPAAcSACLQADQT9xIAxBBnRyciEAIAJBBGoLIQIgAEGAgMQARw0ACwsMAQsgECACayEQDAgLIAFBAk0NAQsgCS8AAEHfpAFHDQEgCSwAAiICQb9/TA0DIAlBAmohCEF+IQoMBQtBAiEAQQAhCiABQQJHDQcgCS0AAEHSAEYNAQwICyAJLQAAQdIARw0CIAEhAAsgCSwAASICQb9/SgRAIAlBAWohCEF/IQogACEBDAMLIAkgAEEBIABBkLXCABDsAwALIAkgAUECIAFBoLXCABDsAwALQQMhAEEAIQogAUEDRg0EQdC0wgAgCUEDENQCDQMgCSwAAyICQb9/SgRAIAlBA2ohCEF9IQoMAQsgCSABQQMgAUGAtcIAEOwDAAsgAkHBAGtB/wFxQRlLDQEgASAKaiEKQQAhAANAIAAgCkcEQCAAIAhqIABBAWohACwAAEEATg0BDAMLCyAHQSBqQgA3AgAgB0IANwIYIAcgCjYCFCAHIAg2AhACQCAHQRBqQQAQH0UEQCAHLQAUIQUCQCAHKAIQIgJFDQAgBygCGCIAIAcvABUgB0EXai0AAEEQdHJBCHQgBXIiBU8NAiAAIAJqLQAAQcEAa0H/AXFBGk8NAiAHKAIcIQQgB0IANwIgIAcgBDYCHCAHIAA2AhggByAFNgIUIAcgAjYCECAHQRBqQQAQHw0KIActABQhBSAHKAIQIgJFDQAgBygCGCEAIAcvABUgB0EXai0AAEEQdHJBCHQgBXIhBQwCCyAFQQFxIQoMBAsMCAsCQAJAIABFDQAgACAFTwRAIAAgBUYNAQwCCyAAIAJqLAAAQb9/TA0BCyAFIABrIRAgACACaiECQQAhBAwBCyACIAUgACAFQZC2wgAQ7AMACwJAAkAgEEUEQEEAIRAMAQtBLiEFQQAhDSACLQAAQS5HDQEgAiAQaiEdIAIhAANAAn8gBcBBAEgEQCAALQABQT9xIRcgBUEfcSEMIAVB/wFxIh5B3wFNBEAgDEEGdCAXciEFIABBAmoMAgsgAC0AAkE/cSAXQQZ0ciEFIB5B8AFJBEAgBSAMQQx0ciEFIABBA2oMAgsgDEESdEGAgPAAcSAALQADQT9xIAVBBnRyciIFQYCAxABGDQMgAEEEagwBCyAFQf8BcSEFIABBAWoLIQACQCAFQd///wBxQcEAa0EaSSAFQTBrQQpJciAFQSFrQQ9Jcg0AAkAgBUE6aw4nAQEBAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAAsgBUH7AGtBA0sNAwsgACAdRg0BIAAtAAAhBQwACwALQQEhDSABIQAMBQsgASEAQQEMAwtBACEKCyABIQALQQAhCEEAIQRBACENQQELIQJBACEQCyALIBA2AhwgCyACNgIYIAsgADYCFCALIAk2AhAgCyAKNgIMIAsgCDYCCCALIAQ2AgQgCyANNgIAIAdB4ABqJAAMAgsgCSABIAAgAUGku8IAEOwDAAtBwLXCAEE9IAdB1ABqQbC1wgBBgLbCABCgAgALAkAgCygCAARAIBIgCykCADcCACASQRhqIAtBGGopAgA3AgAgEkEQaiALQRBqKQIANwIAIBJBCGogC0EIaikCADcCAAwBCyASQQI2AgALIAtBIGokACADKAKAASIAQQJGDQAgA0H4AGogFEEYaigCADYCACADQfAAaiAUQRBqKQIANwMAIANB6ABqIBRBCGopAgA3AwAgAyAUKQIANwNgCyATIAMpA2A3AgAgE0EYaiADQfgAaigCADYCACATQRBqIANB8ABqKQMANwIAIBNBCGogA0HoAGopAwA3AgAgAyAcNgJcIAMgGzYCWCADIAA2AjgLIA9BEGooAgAiAEECRwRAIAMgD0EYaikCADcChAELIAMgADYCgAEgA0EwaiADQThqIANBgAFqIA8oAgAgD0EEaigCACAPQQhqKAIAIA9BDGooAgAQIiADKAIwIgEgASgCDEEBajYCDA0HIBkgFkEsaiIWRw0ACwsgGCARQQxqIhFHDQALDAELIAQgAUHYl8IAEKoEAAsgAygCDCIAQYCAgIB4Rg0AIABFDQEgAygCECAAQQEQpwRBAAwDCyADLQAQQQNHDQAgAygCFCIAKAIAIQEgAEEEaigCACICKAIAIgQEQCABIAQRAwALIAIoAgQiBARAIAEgBCACKAIIEKcECyAAQQxBBBCnBAtBAAwBCwJAIAMoAgwiAEGAgICAeEcEQCAARQ0BIAMoAhAgAEEBEKcEQQEMAgsgAy0AEEEDRw0AIAMoAhQiACgCACEBIABBBGooAgAiAigCACIEBEAgASAEEQMACyACKAIEIgQEQCABIAQgAigCCBCnBAsgAEEMQQQQpwQLQQELIANBoAFqJAANAiAGQdgAaiAGQcgAaigCADYCACAGIAYpAkA3A1ACQAJAIA4oAhxB2YzCAEECIA4oAiAoAgwRAgANAAJAAkAgBigCWEEQTwRAQduMwgAgBigCVEEQENQCRQ0BCyAGQQA2AmwgBkEBNgJgIAZB/IzCADYCXCAGQgQ3AmQgDigCHCAOKAIgIAZB3ABqEMQERQ0BDAILIwBBQGoiCCQAIAhBATYCECAIQQA2AgwgBkHQAGoiBCgCBCEDAkACQCAEKAIIIgBBAU0EQCAAQQFHDQEMAgsgA0EBaiwAAEG/f0oNAQtBiIbCAEEqQbCHwgAQ7QIACyAIIAhBEGo2AjwgCEEBNgI4IAhBADYCMCAIIAhBDGo2AjRBACECIAhBMGoiBygCBCEBAkACQAJAIAcoAgBBAWsOAgECAAsgASgCACECDAELIAEoAgAiAUF/RwRAIAFBAWohAgwBCyMAQSBrIgAkACAAQQA2AhggAEEBNgIMIABB1MbCADYCCCAAQgQ3AhAgAEEIakHohcIAEKQDAAsgBygCDCEFIAAhAQJAAkACQCAHKAIIQQFrDgIBAgALIAUoAgAiAUF/RwRAIAFBAWohAQwCCyMAQSBrIgAkACAAQQA2AhggAEEBNgIMIABBiMfCADYCCCAAQgQ3AhAgAEEIakH4hcIAEKQDAAsgBSgCACEBCwJAIAEgAk8EQCAAIAFPDQEgASAAQbSDwgAQqwQACyACIAFBtIPCABCsBAALIAggATYCBCAIIAI2AgAgCCgCBCEBIAQgCCgCACICNgIIIAggBDYCHCAIIAE2AiAgCCAAIAFrNgIkIAhBhI3CADYCKCAIQYWNwgA2AiwgCCABIANqNgIYIAggAiADajYCFCAIQRRqIgVCgYCAgBA3AgACQCAFKAIQIgtFBEAgBSgCGCIHIAUoAhQiAWsiACAFKAIIIgIoAgAgAigCCCIEa0sEQCACIAQgABCTASACKAIIIQQLIAEgB0cEQCACKAIEIQkCQCAAQQNxIgNFBEAgASEADAELIAEhAANAIAQgCWogAC0AADoAACAEQQFqIQQgAEEBaiEAIANBAWsiAw0ACwsgBSABIAdrQXxNBH8gBCAJaiEJQQAhAQNAIAEgCWoiBSAAIAFqIgMtAAA6AAAgBUEBaiADQQFqLQAAOgAAIAVBAmogA0ECai0AADoAACAFQQNqIANBA2otAAA6AAAgAUEEaiEBIANBBGogB0cNAAsgASAEaiEEIAAgAWoFIAALNgIUCyACIAQ2AggMAQsCQCAFKAIMIgEgBSgCCCIHKAIIIgBGBEAgBSgCGCEEIAUoAhQhAwwBCyABIABrIQkgBygCBCAAaiEAIAUoAhghBCAFKAIUIQMDQCADIARGDQIgACADLQAAOgAAIAUgA0EBaiIDNgIUIAcgBygCCEEBajYCCCAAQQFqIQAgCUEBayIJDQALCwJAIAMgBEYNACAEIANrIgAgBygCACABIAtqIgJrSwRAIAcgAiAAEJMBCyAHKAIEIgkgACABaiICaiABIAlqIAsQ1gQgBSACNgIMIAIgBygCCCIJRgRAIAIhAQwBCyAHKAIEIAlqIQAgASAEaiAJayADayEJA0AgAyAERg0CIAAgAy0AADoAACAFIANBAWoiAzYCFCAHIAcoAghBAWo2AgggAEEBaiEAIAlBAWsiCQ0ACyACIQELQQAhCQJAIAQgA2siCkEASA0AIAMgBEYiEA0BQQAhAEGF5cIALQAAGkEBIQkgCkEBEPUDIgJFDQAgCkEDcSEJIAMgBGtBfE0EQCAKQXxxIREDQCAAIAJqIgQgACADaiIPLQAAOgAAIARBAWogD0EBai0AADoAACAEQQJqIA9BAmotAAA6AAAgBEEDaiAPQQNqLQAAOgAAIBEgAEEEaiIARw0ACyAAIANqIQMLIAkEQANAIAAgAmogAy0AADoAACAAQQFqIQAgA0EBaiEDIAlBAWsiCQ0ACwsgBSADNgIUAkAgAEUNACAAIAcoAgAgASALaiIEa0sEQCAHIAQgABCTAQsgBygCBCIDIAAgAWoiBGogASADaiALENYEIAUgBDYCDCAEIAcoAggiA0YNACADIAFrIQEgBygCBCADaiEDIAIhBANAIABFDQEgAyAELQAAOgAAIAcgBygCCEEBajYCCCAEQQFqIQQgA0EBaiEDIAEgAEEBayIARw0ACwsgEA0BIAIgCkEBEKcEDAELIAkgCkGAjsIAENcDAAsgCCgCJCEAAkACQAJAIAgoAhggCCgCFEcEQCAARQ0DIAgoAhwiAUEIaiEEIAgoAiAiAyABKAIIIgJHDQEMAgsgAEUNAiAIKAIcIgFBCGohBCAIKAIgIgMgASgCCCICRg0BCyABKAIEIgEgAmogASADaiAAENYECyAEIAAgAmo2AgALIAhBQGskAAsgBkEIaiEIIAYoAlQhBEEAIQMCQCAGKAJYIgciAEUNACAAIARqIQADQAJAIAAiAkEBayIALAAAIgFBAEgEQCABQT9xAn8gAkECayIALQAAIgHAIgVBQE4EQCABQR9xDAELIAVBP3ECfyACQQNrIgAtAAAiAcAiBUFATgRAIAFBD3EMAQsgBUE/cSACQQRrIgAtAABBB3FBBnRyC0EGdHILQQZ0ciEBCwJAIAFBIEYgAUEJa0EFSXINACABQYABSQ0BAkACQAJAAkAgAUEIdiIFQRZrDhsDBQUFBQUFBQUFAQUFBQUFBQUFBQUFBQUFBQACCyABQYDgAEcNBAwDCyABQf8BcUHz4cIAai0AAEECcUUNAwwCCyAFDQIgAUH/AXFB8+HCAGotAABBAXENAQwCCyABQYAtRw0BCyAAIARHDQEMAgsLIAIgBGshAwsgCCADNgIEIAggBDYCACAGKAIMIgAgB00EQCAARSAAIAdPckUEQCAAIARqLAAAQb9/TA0HCyAGIAA2AlgLIAZBATYCYCAGQbiMwgA2AlwgBkIBNwJoIAYgBkHQAGqtQoCAgIDAO4Q3A0AgBiAGQUBrNgJkIA4oAhwgDigCICAGQdwAahBFRQ0BCyAGKAJQIgBFDQYgBigCVCAAQQEQpwQMBgsgBigCUCIARQ0EIAYoAlQgAEEBEKcEDAQLIAQgDiACKAIMEQAAIRUMBAtBtIvCAEEYQaiMwgAQwwIAC0GQicIAQTcgBkE4akGAicIAQbSKwgAQoAIAC0HcisIAQTBBjIvCABDtAgALQQAhFQsgBkGAAWokACAVC7sHAgR/AX4CfyMAQSBrIgIkAAJAAkACQAJAAkACQCAALQAAQQFrDgMBAgMACyACIAAoAgQ2AgQgAkEIaiIAIAFB8Z3CAEECEKYDIABBhJ7CAEEEIAJBBGpB9J3CABBvIAJBKToAE0GYnsIAQQQgAkETakGInsIAEG9BheXCAC0AABpBFEEBEPUDIgBFDQQgAEEQakHWp8IAKAAANgAAIABBCGpBzqfCACkAADcAACAAQcanwgApAAA3AAAgAkEUNgIcIAIgADYCGCACQRQ2AhRBrJ7CAEEHIAJBFGpBnJ7CABBvEK4CIQAgAigCFCIBRQ0DIAIoAhggAUEBEKcEDAMLIAIgAC0AAToACCACQRRqIgAgASgCHEGznsIAQQQgASgCICgCDBECADoACCAAIAE2AgQgAEEAOgAJIABBADYCACACQQhqIQUjAEFAaiIBJAAgACgCACEEIAACf0EBIAAtAAgNABogACgCBCIDLQAUQQRxRQRAQQEgAygCHEH/w8IAQYnEwgAgBBtBAkEBIAQbIAMoAiAoAgwRAgANARogBSADQZSewgAoAgARAAAMAQsgBEUEQEEBIAMoAhxBisTCAEECIAMoAiAoAgwRAgANARoLIAFBAToAFyABQSBqIANBCGopAgA3AwAgAUEoaiADQRBqKQIANwMAIAFBMGogA0EYaigCADYCACABIAMpAhw3AgggAykCACEGIAFB4MPCADYCOCABIAY3AxggASABQRdqNgIQIAEgAUEIajYCNEEBIAUgAUEYakGUnsIAKAIAEQAADQAaIAEoAjRBhMTCAEECIAEoAjgoAgwRAgALOgAIIAAgBEEBajYCACABQUBrJAAgACIBLQAIIQMCQCABKAIAIgRFBEAgAyEADAELQQEhAAJAIANBAXFFBEAgBEEBRw0BIAEtAAlFDQEgASgCBCIDLQAUQQRxDQEgAygCHEGMxMIAQQEgAygCICgCDBECAEUNAQsgAUEBOgAIDAELIAEgASgCBCIAKAIcQfnAwgBBASAAKAIgKAIMEQIAIgA6AAgLIABBAXEhAAwCCyAAKAIEIQAgAkEUaiIDIAFBt57CAEEFEKYDIANBmJ7CAEEEIABBCGpBiJ7CABBvQayewgBBByAAQbyewgAQbxCuAiEADAELIAIgACgCBCIANgIUIAFB3J7CAEEGQZiewgBBBCAAQQhqQYiewgBB4p7CAEEFIAJBFGpBzJ7CABDDASEACyACQSBqJAAgAAwBC0EBQRRB8JLCABDXAwALCwgAIAAlARAICwgAIAAlARALCwgAIAAlARAPCwQAQQALAgALC43iAhAAQYCAwAALqRBkZXNjcmlwdGlvbigpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBEaXNwbGF5L1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAKAAQAGsAAACiAAAAGQAAAAMAAAAMAAAABAAAAAQAAAADAAAADAAAAAQAAAAFAAAABAAAAKQAEAAGAAAABwAAAAgAAAAGAAAACQAAAAoAAAAoAAAABAAAAAsAAAAKAAAAKAAAAAQAAAAMAAAACwAAAOAAEAANAAAADgAAAA8AAAANAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlOiBpbnZhbGlkIE9uY2Ugc3RhdGU4ARAAPAAAAC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvc3RkL3NyYy9zeXMvc3luYy9vbmNlL25vX3RocmVhZHMucnN8ARAAfAAAADUAAAASAAAAZm9yZ2UtaW50ZXJuYWwtcnMvc3JjL3NvcnQucnMAAAAIAhAAHQAAAB0AAAAdAAAARXhwZWN0ZWQgIGFjdGl2ZSBzcGxhdHMgYnV0IGdvdCA4AhAACQAAAEECEAAXAAAACAIQAB0AAAA3AAAAFQAAAAgCEAAdAAAAXwAAAB0AAAAIAhAAHQAAAHcAAAAdAAAACAIQAB0AAAB3AAAAFQAAAAgCEAAdAAAAaAAAABQAAABmb3JnZS1pbnRlcm5hbC1ycy9zcmMvbGliLnJzuAIQABwAAAATAAAAPQAAALgCEAAcAAAAJAAAACAAAABudW1TcGxhdHNwYWNrZWRTcGxhdHMAAAAYAAAABAAAAAQAAAAZAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZQC4AhAAHAAAADAAAABXAAAAuAIQABwAAAAvAAAAYwAAAAEAAAAAAAAAGgAAALgCEAAcAAAAOwAAAD8AAAAbAAAAHAAAAC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvc3RkL3NyYy90aHJlYWQvbG9jYWwucnOMAxAAcAAAABQBAAAZAAAAjAMQAHAAAAATAgAAJgAAAC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzABwEEABrAAAAogAAABkAAAAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzAAAAmAQQAG0AAAAqAgAAEQAAAGZvcmdlLWludGVybmFsLXJzL3NyYy9saWIucnMYBRAAHAAAAFUAAAAtAAAAAQAAAAAAAAAYBRAAHAAAAEcAAAA7AAAAHQAAAAQAAAAEAAAAGQAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAGAUQABwAAABFAAAAWAAAABgFEAAcAAAAZwAAADMAAAAYBRAAHAAAAHIAAAAtAAAAGAUQABwAAACKAAAAKAAAAGRlc2NyaXB0aW9uKCkgaXMgZGVwcmVjYXRlZDsgdXNlIERpc3BsYXkeAAAADAAAAAQAAAAEAAAAHgAAAAwAAAAEAAAABQAAAAQAAAAABhAAHwAAAAcAAAAgAAAABgAAACEAAABmb3JnZS1pbnRlcm5hbC1ycy9zcmMvcmF5Y2FzdC5yczwGEAAgAAAAIQAAABcAAAA8BhAAIAAAAG4AAAAXAAAAPAYQACAAAAB0AAAAHAAAADwGEAAgAAAAdgAAABwAAAA8BhAAIAAAAHsAAAAgAAAAd2xnL3NyYy93bGcwL2RlY29kZS5ycwAArAYQABYAAAA5AAAAGgAAAKwGEAAWAAAAOgAAABoAAACsBhAAFgAAADsAAAAaAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZawGEAAWAAAAPAAAABIAAACsBhAAFgAAAEMAAAAaAAAArAYQABYAAABEAAAAGgAAAKwGEAAWAAAARQAAABoAAACsBhAAFgAAAHUAAAAPAAAArAYQABYAAAB3AAAADwAAAKwGEAAWAAAAfAAAABoAAACsBhAAFgAAAH0AAAAaAAAArAYQABYAAAB+AAAAGgAAAKwGEAAWAAAAfwAAABoAAAAiAAAABAAAAAQAAAAjAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZXdsZy9zcmMvd2xnMC9tb2QucnMAAPcHEAATAAAASAAAACcAAAD3BxAAEwAAAJwAAAAnAEG0kMAAC/ZsAQEAAQEBAQEBAAAAAAAAAAEBAQABAQEAAgAAAAAAAAABAQEAAQEBAVVuc3VwcG9ydGVkIFdMRyB2ZXJzaW9uAFwIEAAXAAAASW52YWxpZCBXTEcgc2lnbmF0dXJlAAAAfAgQABUAAAD3BxAAEwAAAPgAAAAnAAAAV2xnMEhlYWRlcmNlbnRlcl9zY2FsZWNlbnRlcl9vZmZzZXRsbl9zY2FsZV9taW5sbl9zY2FsZV9tYXhudW1fc3BsYXRzbWF4X3NoX29yZGVybnVtX3NoX3NwbGF0cwAAtggQAAwAAADCCBAADQAAAM8IEAAMAAAA2wgQAAwAAADnCBAACgAAAPEIEAAMAAAA/QgQAA0AAAAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwBECRAAawAAAKIAAAAZAAAAVW5zdXBwb3J0ZWQgV0xHICFzZXR0aW5ncy5lbmFibGVfc3BsaXRfZGltcwDACRAAKwAAAHdsZy9zcmMvd2xnMC9kZWNvZGUucnMAAPQJEAAWAAAAnQAAACAAAABVbnN1cHBvcnRlZCBXTEcgIXNldHRpbmdzLmVuYWJsZV9zcGxpdF9jZW50ZXJfYnl0ZXMAHAoQADMAAAD0CRAAFgAAAKAAAAAmAAAA9AkQABYAAADYAAAAKAAAAEludmFsaWQgV0xHIGRhdGEgc2l6ZQAAAHgKEAAVAAAA9AkQABYAAADhAAAAHAAAAPQJEAAWAAAA4gAAABwAAAD0CRAAFgAAAOMAAAAcAAAA9AkQABYAAADcAAAAHAAAAGRlc2NyaXB0aW9uKCkgaXMgZGVwcmVjYXRlZDsgdXNlIERpc3BsYXlSYXdSTEVDb21wcmVzc2VkUmVzZXJ2ZWQkAAAACAAAAAQAAAAlAAAAJAAAAAgAAAAEAAAAJgAAACUAAAAYCxAAJwAAACgAAAApAAAAKgAAACsAAAAsAAAAIAAAAAgAAAAtAAAALAAAACAAAAAIAAAALgAAAC0AAABUCxAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAADAAAAAQAAAA1AAAANAAAAAwAAAAEAAAANgAAADUAAACQCxAANwAAADgAAAA5AAAAOgAAACsAAAAAAAAACAAAAAQAAAA7AAAAAAAAAAgAAAAEAAAAPAAAADsAAADMCxAANwAAAD0AAAA5AAAAPgAAACsAAAAAAAAABAAAAAQAAAA/AAAAAAAAAAQAAAAEAAAAQAAAAFRvb01hbnlCaXRzbnVtX3JlcXVlc3RlZF9iaXRzbGltaXQAAAAAAAAEAAAABAAAAEEAAABOb3RFbm91Z2hSZW1haW5pbmdCaXRzcmVxdWVzdGVkcmVtYWluaW5nQWNjTG9nSXNaZXJvAAAAAAEAAAABAAAAQgAAAEFjY0xvZ1Rvb0JpZ2dvdG1heAAAAAAAAAQAAAAEAAAAQwAAAEdldEJpdHNFcnJvcgAAAAAEAAAABAAAAEQAAAAAAAAABAAAAAQAAABFAAAAUHJvYmFiaWxpdHlDb3VudGVyTWlzbWF0Y2hleHBlY3RlZF9zdW1zeW1ib2xfcHJvYmFiaWxpdGllc1Rvb01hbnlTeW1ib2xzAAAAAAQAAAAEAAAARgAAAEJsb2NrU2l6ZVRvb0xhcmdlc2l6ZUludmFsaWRCbG9ja3R5cGVOdW1iZXJudW1UYWJsZUlzVW5pbml0aWFsaXplZAAAAAAAAAwAAAAEAAAARwAAAAAAAAAMAAAABAAAAEgAAABHAAAAjA0QADcAAABJAAAAOQAAAEoAAAArAAAAAAAAAAQAAAAEAAAASwAAAFdpbmRvd1Rvb0JpZ1dpbmRvd1Rvb1NtYWxsAAAAAAAABAAAAAQAAABMAAAARnJhbWVEZXNjcmlwdG9yRXJyb3JEaWN0SWRUb29TbWFsbGV4cGVjdGVkTWlzbWF0Y2hlZEZyYW1lU2l6ZUZyYW1lU2l6ZUlzWmVyb0ludmFsaWRGcmFtZVNpemVOb3RFbm91Z2hCeXRlc0luRGljdGlvbmFyeW5lZWRPZmZzZXRUb29CaWdvZmZzZXRidWZfbGVuAAAAAAAEAAAABAAAAE0AAABSZWFkRnJhbWVIZWFkZXJFcnJvcgAAAAAEAAAABAAAAE4AAABGcmFtZUhlYWRlckVycm9yV2luZG93U2l6ZVRvb0JpZwAAAAAEAAAABAAAAE8AAABEaWN0aW9uYXJ5RGVjb2RlRXJyb3IAAAAAAAAABAAAAAQAAABQAAAARmFpbGVkVG9SZWFkQmxvY2tIZWFkZXIAAAAAAAQAAAAEAAAAUQAAAEZhaWxlZFRvUmVhZEJsb2NrQm9keQAAAAAAAAAEAAAABAAAAFIAAABGYWlsZWRUb1JlYWRDaGVja3N1bU5vdFlldEluaXRpYWxpemVkRmFpbGVkVG9Jbml0aWFsaXplRmFpbGVkVG9EcmFpbkRlY29kZWJ1ZmZlckZhaWxlZFRvU2tpcEZyYW1lVGFyZ2V0VG9vU21hbGxEaWN0Tm90UHJvdmlkZWRkaWN0X2lkAAAAAAAAAAQAAAAEAAAAUwAAAEZTRURlY29kZXJFcnJvcgAAAAAABAAAAAQAAABUAAAARlNFVGFibGVFcnJvclNvdXJjZUlzRW1wdHlOb3RFbm91Z2hCeXRlc0ZvcldlaWdodHNnb3RfYnl0ZXNleHBlY3RlZF9ieXRlcwAAAAAAAAAEAAAABAAAAFUAAABFeHRyYVBhZGRpbmdza2lwcGVkX2JpdHNUb29NYW55V2VpZ2h0c01pc3NpbmdXZWlnaHRzTGVmdG92ZXJJc05vdEFQb3dlck9mMk5vdEVub3VnaEJ5dGVzVG9EZWNvbXByZXNzV2VpZ2h0c2hhdmVGU0VUYWJsZVVzZWRUb29NYW55Qnl0ZXN1c2VkYXZhaWxhYmxlX2J5dGVzTm90RW5vdWdoQnl0ZXNJblNvdXJjZVdlaWdodEJpZ2dlclRoYW5NYXhOdW1CaXRzTWF4Qml0c1Rvb0hpZ2gAAAAAAQAAAAEAAABWAAAAAAAAAAEAAAABAAAAVwAAAFYAAABgERAAWAAAAFkAAABaAAAAWwAAAFwAAABVbnN1cHBvcnRlZE9mZnNldG9mZnNldF9jb2RlWmVyb09mZnNldE5vdEVub3VnaEJ5dGVzRm9yTnVtU2VxdWVuY2VzAAAAAAAEAAAABAAAAF0AAABFeHRyYUJpdHNiaXRzX3JlbWFpbmluZ01pc3NpbmdDb21wcmVzc2lvbk1vZGVNaXNzaW5nQnl0ZUZvclJsZUxsVGFibGVNaXNzaW5nQnl0ZUZvclJsZU9mVGFibGVNaXNzaW5nQnl0ZUZvclJsZU1sVGFibGUAAABeAAAADAAAAAQAAABfAAAAXgAAAAwAAAAEAAAAYAAAAF8AAABoEhAAYQAAAGIAAAA5AAAAYwAAACsAAAAAAAAAEAAAAAgAAABkAAAAAAAAABAAAAAIAAAAZQAAAGQAAACkEhAAZgAAAGcAAAAxAAAAaAAAADMAAABpAAAAGAAAAAQAAABqAAAAaQAAABgAAAAEAAAAawAAAGoAAADgEhAAbAAAAG0AAAA5AAAAbgAAACsAAABvAAAACAAAAAQAAABwAAAAbwAAAAgAAAAEAAAAcQAAAHAAAAAcExAAcgAAAHMAAAA5AAAAdAAAACsAAAB1AAAAGAAAAAQAAAB2AAAAdQAAABgAAAAEAAAAdwAAAHYAAABYExAAeAAAAHkAAAA5AAAAegAAACsAAAAAAAAADAAAAAQAAAB7AAAAAAAAAAwAAAAEAAAAfAAAAHsAAACUExAAfQAAAH4AAAA5AAAAfwAAACsAAACAAAAAFAAAAAQAAACBAAAAgAAAABQAAAAEAAAAggAAAIEAAADQExAAgwAAAIQAAAA5AAAAhQAAACsAAABSZWFkRXJyb3JGb3VuZFJlc2VydmVkQmxvY2sAAAAAAAQAAAAEAAAAhgAAAEJsb2NrVHlwZUVycm9yAAAAAAAABAAAAAQAAACHAAAAQmxvY2tTaXplRXJyb3JCbG9ja0NvbnRlbnRSZWFkRXJyb3JNYWxmb3JtZWRTZWN0aW9uSGVhZGVyZXhwZWN0ZWRfbGVucmVtYWluaW5nX2J5dGVzAAAAAAQAAAAEAAAAiAAAAERlY29tcHJlc3NMaXRlcmFsc0Vycm9yAAAAAAAEAAAABAAAAIkAAABMaXRlcmFsc1NlY3Rpb25QYXJzZUVycm9yAAAAAAAAAAQAAAAEAAAAigAAAFNlcXVlbmNlc0hlYWRlclBhcnNlRXJyb3IAAAAAAAAABAAAAAQAAACLAAAARGVjb2RlU2VxdWVuY2VFcnJvcgAAAAAABAAAAAQAAACMAAAARXhlY3V0ZVNlcXVlbmNlc0Vycm9ySW52YWxpZEZyYW1lQ29udGVudFNpemVGbGFnTWFnaWNOdW1iZXJSZWFkRXJyb3JCYWRNYWdpY051bWJlckZyYW1lRGVzY3JpcHRvclJlYWRFcnJvckludmFsaWRGcmFtZURlc2NyaXB0b3JXaW5kb3dEZXNjcmlwdG9yUmVhZEVycm9yRGljdGlvbmFyeUlkUmVhZEVycm9yRnJhbWVDb250ZW50U2l6ZVJlYWRFcnJvclNraXBGcmFtZW1hZ2ljX251bWJlcmxlbmd0aAAAAAAAAAQAAAAEAAAAjQAAAEJhZE1hZ2ljTnVtAAAAAAAEAAAABAAAAI4AAABIdWZmbWFuVGFibGVFcnJvcgAAAAAAAAAEAAAABAAAAI8AAABEZWNvZGVidWZmZXJFcnJvck5vdEVub3VnaEJ5dGVzRm9yU2VxdWVuY2V3YW50ZWQAAAAAAQAAAAEAAACQAAAAAAAAAAEAAAABAAAAkQAAAJAAAADEFhAAWAAAAJIAAABaAAAAWwAAAFwAAAAAAAAABAAAAAQAAACTAAAAAAAAAAQAAAAEAAAAlAAAAJMAAAAAFxAANwAAAJUAAAA5AAAASgAAACsAAACWAAAAFAAAAAQAAACXAAAAlgAAABQAAAAEAAAAmAAAAJcAAAA8FxAAmQAAAJoAAAA5AAAAmwAAACsAAAAAAAAADAAAAAQAAACcAAAAAAAAAAwAAAAEAAAAnQAAAJwAAAB4FxAAngAAAJ8AAAA5AAAAoAAAACsAAAAAAAAACAAAAAQAAAChAAAAAAAAAAgAAAAEAAAAogAAAKEAAAC0FxAANwAAAKMAAAA5AAAASgAAACsAAACkAAAAFAAAAAQAAAClAAAApAAAABQAAAAEAAAApgAAAKUAAADwFxAApwAAAKgAAAA5AAAAqQAAACsAAAAAAAAADAAAAAQAAACqAAAAAAAAAAwAAAAEAAAAqwAAAKoAAAAsGBAArAAAAK0AAAA5AAAArgAAACsAAABEZWNvZGVyU3RhdGVJc0ZhaWxlZEV4cGVjdGVkSGVhZGVyT2ZQcmV2aW91c0Jsb2NrAAAAAAAAAAEAAAABAAAArwAAAHN0ZXBzb3VyY2UAAAAAAAAEAAAABAAAALAAAABEZWNvbXByZXNzQmxvY2tFcnJvck1pc3NpbmdDb21wcmVzc2VkU2l6ZU1pc3NpbmdOdW1TdHJlYW1zAAAAAAAABAAAAAQAAACxAAAASHVmZm1hbkRlY29kZXJFcnJvclVuaW5pdGlhbGl6ZWRIdWZmbWFuVGFibGVNaXNzaW5nQnl0ZXNGb3JKdW1wSGVhZGVyTWlzc2luZ0J5dGVzRm9yTGl0ZXJhbHNuZWVkZWQAAAAAAAAEAAAABAAAALIAAABCaXRzdHJlYW1SZWFkTWlzbWF0Y2hyZWFkX3RpbERlY29kZWRMaXRlcmFsQ291bnRNaXNtYXRjaGRlY29kZWQAswAAABQAAAAEAAAAtAAAALMAAAAUAAAABAAAALUAAAC0AAAAyBkQALYAAAC3AAAAOQAAALgAAAArAAAAAAAAAAwAAAAEAAAAuQAAAAAAAAAMAAAABAAAALoAAAC5AAAABBoQADcAAAC7AAAAOQAAAEoAAAArAAAAvAAAABgAAAAEAAAAvQAAALwAAAAYAAAABAAAAL4AAAC9AAAAQBoQAL8AAADAAAAAOQAAAMEAAAArAAAAAAAAAAwAAAAEAAAAwgAAAAAAAAAMAAAABAAAAMMAAADCAAAAfBoQAMQAAADFAAAAOQAAAMYAAAArAAAASWxsZWdhbExpdGVyYWxTZWN0aW9uVHlwZU5vdEVub3VnaEJ5dGVzbmVlZF9hdF9sZWFzdAMAAAADAAAACgAAAAgAAAAACxAAAwsQAAYLEAAQCxAAZGVzY3JpcHRpb24oKSBpcyBkZXByZWNhdGVkOyB1c2UgRGlzcGxheVJhd1JMRUNvbXByZXNzZWRSZXNlcnZlZMcAAAAgAAAACAAAAC0AAADHAAAAIAAAAAgAAADIAAAALQAAAEwbEADJAAAAMAAAAMoAAAAyAAAAywAAAAAAAAAIAAAABAAAADsAAAAAAAAACAAAAAQAAAA8AAAAOwAAAIgbEADMAAAAPQAAAM0AAAA+AAAAzgAAAM8AAAAIAAAABAAAACUAAADPAAAACAAAAAQAAAAmAAAAJQAAAMQbEAAnAAAAKAAAACkAAAAqAAAAzgAAANAAAAAMAAAABAAAADUAAADQAAAADAAAAAQAAAA2AAAANQAAAAAcEADMAAAAOAAAAM0AAAA6AAAAzgAAANEAAABAAAAACAAAANIAAADRAAAAQAAAAAgAAADTAAAA0gAAADwcEADUAAAA1QAAANYAAADUAAAA1wAAANgAAAAoAAAABAAAANkAAADYAAAAKAAAAAQAAADaAAAA2QAAAHgcEADbAAAA3AAAAN0AAADbAAAA3gAAAN8AAAAkAAAABAAAANkAAADfAAAAJAAAAAQAAADaAAAA2QAAALQcEADbAAAA4AAAAN0AAADbAAAA3gAAAOEAAAAkAAAABAAAANkAAADhAAAAJAAAAAQAAADaAAAA2QAAAPAcEADbAAAA4gAAAN0AAADbAAAA3gAAAOMAAADkAAAA5QAAAOYAAADnAAAA6AAAAOkAAADqAAAA6wAAAOwAAADtAAAA7gAAAO8AAADpAAAA8AAAAPEAAADyAAAA8wAAAPQAAADvAAAA6QAAAPUAAAD2AAAA9wAAAPgAAAD5AAAA+gAAAOkAAAAAAAAABAAAAAQAAAD7AAAAAAAAAAQAAAAEAAAAQAAAAFRvb01hbnlCaXRzbnVtX3JlcXVlc3RlZF9iaXRzbGltaXQAAAAAAAAEAAAABAAAAEEAAABOb3RFbm91Z2hSZW1haW5pbmdCaXRzcmVxdWVzdGVkcmVtYWluaW5nQWNjTG9nSXNaZXJvAAAAAAEAAAABAAAA/AAAAEFjY0xvZ1Rvb0JpZ2dvdG1heAAAAAAAAAQAAAAEAAAAQwAAAEdldEJpdHNFcnJvcgAAAAAEAAAABAAAAP0AAAAAAAAABAAAAAQAAABFAAAAUHJvYmFiaWxpdHlDb3VudGVyTWlzbWF0Y2hleHBlY3RlZF9zdW1zeW1ib2xfcHJvYmFiaWxpdGllc1Rvb01hbnlTeW1ib2xzAAAAAAQAAAAEAAAARgAAAEJsb2NrU2l6ZVRvb0xhcmdlc2l6ZUludmFsaWRCbG9ja3R5cGVOdW1iZXJudW1UYWJsZUlzVW5pbml0aWFsaXplZAAAAAAAAAwAAAAEAAAARwAAAAAAAAAMAAAABAAAAP4AAABHAAAAIB8QAMwAAABJAAAAzQAAAEoAAADOAAAAAAAAAAQAAAAEAAAASwAAAFdpbmRvd1Rvb0JpZ1dpbmRvd1Rvb1NtYWxsAAAAAAAABAAAAAQAAABMAAAARnJhbWVEZXNjcmlwdG9yRXJyb3JEaWN0SWRUb29TbWFsbGV4cGVjdGVkTWlzbWF0Y2hlZEZyYW1lU2l6ZUZyYW1lU2l6ZUlzWmVyb0ludmFsaWRGcmFtZVNpemVOb3RFbm91Z2hCeXRlc0luRGljdGlvbmFyeW5lZWRPZmZzZXRUb29CaWdvZmZzZXRidWZfbGVuAAAAAAAEAAAABAAAAE0AAABSZWFkRnJhbWVIZWFkZXJFcnJvcgAAAAAEAAAABAAAAE4AAABGcmFtZUhlYWRlckVycm9yV2luZG93U2l6ZVRvb0JpZwAAAAAEAAAABAAAAE8AAABEaWN0aW9uYXJ5RGVjb2RlRXJyb3IAAAAAAAAABAAAAAQAAABQAAAARmFpbGVkVG9SZWFkQmxvY2tIZWFkZXIAAAAAAAQAAAAEAAAAUQAAAEZhaWxlZFRvUmVhZEJsb2NrQm9keQAAAAAAAAAEAAAABAAAAFIAAABGYWlsZWRUb1JlYWRDaGVja3N1bU5vdFlldEluaXRpYWxpemVkRmFpbGVkVG9Jbml0aWFsaXplRmFpbGVkVG9EcmFpbkRlY29kZWJ1ZmZlckZhaWxlZFRvU2tpcEZyYW1lVGFyZ2V0VG9vU21hbGxEaWN0Tm90UHJvdmlkZWRkaWN0X2lkAAAAAAAAAAQAAAAEAAAAUwAAAEZTRURlY29kZXJFcnJvcgAAAAAABAAAAAQAAABUAAAARlNFVGFibGVFcnJvclNvdXJjZUlzRW1wdHlOb3RFbm91Z2hCeXRlc0ZvcldlaWdodHNnb3RfYnl0ZXNleHBlY3RlZF9ieXRlcwAAAAAAAAAEAAAABAAAAFUAAABFeHRyYVBhZGRpbmdza2lwcGVkX2JpdHNUb29NYW55V2VpZ2h0c01pc3NpbmdXZWlnaHRzTGVmdG92ZXJJc05vdEFQb3dlck9mMk5vdEVub3VnaEJ5dGVzVG9EZWNvbXByZXNzV2VpZ2h0c2hhdmVGU0VUYWJsZVVzZWRUb29NYW55Qnl0ZXN1c2VkYXZhaWxhYmxlX2J5dGVzTm90RW5vdWdoQnl0ZXNJblNvdXJjZVdlaWdodEJpZ2dlclRoYW5NYXhOdW1CaXRzTWF4Qml0c1Rvb0hpZ2gAAAAAAQAAAAEAAABWAAAAAAAAAAEAAAABAAAA/wAAAFYAAAD0IhAAAAEAAFkAAAABAQAAWwAAAAIBAABVbnN1cHBvcnRlZE9mZnNldG9mZnNldF9jb2RlWmVyb09mZnNldE5vdEVub3VnaEJ5dGVzRm9yTnVtU2VxdWVuY2VzAAAAAAAEAAAABAAAAF0AAABFeHRyYUJpdHNiaXRzX3JlbWFpbmluZ01pc3NpbmdDb21wcmVzc2lvbk1vZGVNaXNzaW5nQnl0ZUZvclJsZUxsVGFibGVNaXNz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bEVuY29kaW5nSW52YWxpZENoYXJFbmNvZGluZwAAAAAAAAAEAAAABAAAAEEAAABJbnZhbGlkVGFnRW5jb2RpbmdEZXNlcmlhbGl6ZUFueU5vdFN1cHBvcnRlZFNpemVMaW1pdFNlcXVlbmNlTXVzdEhhdmVMZW5ndGgAAAAAAAQAAAAEAAAANQEAAEN1c3RvbU5vbmVTb21lUmF3UkxFQ29tcHJlc3NlZFJlc2VydmVkAAAAAAAABAAAAAQAAAA2AQAAVG9vTWFueUJpdHNudW1fcmVxdWVzdGVkX2JpdHNsaW1pdE5vdEVub3VnaFJlbWFpbmluZ0JpdHNyZXF1ZXN0ZWRyZW1haW5pbmdBY2NMb2dJc1plcm8AAAAAAAABAAAAAQAAADcBAABBY2NMb2dUb29CaWdnb3RtYXgAAAAAAAAEAAAABAAAAEMAAABHZXRCaXRzRXJyb3IAAAAABAAAAAQAAAA4AQAAAAAAAAQAAAAEAAAARQAAAFByb2JhYmlsaXR5Q291bnRlck1pc21hdGNoZXhwZWN0ZWRfc3Vtc3ltYm9sX3Byb2JhYmlsaXRpZXNUb29NYW55U3ltYm9scwAAAAAEAAAABAAAAEYAAABCbG9ja1NpemVUb29MYXJnZXNpemVJbnZhbGlkQmxvY2t0eXBlTnVtYmVybnVtVGFibGVJc1VuaW5pdGlhbGl6ZWQAAAAAAAAMAAAABAAAAEcAAAAAAAAADAAAAAQAAAA5AQAARwAAAHAwEAA6AQAASQAAADsBAABKAAAAPAEAAAAAAAAEAAAABAAAAEsAAABXaW5kb3dUb29CaWdXaW5kb3dUb29TbWFsbAAAAAAAAAQAAAAEAAAATAAAAEZyYW1lRGVzY3JpcHRvckVycm9yRGljdElkVG9vU21hbGxleHBlY3RlZE1pc21hdGNoZWRGcmFtZVNpemVGcmFtZVNpemVJc1plcm9JbnZhbGlkRnJhbWVTaXplTm90RW5vdWdoQnl0ZXNJbkRpY3Rpb25hcnluZWVkT2Zmc2V0VG9vQmlnb2Zmc2V0YnVmX2xlbgAAAAAABAAAAAQAAABNAAAAUmVhZEZyYW1lSGVhZGVyRXJyb3IAAAAABAAAAAQAAABOAAAARnJhbWVIZWFkZXJFcnJvcldpbmRvd1NpemVUb29CaWcAAAAABAAAAAQAAABPAAAARGljdGlvbmFyeURlY29kZUVycm9yAAAAAAAAAAQAAAAEAAAAUAAAAEZhaWxlZFRvUmVhZEJsb2NrSGVhZGVyAAAAAAAEAAAABAAAAFEAAABGYWlsZWRUb1JlYWRCbG9ja0JvZHlGYWlsZWRUb1JlYWRDaGVja3N1bU5vdFlldEluaXRpYWxpemVkRmFpbGVkVG9Jbml0aWFsaXplRmFpbGVkVG9EcmFpbkRlY29kZWJ1ZmZlckZhaWxlZFRvU2tpcEZyYW1lVGFyZ2V0VG9vU21hbGxEaWN0Tm90UHJvdmlkZWRkaWN0X2lkAAAAAAAABAAAAAQAAABTAAAARlNFRGVjb2RlckVycm9yAAAAAAAEAAAABAAAAFQAAABGU0VUYWJsZUVycm9yU291cmNlSXNFbXB0eU5vdEVub3VnaEJ5dGVzRm9yV2VpZ2h0c2dvdF9ieXRlc2V4cGVjdGVkX2J5dGVzRXh0cmFQYWRkaW5nc2tpcHBlZF9iaXRzVG9vTWFueVdlaWdodHNNaXNzaW5nV2VpZ2h0c0xlZnRvdmVySXNOb3RBUG93ZXJPZjJOb3RFbm91Z2hCeXRlc1RvRGVjb21wcmVzc1dlaWdodHNoYXZlRlNFVGFibGVVc2VkVG9vTWFueUJ5dGVzdXNlZGF2YWlsYWJsZV9ieXRlc05vdEVub3VnaEJ5dGVzSW5Tb3VyY2VXZWlnaHRCaWdnZXJUaGFuTWF4TnVtQml0c01heEJpdHNUb29IaWdoAAAAAAAAAAEAAAABAAAAVgAAAAAAAAABAAAAAQAAAD0BAABWAAAAIDQQAD4BAABZAAAAPwEAAFsAAABAAQAAVW5zdXBwb3J0ZWRPZmZzZXRvZmZzZXRfY29kZVplcm9PZmZzZXROb3RFbm91Z2hCeXRlc0Zvck51bVNlcXVlbmNlcwAAAAAABAAAAAQAAABdAAAARXh0cmFCaXRzYml0c19yZW1haW5pbmdNaXNzaW5nQ29tcHJlc3Npb25Nb2RlTWlzc2luZ0J5dGVGb3JSbGVMbFRhYmxlTWlzc2luZ0J5dGVGb3JSbGVPZlRhYmxlTWlzc2luZ0J5dGVGb3JSbGVNbFRhYmxlAAAAQQEAAAwAAAAEAAAAXwAAAEEBAAAMAAAABAAAAEIBAABfAAAAKDUQAEMBAABiAAAAOwEAAGMAAAA8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YWxzbmVlZGVkAAAAAAAABAAAAAQAAABjAQAAQml0c3RyZWFtUmVhZE1pc21hdGNocmVhZF90aWxEZWNvZGVkTGl0ZXJhbENvdW50TWlzbWF0Y2hkZWNvZGVkAGQBAAAUAAAABAAAALQAAABkAQAAFAAAAAQAAABlAQAAtAAAAMQ8EABmAQAAtwAAADsBAAC4AAAAPAEAAAAAAAAMAAAABAAAALkAAAAAAAAADAAAAAQAAABnAQAAuQAAAAA9EAA6AQAAuwAAADsBAABKAAAAPAEAAGgBAAAYAAAABAAAAL0AAABoAQAAGAAAAAQAAABpAQAAvQAAADw9EABqAQAAwAAAADsBAADBAAAAPAEAAAAAAAAMAAAABAAAAMIAAAAAAAAADAAAAAQAAABrAQAAwgAAAHg9EABsAQAAxQAAADsBAADGAAAAPAEAAElsbGVnYWxMaXRlcmFsU2VjdGlvblR5cGVOb3RFbm91Z2hCeXRlc25lZWRfYXRfbGVhc3QDAAAAAwAAAAoAAAAIAAAA8i4QAPUuEAD4LhAAAi8QAC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnMAAAAIPhAAbQAAACoCAAARAAAAYW4gYXJyYXkgb2YgbGVuZ3RoIDQAAAAAAAAAAAEAAABtAQBBtP3AAAv1KAEAAABtAQAAAAAAAAgAAAAEAAAAbgEAAHN0cnVjdCBXbGcwSGVhZGVyIHdpdGggNyBlbGVtZW50cwAAAMw+EAAhAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogaW52YWxpZCBPbmNlIHN0YXRl+D4QADwAAAAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L3N0ZC9zcmMvc3lzL3N5bmMvb25jZS9ub190aHJlYWRzLnJzPD8QAHwAAAA1AAAAEgAAAGZhaWxlZCB0byBmaWxsIHdob2xlIGJ1ZmZlcgDIPxAAGwAAACUAAAACAAAA5D8QAC9Vc2Vycy9keWxhbi8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3J1enN0ZC0wLjguMC9zcmMvZGVjb2RpbmcvYmxvY2tfZGVjb2Rlci5yc0J1ZyBpbiB0aGlzIGxpYnJhcnkA+D8QAGwAAACYAAAAFgAAAFdyb25nIG51bWJlciBvZiBsaXRlcmFsczogLCBTaG91bGQgaGF2ZSBiZWVuOiAAAIhAEAAaAAAAokAQABQAAAD4PxAAbAAAAK0AAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogYnl0ZXNfdXNlZF9pbl9saXRlcmFsc19zZWN0aW9uID09IHVwcGVyX2xpbWl0X2Zvcl9saXRlcmFscyBhcyB1MzIA+D8QAGwAAACzAAAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IHUzMjo6ZnJvbShieXRlc19pbl9saXRlcmFsc19oZWFkZXIpICsgYnl0ZXNfdXNlZF9pbl9saXRlcmFsc19zZWN0aW9uICsKICAgICAgICAgICAgdTMyOjpmcm9tKGJ5dGVzX2luX3NlcXVlbmNlX2hlYWRlcikgKyByYXcubGVuKCkgYXMgdTMyID09CiAgICBoZWFkZXIuY29udGVudF9zaXplAAD4PxAAbAAAAMEAAAAJAAAA+D8QAGwAAAC6AAAAFwAAAPg/EABsAAAAiwAAABcAAABIb3cgZGlkIHlvdSBldmVuIGdldCB0aGlzLiBUaGUgZGVjb2RlciBzaG91bGQgZXJyb3Igb3V0IGlmIGl0IGRldGVjdHMgYSByZXNlcnZlZC10eXBlIGJsb2NrAPg/EABsAAAAcAAAABEAAABmYWlsZWQgdG8gZmlsbCB3aG9sZSBidWZmZXIAkEIQABsAAAAlAAAAAgAAAKxCEABkZXNjcmlwdGlvbigpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBEaXNwbGF5AAAAAAQAAAAEAAAAbwEAAAAAAAAEAAAABAAAAHABAABVdGY4RXJyb3J2YWxpZF91cF90b2Vycm9yX2xlblJhd1JMRUNvbXByZXNzZWRSZXNlcnZlZAAAAAAAAAAEAAAABAAAAEAAAABUb29NYW55Qml0c251bV9yZXF1ZXN0ZWRfYml0c2xpbWl0AAAAAAAABAAAAAQAAABBAAAATm90RW5vdWdoUmVtYWluaW5nQml0c3JlcXVlc3RlZHJlbWFpbmluZ0FjY0xvZ0lzWmVybwAAAAABAAAAAQAAAHEBAABBY2NMb2dUb29CaWdnb3RtYXgAAAAAAAAEAAAABAAAAEMAAABHZXRCaXRzRXJyb3IAAAAABAAAAAQAAAByAQAAAAAAAAQAAAAEAAAARQAAAFByb2JhYmlsaXR5Q291bnRlck1pc21hdGNoZXhwZWN0ZWRfc3Vtc3ltYm9sX3Byb2JhYmlsaXRpZXNUb29NYW55U3ltYm9scwAAAAAEAAAABAAAAEYAAABCbG9ja1NpemVUb29MYXJnZXNpemVJbnZhbGlkQmxvY2t0eXBlTnVtYmVybnVtVGFibGVJc1VuaW5pdGlhbGl6ZWQAAAAAAAAMAAAABAAAAEcAAAAAAAAADAAAAAQAAABzAQAARwAAALREEABKAAAASQAAAHQBAABKAAAAdQEAAAAAAAAEAAAABAAAAEsAAABXaW5kb3dUb29CaWdXaW5kb3dUb29TbWFsbAAAAAAAAAQAAAAEAAAATAAAAEZyYW1lRGVzY3JpcHRvckVycm9yRGljdElkVG9vU21hbGxleHBlY3RlZE1pc21hdGNoZWRGcmFtZVNpemVGcmFtZVNpemVJc1plcm9JbnZhbGlkRnJhbWVTaXplTm90RW5vdWdoQnl0ZXNJbkRpY3Rpb25hcnluZWVkT2Zmc2V0VG9vQmlnb2Zmc2V0YnVmX2xlbgAAAAAABAAAAAQAAABTAAAARlNFRGVjb2RlckVycm9yAAAAAAAEAAAABAAAAFQAAABGU0VUYWJsZUVycm9yU291cmNlSXNFbXB0eU5vdEVub3VnaEJ5dGVzRm9yV2VpZ2h0c2dvdF9ieXRlc2V4cGVjdGVkX2J5dGVzAAAAAAAAAAQAAAAEAAAAVQAAAEV4dHJhUGFkZGluZ3NraXBwZWRfYml0c1Rvb01hbnlXZWlnaHRzTWlzc2luZ1dlaWdodHNMZWZ0b3ZlcklzTm90QVBvd2VyT2YyTm90RW5vdWdoQnl0ZXNUb0RlY29tcHJlc3NXZWlnaHRzaGF2ZUZTRVRhYmxlVXNlZFRvb01hbnlCeXRlc3VzZWRhdmFpbGFibGVfYnl0ZXNOb3RFbm91Z2hCeXRlc0luU291cmNlV2VpZ2h0QmlnZ2VyVGhhbk1heE51bUJpdHNNYXhCaXRzVG9vSGlnaAAAAAABAAAAAQAAAFYAAAAAAAAAAQAAAAEAAAB2AQAAVgAAACRHEABbAAAAWQAAAHcBAABbAAAAeAEAAFVuc3VwcG9ydGVkT2Zmc2V0b2Zmc2V0X2NvZGVaZXJvT2Zmc2V0Tm90RW5vdWdoQnl0ZXNGb3JOdW1TZXF1ZW5jZXMAAAAAAAQAAAAEAAAAXQAAAEV4dHJhQml0c2JpdHNfcmVtYWluaW5nTWlzc2luZ0NvbXByZXNzaW9uTW9kZU1pc3NpbmdCeXRlRm9yUmxlTGxUYWJsZU1pc3NpbmdCeXRlRm9yUmxlT2ZUYWJsZU1pc3NpbmdCeXRlRm9yUmxlTWxUYWJsZQAAAHkBAAAMAAAABAAAAF8AAAB5AQAADAAAAAQAAAB6AQAAXwAAACxIEAB7AQAAYgAAAHQBAABjAAAAdQEAAAAAAAAQAAAACAAAAGQAAAAAAAAAEAAAAAgAAAB8AQAAZAAAAGhIEAB9AQAAZwAAAH4BAABoAAAAfwEAAIABAAAYAAAABAAAAGoAAACAAQAAGAAAAAQAAACBAQAAagAAAKRIEACCAQAAbQAAAHQBAABuAAAAdQEAAIMBAAAIAAAABAAAAHAAAACDAQAACAAAAAQAAACEAQAAcAAAAOBIEACFAQAAcwAAAHQBAAB0AAAAdQEAAIYBAAAYAAAABAAAAHYAAACGAQAAGAAAAAQAAACHAQAAdgAAABxJEACIAQAAeQAAAHQBAAB6AAAAdQEAAIkBAAAIAAAABAAAACUAAACJAQAACAAAAAQAAAAmAAAAJQAAAFhJEAAnAAAAKAAAACkAAAAqAAAAdQEAAAAAAAAMAAAABAAAAHsAAAAAAAAADAAAAAQAAACKAQAAewAAAJRJEACLAQAAfgAAAHQBAAB/AAAAdQEAAIwBAAAUAAAABAAAAIEAAACMAQAAFAAAAAQAAACNAQAAgQAAANBJEACOAQAAhAAAAHQBAACFAAAAdQEAAAAAAAAEAAAABAAAAFIAAABSZWFkRXJyb3JGb3VuZFJlc2VydmVkQmxvY2sAAAAAAAQAAAAEAAAAhgAAAEJsb2NrVHlwZUVycm9yAAAAAAAABAAAAAQAAACHAAAAQmxvY2tTaXplRXJyb3JCbG9ja0NvbnRlbnRSZWFkRXJyb3JNYWxmb3JtZWRTZWN0aW9uSGVhZGVyZXhwZWN0ZWRfbGVucmVtYWluaW5nX2J5dGVzAAAAAAQAAAAEAAAAiAAAAERlY29tcHJlc3NMaXRlcmFsc0Vycm9yAAAAAAAEAAAABAAAAIkAAABMaXRlcmFsc1NlY3Rpb25QYXJzZUVycm9yAAAAAAAAAAQAAAAEAAAAigAAAFNlcXVlbmNlc0hlYWRlclBhcnNlRXJyb3IAAAAAAAAABAAAAAQAAACLAAAARGVjb2RlU2VxdWVuY2VFcnJvcgAAAAAABAAAAAQAAACMAAAARXhlY3V0ZVNlcXVlbmNlc0Vycm9ySW52YWxpZEZyYW1lQ29udGVudFNpemVGbGFnTWFnaWNOdW1iZXJSZWFkRXJyb3JCYWRNYWdpY051bWJlckZyYW1lRGVzY3JpcHRvclJlYWRFcnJvckludmFsaWRGcmFtZURlc2NyaXB0b3JXaW5kb3dEZXNjcmlwdG9yUmVhZEVycm9yRGljdGlvbmFyeUlkUmVhZEVycm9yRnJhbWVDb250ZW50U2l6ZVJlYWRFcnJvclNraXBGcmFtZW1hZ2ljX251bWJlcmxlbmd0aAAAAAAAAAQAAAAEAAAAjQAAAEJhZE1hZ2ljTnVtAAAAAAAEAAAABAAAAI4AAABIdWZmbWFuVGFibGVFcnJvcgAAAAAAAAAEAAAABAAAAI8AAABEZWNvZGVidWZmZXJFcnJvck5vdEVub3VnaEJ5dGVzRm9yU2VxdWVuY2V3YW50ZWQAAAAAAQAAAAEAAACQAAAAAAAAAAEAAAABAAAAjwEAAJAAAADUTBAAWwAAAJIAAAB3AQAAWwAAAHgBAAAAAAAABAAAAAQAAACTAAAAAAAAAAQAAAAEAAAAkAEAAJMAAAAQTRAASgAAAJUAAAB0AQAASgAAAHUBAACRAQAAFAAAAAQAAACXAAAAkQEAABQAAAAEAAAAkgEAAJcAAABMTRAAkwEAAJoAAAB0AQAAmwAAAHUBAAAAAAAADAAAAAQAAACcAAAAAAAAAAwAAAAEAAAAlAEAAJwAAACITRAAlQEAAJ8AAAB0AQAAoAAAAHUBAAAAAAAACAAAAAQAAAChAAAAAAAAAAgAAAAEAAAAlgEAAKEAAADETRAASgAAAKMAAAB0AQAASgAAAHUBAACXAQAAFAAAAAQAAAClAAAAlwEAABQAAAAEAAAAmAEAAKUAAAAAThAAmQEAAKgAAAB0AQAAqQAAAHUBAAAAAAAADAAAAAQAAACqAAAAAAAAAAwAAAAEAAAAmgEAAKoAAAA8ThAAmwEAAK0AAAB0AQAArgAAAHUBAABEZWNvZGVyU3RhdGVJc0ZhaWxlZEV4cGVjdGVkSGVhZGVyT2ZQcmV2aW91c0Jsb2NrAAAAAAAAAAEAAAABAAAAnAEAAHN0ZXBzb3VyY2UAAAAAAAAEAAAABAAAALAAAABEZWNvbXByZXNzQmxvY2tFcnJvck1pc3NpbmdDb21wcmVzc2VkU2l6ZU1pc3NpbmdOdW1TdHJlYW1zAAAAAAAABAAAAAQAAACxAAAASHVmZm1hbkRlY29kZXJFcnJvclVuaW5pdGlhbGl6ZWRIdWZmbWFuVGFibGVNaXNzaW5nQnl0ZXNGb3JKdW1wSGVhZGVyTWlzc2luZ0J5dGVzRm9yTGl0ZXJhbHNuZWVkZWQAAAAAAAAEAAAABAAAAJ0BAABCaXRzdHJlYW1SZWFkTWlzbWF0Y2hyZWFkX3RpbERlY29kZWRMaXRlcmFsQ291bnRNaXNtYXRjaGRlY29kZWQAngEAABQAAAAEAAAAtAAAAJ4BAAAUAAAABAAAAJ8BAAC0AAAA2E8QAKABAAC3AAAAdAEAALgAAAB1AQAAAAAAAAwAAAAEAAAAuQAAAAAAAAAMAAAABAAAAKEBAAC5AAAAFFAQAEoAAAC7AAAAdAEAAEoAAAB1AQAAogEAABgAAAAEAAAAvQAAAKIBAAAYAAAABAAAAKMBAAC9AAAAUFAQAKQBAADAAAAAdAEAAMEAAAB1AQAAAAAAAAwAAAAEAAAAwgAAAAAAAAAMAAAABAAAAKUBAADCAAAAjFAQAMYAAADFAAAAdAEAAMYAAAB1AQAASWxsZWdhbExpdGVyYWxTZWN0aW9uVHlwZU5vdEVub3VnaEJ5dGVzbmVlZF9hdF9sZWFzdAMAAAADAAAACgAAAAgAAAAlQxAAKEMQACtDEAA1QxAAL1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9zdGQvc3JjL2lvL21vZC5ycwAAHFEQAGoAAACyAQAAMQAAAGFzc2VydGlvbiBmYWlsZWQ6IGZpbGxlZCA8PSBzZWxmLmJ1Zi5pbml0L1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9jb3JlL3NyYy9pby9ib3Jyb3dlZF9idWYucnMAAADBURAAdAAAAB0BAAAJAAAAL1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYnRyZWUvbmF2aWdhdGUucnNIUhAAgAAAAFgCAAAwAAAASW52YWxpZCBGcmFtZV9Db250ZW50X1NpemVfRmxhZzsgSXM6ICwgU2hvdWxkIGJlIG9uZSBvZjogMCwgMSwgMiwgMwDYUhAAJQAAAP1SEAAeAEG0psEAC8piwAMAAHdpbmRvd19zaXplIGJpZ2dlciB0aGFuIGFsbG93ZWQgbWF4aW11bS4gSXM6ICwgU2hvdWxkIGJlIGxvd2VyIHRoYW46IAAAADhTEAAtAAAAZVMQABgAAAAABAAAAAAAAHdpbmRvd19zaXplIHNtYWxsZXIgdGhhbiBhbGxvd2VkIG1pbmltdW0uIElzOiAsIFNob3VsZCBiZSBncmVhdGVyIHRoYW46IJhTEAAuAAAAxlMQABoAAAABAAAAAAAAAE5vdCBlbm91Z2ggYnl0ZXMgaW4gZGljdF9pZC4gSXM6ICwgU2hvdWxkIGJlOiAAAPhTEAAhAAAAGVQQAA0AAABmcmFtZV9jb250ZW50X3NpemUgZG9lcyBub3QgaGF2ZSB0aGUgcmlnaHQgbGVuZ3RoLiBJczogADhUEAA3AAAAGVQQAA0AAABmcmFtZV9jb250ZW50X3NpemUgd2FzIHplcm9JbnZhbGlkIGZyYW1lX2NvbnRlbnRfc2l6ZS4gSXM6ICwgU2hvdWxkIGJlIG9uZSBvZiAxLCAyLCA0LCA4IGJ5dGVzAACbVBAAIAAAALtUEAAjAAAARXJyb3Igd2hpbGUgcmVhZGluZyBtYWdpYyBudW1iZXI6IAAA8FQQACIAAABSZWFkIHdyb25nIG1hZ2ljIG51bWJlcjogMHgAHFUQABsAAABFcnJvciB3aGlsZSByZWFkaW5nIGZyYW1lIGRlc2NyaXB0b3I6IAAAQFUQACYAAABFcnJvciB3aGlsZSByZWFkaW5nIHdpbmRvdyBkZXNjcmlwdG9yOiAAcFUQACcAAABFcnJvciB3aGlsZSByZWFkaW5nIGRpY3Rpb25hcnkgaWQ6IACgVRAAIwAAAEVycm9yIHdoaWxlIHJlYWRpbmcgZnJhbWUgY29udGVudCBzaXplOiDMVRAAKAAAAFNraXBwYWJsZUZyYW1lIGVuY291bnRlcmVkIHdpdGggTWFnaWNOdW1iZXIgMHggYW5kIGxlbmd0aCAgYnl0ZXP8VRAALgAAACpWEAAMAAAANlYQAAYAAABFcnJvciB3aGlsZSByZWFkaW5nIHRoZSBibG9jayBoZWFkZXJSZXNlcnZlZCBibG9jayBvY2N1cmVkLiBUaGlzIGlzIGNvbnNpZGVyZWQgY29ycnVwdGlvbiBieSB0aGUgZG9jdW1lbnRhdGlvbkVycm9yIGdldHRpbmcgYmxvY2sgdHlwZTogwlYQABoAAABFcnJvciBnZXR0aW5nIGJsb2NrIGNvbnRlbnQgc2l6ZTogAADkVhAAIgAAAEludmFsaWQgQmxvY2t0eXBlIG51bWJlci4gSXM6ICBTaG91bGQgYmUgb25lIG9mOiAwLCAxLCAyLCAzICgzIGlzIHJlc2VydmVkIHRob3VnaAAAABBXEAAeAAAALlcQADMAAAAAAAIAQmxvY2tzaXplIHdhcyBiaWdnZXIgdGhhbiB0aGUgYWJzb2x1dGUgbWF4aW11bSAgKDEyOGtiKS4gSXM6IAAAAHhXEAAvAAAAp1cQAA4AAABFcnJvciB3aGlsZSByZWFkaW5nIHRoZSBibG9jayBjb250ZW50OiAAyFcQACcAAABNYWxmb3JtZWQgc2VjdGlvbiBoZWFkZXIuIFNheXMgbGl0ZXJhbHMgd291bGQgYmUgdGhpcyBsb25nOiAgYnV0IHRoZXJlIGFyZSBvbmx5ICBieXRlcyBsZWZ0APhXEAA8AAAANFgQABQAAABIWBAACwAAAENhbid0IGRlY29kZSBuZXh0IGJsb2NrIGlmIGZhaWxlZCBhbG9uZyB0aGUgd2F5LiBSZXN1bHRzIHdpbGwgYmUgbm9uc2Vuc2VDYW4ndCBkZWNvZGUgbmV4dCBibG9jayBib2R5LCB3aGlsZSBleHBlY3RpbmcgdG8gZGVjb2RlIHRoZSBoZWFkZXIgb2YgdGhlIHByZXZpb3VzIGJsb2NrLiBSZXN1bHRzIHdpbGwgYmUgbm9uc2Vuc2VFcnJvciB3aGlsZSByZWFkaW5nIGJ5dGVzIGZvciA6IAAnWRAAHgAAAEVZEAACAAAATmVlZCAgYnl0ZXMgZnJvbSB0aGUgZGljdGlvbmFyeSBidXQgaXQgaXMgb25seSAgYnl0ZXMgbG9uZwAAWFkQAAUAAABdWRAAKgAAAIdZEAALAAAAb2Zmc2V0OiAgYmlnZ2VyIHRoYW4gYnVmZmVyOiAAAACsWRAACAAAALRZEAAVAAAAQmFkIG1hZ2ljX251bSBhdCBzdGFydCBvZiB0aGUgZGljdGlvbmFyeTsgR290OiAsIEV4cGVjdGVkOiAA3FkQAC8AAAALWhAADAAAADekMOxTcGVjaWZpZWQgd2luZG93X3NpemUgaXMgdG9vIGJpZzsgUmVxdWVzdGVkOiAsIE1heDogLFoQAC0AAABZWhAABwAAAEZhaWxlZCB0byBwYXJzZS9kZWNvZGUgYmxvY2sgYm9keTogAHBaEAAjAAAARmFpbGVkIHRvIHBhcnNlIGJsb2NrIGhlYWRlcjogAACcWhAAHgAAAEZhaWxlZCB0byByZWFkIGNoZWNrc3VtOiAAAADEWhAAGQAAAERlY29kZXIgbXVzdCBpbml0aWFsaXplZCBvciByZXNldCBiZWZvcmUgdXNpbmcgaXREZWNvZGVyIGVuY291bnRlcmVkIGVycm9yIHdoaWxlIGluaXRpYWxpemluZzogABlbEAAuAAAARGVjb2RlciBlbmNvdW50ZXJlZCBlcnJvciB3aGlsZSBkcmFpbmluZyB0aGUgZGVjb2RlYnVmZmVyOiAAUFsQADsAAABGYWlsZWQgdG8gc2tpcCBieXRlcyBmb3IgdGhlIGxlbmd0aCBnaXZlbiBpbiB0aGUgZnJhbWUgaGVhZGVyVGFyZ2V0IG11c3QgaGF2ZSBhdCBsZWFzdCBhcyBtYW55IGJ5dGVzIGFzIHRoZSBjb250ZW50c2l6ZSBvZiB0aGUgZnJhbWUgcmVwb3J0c0ZyYW1lIGhlYWRlciBzcGVjaWZpZWQgZGljdGlvbmFyeSBpZCAweCB0aGF0IHdhc250IHByb3ZpZGVkIGJ5IGFkZF9kaWN0KCkgb3IgcmVzZXRfd2l0aF9kaWN0KCkAACBcEAAnAAAAR1wQADcAAABjb21wcmVzc2VkIHNpemUgd2FzIG5vbmUgZXZlbiB0aG91Z2ggaXQgbXVzdCBiZSBzZXQgdG8gc29tZXRoaW5nIGZvciBjb21wcmVzc2VkIGxpdGVyYWxzbnVtX3N0cmVhbXMgd2FzIG5vbmUgZXZlbiB0aG91Z2ggaXQgbXVzdCBiZSBzZXQgdG8gc29tZXRoaW5nICgxIG9yIDQpIGZvciBjb21wcmVzc2VkIGxpdGVyYWxzVHJpZWQgdG8gcmV1c2UgaHVmZm1hbiB0YWJsZSBidXQgaXQgd2FzIG5ldmVyIGluaXRpYWxpemVkTmVlZCA2IGJ5dGVzIHRvIGRlY29kZSBqdW1wIGhlYWRlciwgZ290IAAAfl0QACgAAAA2VhAABgAAAE5lZWQgYXQgbGVhc3QgIGJ5dGVzIHRvIGRlY29kZSBsaXRlcmFscy4gSGF2ZTogALhdEAAOAAAAxl0QACEAAAA2VhAABgAAAFBhZGRpbmcgYXQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2Vfc2VjdGlvbiB3YXMgbW9yZSB0aGFuIGEgYnl0ZSBsb25nOiAgYml0cy4gUHJvYmFibHkgY2F1c2VkIGJ5IGRhdGEgY29ycnVwdGlvbgAAXhAARgAAAEZeEAApAAAAQml0c3RyZWFtIHdhcyByZWFkIHRpbGw6ICwgc2hvdWxkIGhhdmUgYmVlbjogAAAAgF4QABkAAACZXhAAFAAAAERpZCBub3QgZGVjb2RlIGVub3VnaCBsaXRlcmFsczogLCBTaG91bGQgaGF2ZSBiZWVuOiDAXhAAIAAAAOBeEAAUAAAAU2VxdWVuY2Ugd2FudHMgdG8gY29weSB1cCB0byBieXRlIC4gQnl0ZXMgaW4gbGl0ZXJhbHNidWZmZXI6IAAAAARfEAAiAAAAJl8QABsAAABJbGxlZ2FsIG9mZnNldDogMCBmb3VuZERvIG5vdCBzdXBwb3J0IG9mZnNldHMgYmlnZ2VyIHRoYW4gMTw8MzI7IGdvdDogAABrXxAALwAAAFJlYWQgYW4gb2Zmc2V0ID09IDAuIFRoYXQgaXMgYW4gaWxsZWdhbCB2YWx1ZSBmb3Igb2Zmc2V0c0J5dGVzdHJlYW0gZGlkIG5vdCBjb250YWluIGVub3VnaCBieXRlcyB0byBkZWNvZGUgbnVtX3NlcXVlbmNlc2NvbXByZXNzaW9uIG1vZGVzIGFyZSBub25lIGJ1dCB0aGV5IG11c3QgYmUgc2V0IHRvIHNvbWV0aGluZ05lZWQgYSBieXRlIHRvIHJlYWQgZm9yIFJMRSBsbCB0YWJsZU5lZWQgYSBieXRlIHRvIHJlYWQgZm9yIFJMRSBvZiB0YWJsZU5lZWQgYSBieXRlIHRvIHJlYWQgZm9yIFJMRSBtbCB0YWJsZUlsbGVnYWwgbGl0ZXJhbHNzZWN0aW9udHlwZS4gSXM6ICwgbXVzdCBiZSBpbjogMCwgMSwgMiwgMwAAAMRgEAAhAAAA5WAQABgAAABOb3QgZW5vdWdoIGJ5dGUgdG8gcGFyc2UgdGhlIGxpdGVyYWxzIHNlY3Rpb24gaGVhZGVyLiBIYXZlOiAsIE5lZWQ6IBBhEAA8AAAATGEQAAgAAABzb3VyY2UgbXVzdCBoYXZlIGF0IGxlYXN0ICBieXRlcyB0byBwYXJzZSBoZWFkZXI7IGdvdCAAAGRhEAAaAAAAfmEQABwAAAA2VhAABgAAAEFjY2xvZyBtdXN0IGJlIGF0IGxlYXN0IDFGb3VuZCBGU0UgYWNjX2xvZzogIGJpZ2dlciB0aGFuIGFsbG93ZWQgbWF4aW11bSBpbiB0aGlzIGNhc2U6IADNYRAAEwAAAOBhEAArAAAAVGhlIGNvdW50ZXIgKCkgZXhjZWVkZWQgdGhlIGV4cGVjdGVkIHN1bTogLiBUaGlzIG1lYW5zIGFuIGVycm9yIG9yIGNvcnJ1cHRlZCBkYXRhIAogHGIQAA0AAAApYhAAHQAAAEZiEAAqAAAAVGhlcmUgYXJlIHRvbyBtYW55IHN5bWJvbHMgaW4gdGhpcyBkaXN0cmlidXRpb246IC4gTWF4OiAyNTYAiGIQADEAAAC5YhAACgAAAFRyaWVkIHRvIHVzZSBhbiB1bmluaXRpYWxpemVkIHRhYmxlIVNvdXJjZSBuZWVkcyB0byBoYXZlIGF0IGxlYXN0IG9uZSBieXRlSGVhZGVyIHNheXMgdGhlcmUgc2hvdWxkIGJlICBieXRlcyBmb3IgdGhlIHdlaWdodHMgYnV0IHRoZXJlIGFyZSBvbmx5ICBieXRlcyBpbiB0aGUgc3RyZWFtHmMQABwAAAA6YxAAKgAAAGRjEAAUAAAATW9yZSB0aGFuIDI1NSB3ZWlnaHRzIGRlY29kZWQgKGdvdCAgd2VpZ2h0cykuIFN0cmVhbSBpcyBwcm9iYWJseSBjb3JydXB0ZWQAAJBjEAAjAAAAs2MQACcAAABDYW4ndCBidWlsZCBodWZmbWFuIHRhYmxlIHdpdGhvdXQgYW55IHdlaWdodHNMZWZ0b3ZlciBtdXN0IGJlIHBvd2VyIG9mIHR3byBidXQgaXM6IAAZZBAAJgAAAE5vdCBlbm91Z2ggYnl0ZXMgaW4gc3RyZWFtIHRvIGRlY29tcHJlc3Mgd2VpZ2h0cy4gSXM6IAAASGQQADYAAAAZVBAADQAAAEZTRSB0YWJsZSB1c2VkIG1vcmUgYnl0ZXM6ICB0aGFuIHdlcmUgbWVhbnQgdG8gYmUgdXNlZCBmb3IgdGhlIHdob2xlIHN0cmVhbSBvZiBodWZmbWFuIHdlaWdodHMgKCkAAACQZBAAGwAAAKtkEABFAAAA8GQQAAEAAABTb3VyY2UgbmVlZHMgdG8gaGF2ZSBhdCBsZWFzdCAgYnl0ZXMsIGdvdDogAAxlEAAeAAAAKmUQAA0AAAALQ2FudCBoYXZlIHdlaWdodDogIGJpZ2dlciB0aGFuIG1heF9udW1fYml0czogAABJZRAAEgAAAFtlEAAbAAAAbWF4X2JpdHMgZGVyaXZlZCBmcm9tIHdlaWdodHMgaXM6ICBzaG91bGQgYmUgbG93ZXIgdGhhbjogAAAAiGUQACIAAACqZRAAFwAAAENhbnQgc2VydmUgdGhpcyByZXF1ZXN0LiBUaGUgcmVhZGVyIGlzIGxpbWl0ZWQgdG8gIGJpdHMsIHJlcXVlc3RlZCAgYml0c9RlEAAyAAAABmYQABEAAAAXZhAABQAAAENhbid0IHJlYWQgIGJpdHMsIG9ubHkgaGF2ZSAgYml0cyBsZWZ0AAA0ZhAACwAAAD9mEAARAAAAUGYQAAoAAAAAAAAABAAAAAQAAADJAQAAAAAAAAQAAAAEAAAAygEAAFRvb01hbnlCaXRzbnVtX3JlcXVlc3RlZF9iaXRzbGltaXQAAAAAAAAEAAAABAAAAMsBAABOb3RFbm91Z2hSZW1haW5pbmdCaXRzcmVxdWVzdGVkcmVtYWluaW5nSW52YWxpZEZyYW1lQ29udGVudFNpemVGbGFnZ290AAAAAAAABAAAAAQAAADMAQAAV2luZG93VG9vQmlnV2luZG93VG9vU21hbGwAAAAAAAAEAAAABAAAAK4BAABGcmFtZURlc2NyaXB0b3JFcnJvckRpY3RJZFRvb1NtYWxsZXhwZWN0ZWRNaXNtYXRjaGVkRnJhbWVTaXplRnJhbWVTaXplSXNaZXJvSW52YWxpZEZyYW1lU2l6ZQAAAAAEAAAABAAAAM0BAABNYWdpY051bWJlclJlYWRFcnJvcgAAAAAEAAAABAAAAM4BAABCYWRNYWdpY051bWJlckZyYW1lRGVzY3JpcHRvclJlYWRFcnJvckludmFsaWRGcmFtZURlc2NyaXB0b3JXaW5kb3dEZXNjcmlwdG9yUmVhZEVycm9yRGljdGlvbmFyeUlkUmVhZEVycm9yRnJhbWVDb250ZW50U2l6ZVJlYWRFcnJvcgAAAAAABAAAAAQAAADPAQAAU2tpcEZyYW1lbWFnaWNfbnVtYmVybGVuZ3RoQmxvY2tDb250ZW50UmVhZEVycm9yTWFsZm9ybWVkU2VjdGlvbkhlYWRlcmV4cGVjdGVkX2xlbnJlbWFpbmluZ19ieXRlcwAAAAAAAAAEAAAABAAAALIBAABEZWNvbXByZXNzTGl0ZXJhbHNFcnJvcgAAAAAABAAAAAQAAACzAQAATGl0ZXJhbHNTZWN0aW9uUGFyc2VFcnJvcgAAAAAAAAAEAAAABAAAALQBAABTZXF1ZW5jZXNIZWFkZXJQYXJzZUVycm9yAAAAAAAAAAQAAAAEAAAAtQEAAERlY29kZVNlcXVlbmNlRXJyb3IAAAAAAAQAAAAEAAAAtgEAAEV4ZWN1dGVTZXF1ZW5jZXNFcnJvck5vdEVub3VnaEJ5dGVzSW5EaWN0aW9uYXJ5bmVlZE9mZnNldFRvb0JpZ29mZnNldGJ1Zl9sZW4AAAAABAAAAAQAAAC4AQAAQmFkTWFnaWNOdW0AAAAAAAQAAAAEAAAAuQEAAEZTRVRhYmxlRXJyb3IAAAAAAAAABAAAAAQAAAC6AQAASHVmZm1hblRhYmxlRXJyb3JNaXNzaW5nQ29tcHJlc3NlZFNpemVNaXNzaW5nTnVtU3RyZWFtcwAAAAAABAAAAAQAAADBAQAAR2V0Qml0c0Vycm9yAAAAAAQAAAAEAAAAwgEAAEh1ZmZtYW5EZWNvZGVyRXJyb3JVbmluaXRpYWxpemVkSHVmZm1hblRhYmxlTWlzc2luZ0J5dGVzRm9ySnVtcEhlYWRlck1pc3NpbmdCeXRlc0ZvckxpdGVyYWxzbmVlZGVkAAAAAAAABAAAAAQAAADQAQAARXh0cmFQYWRkaW5nc2tpcHBlZF9iaXRzAAAAAAQAAAAEAAAA0QEAAAAAAAAEAAAABAAAANIBAABCaXRzdHJlYW1SZWFkTWlzbWF0Y2hyZWFkX3RpbERlY29kZWRMaXRlcmFsQ291bnRNaXNtYXRjaGRlY29kZWQAAAAAAAQAAAAEAAAAxQEAAERlY29kZWJ1ZmZlckVycm9yTm90RW5vdWdoQnl0ZXNGb3JTZXF1ZW5jZXdhbnRlZGhhdmVaZXJvT2Zmc2V0AAAAAAAABAAAAAQAAADGAQAARlNFRGVjb2RlckVycm9yVW5zdXBwb3J0ZWRPZmZzZXRvZmZzZXRfY29kZU5vdEVub3VnaEJ5dGVzRm9yTnVtU2VxdWVuY2VzRXh0cmFCaXRzYml0c19yZW1haW5pbmdNaXNzaW5nQ29tcHJlc3Npb25Nb2RlTWlzc2luZ0J5dGVGb3JSbGVMbFRhYmxlTWlzc2luZ0J5dGVGb3JSbGVPZlRhYmxlTWlzc2luZ0J5dGVGb3JSbGVNbFRhYmxlSWxsZWdhbExpdGVyYWxTZWN0aW9uVHlwZU5vdEVub3VnaEJ5dGVzAAAAAAEAAAABAAAA0wEAAG5lZWRfYXRfbGVhc3RBY2NMb2dJc1plcm9BY2NMb2dUb29CaWdtYXgAAAAABAAAAAQAAADHAQAAUHJvYmFiaWxpdHlDb3VudGVyTWlzbWF0Y2hleHBlY3RlZF9zdW1zeW1ib2xfcHJvYmFiaWxpdGllc1Rvb01hbnlTeW1ib2xzVGFibGVJc1VuaW5pdGlhbGl6ZWRTb3VyY2VJc0VtcHR5Tm90RW5vdWdoQnl0ZXNGb3JXZWlnaHRzZ290X2J5dGVzZXhwZWN0ZWRfYnl0ZXNUb29NYW55V2VpZ2h0c01pc3NpbmdXZWlnaHRzTGVmdG92ZXJJc05vdEFQb3dlck9mMk5vdEVub3VnaEJ5dGVzVG9EZWNvbXByZXNzV2VpZ2h0c0ZTRVRhYmxlVXNlZFRvb01hbnlCeXRlc3VzZWRhdmFpbGFibGVfYnl0ZXNOb3RFbm91Z2hCeXRlc0luU291cmNlV2VpZ2h0QmlnZ2VyVGhhbk1heE51bUJpdHNNYXhCaXRzVG9vSGlnaC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnMAAABQbhAAbQAAACoCAAARAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcnV6c3RkLTAuOC4wL3NyYy9kZWNvZGluZy9iaXRfcmVhZGVyX3JldmVyc2UucnMAAADQbhAAcQAAADcAAABFAAAA0G4QAHEAAAA3AAAALwAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGXQbhAAcQAAAEYAAAANAAAA0G4QAHEAAABKAAAAHgAAAFRoaXMgaXMgYSBidWcgaW4gdGhlIHByb2dyYW0uIFRoZXJlIHNob3VsZCBvbmx5IGJlIHZhbHVlcyBiZXR3ZWVuIDAuLjMvVXNlcnMvZHlsYW4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9ydXpzdGQtMC44LjAvc3JjL2Jsb2Nrcy9saXRlcmFsc19zZWN0aW9uLnJzAPJvEABtAAAAewAAADQAAADybxAAbQAAAJAAAABXAAAA8m8QAG0AAACXAAAAKgAAAPJvEABtAAAAmAAAACoAAADybxAAbQAAAJsAAAAaAAAA8m8QAG0AAACoAAAAGgAAAPJvEABtAAAAtAAAAEQAAADybxAAbQAAALgAAABGAAAA8m8QAG0AAADAAAAAKgAAAPJvEABtAAAAwQAAACsAAADybxAAbQAAAMUAAABIAAAA8m8QAG0AAADNAAAAKgAAAPJvEABtAAAAzgAAACsAAADybxAAbQAAANMAAAAuAAAA8m8QAG0AAADUAAAALgAAAENhbnQgcmV0dXJuIHRoaXMgbWFueSBiaXRzL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcnV6c3RkLTAuOC4wL3NyYy9kZWNvZGluZy9iaXRfcmVhZGVyLnJzAGpxEABpAAAANgAAAA0AAABqcRAAaQAAAE8AAAAjAAAAYXNzZXJ0aW9uIGZhaWxlZDogbiAtIGJpdF9zaGlmdCA9PSBiaXRzX2luX2xhc3RfYnl0ZV9uZWVkZWQAanEQAGkAAABtAAAADQAAAGpxEABpAAAAcQAAAB8AAABqcRAAaQAAAGgAAAAkAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5pZHggJSA4ID09IDAAanEQAGkAAABkAAAADQAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaWR4ID09IG9sZF9pZHggKyBuAAAAanEQAGkAAAB3AAAACQAAAFNlcV9zdW06ICBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZGlmZmVyZW5jZSBpbiBidWZmZXJzaXplOiAAANByEAAJAAAA2XIQADEAAAAvVXNlcnMvZHlsYW4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9ydXpzdGQtMC44LjAvc3JjL2RlY29kaW5nL3NlcXVlbmNlX2V4ZWN1dGlvbi5ycwAAABxzEABxAAAALwAAAAUAAAAccxAAcQAAAAsAAAAkAAAAHHMQAHEAAAAVAAAANAAAAEFsbG9jYXRpbmcgbmV3IHNwYWNlIGZvciB0aGUgcmluZ2J1ZmZlciBmYWlsZWQvVXNlcnMvZHlsYW4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9ydXpzdGQtMC44LjAvc3JjL2RlY29kaW5nL3JpbmdidWZmZXIucnMA7nMQAGkAAABhAAAAIwAAAENvdWxkIG5vdCBjcmVhdGUgbGF5b3V0IGZvciB1OCBhcnJheSBvZiBzaXplIAAAAGh0EAAtAAAA7nMQAGkAAABaAAAAIQAAAO5zEABpAAAAtAAAABUAAADucxAAaQAAAL4AAAAVAAAA7nMQAGkAAAB3AQAAHQAAAO5zEABpAAAAzgEAABUAAAAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwDwdBAAawAAAKIAAAAZAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcnV6c3RkLTAuOC4wL3NyYy9kZWNvZGluZy9saXRlcmFsc19zZWN0aW9uX2RlY29kZXIucnMAbHUQAHcAAAAUAAAAIgAAAGx1EAB3AAAAGAAAAE0AAABsdRAAdwAAADQAAAAZAAAAbHUQAHcAAAByAAAAGAAAAGx1EAB3AAAAkQAAABQAAABhc3NlcnRpb24gZmFpbGVkOiBudW1fc3RyZWFtcyA9PSAxAABsdRAAdwAAAIAAAAAJAAAAbHUQAHcAAABFAAAAGQAAAC9Vc2Vycy9keWxhbi8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3J1enN0ZC0wLjguMC9zcmMvZGVjb2Rpbmcvc2VxdWVuY2Vfc2VjdGlvbl9kZWNvZGVyLnJzAHh2EAB3AAAAGAAAAB0AAAB4dhAAdwAAAHUAAAAQAAAAeHYQAHcAAADAAAAAEAAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGU6IElsbGVnYWwgbGl0ZXJhbCBsZW5ndGggY29kZSB3YXM6IAAgdxAASwAAAHh2EAB3AAAA+gAAAA4AAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlOiBJbGxlZ2FsIG1hdGNoIGxlbmd0aCBjb2RlIHdhczogAAAAhHcQAEkAAAB4dhAAdwAAABoBAAAOAAAABAAAAAMAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAEAAAABAAAAAQAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAMAAAACAAAAAQAAAAEAAAABAAAAAQAAAAEAAAD/////////////////////AQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAA//////////////////////////8BAAAABAAAAAMAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAA/////////////////////////////////////3h2EAB3AAAAdgEAABwAAAB4dhAAdwAAAFMBAAAcAAAAAQEBAQICAwMEBgcICQoLDA0ODxAQAAAAEgAAABQAAAAWAAAAGAAAABwAAAAgAAAAKAAAADAAAABAAAAAgAAAAAABAAAAAgAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAAABAAEBAQECAgMDBAQFBwgJCgsMDQ4PEAAAACMAAAAlAAAAJwAAACkAAAArAAAALwAAADMAAAA7AAAAQwAAAFMAAABjAAAAgwAAAAMBAAADAgAAAwQAAAMIAAADEAAAAyAAAANAAAADgAAAAwABAC9Vc2Vycy9keWxhbi8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3R3b3gtaGFzaC0yLjEuMC9zcmMveHhoYXNoNjQucnMAAACwehAAYQAAAFQAAAAfAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcnV6c3RkLTAuOC4wL3NyYy9kZWNvZGluZy9kZWNvZGVidWZmZXIucnMAJHsQAGsAAAAaAAAAHgAAACR7EABrAAAAnQAAADQAAAAkexAAawAAAOoAAAAeAAAAUmF3UkxFQ29tcHJlc3NlZFJlc2VydmVyZAAAAAAAAAAEAAAABAAAAMoBAAAAAAAABAAAAAQAAADQAQAAYXNzZXJ0aW9uIGZhaWxlZDogeCA+IDAvVXNlcnMvZHlsYW4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9ydXpzdGQtMC44LjAvc3JjL2h1ZmYwL2h1ZmYwX2RlY29kZXIucnMTfBAAaQAAADEAAAAFAAAAE3wQAGkAAAA+AAAAGgAAABN8EABpAAAAUAAAACkAAAATfBAAaQAAAGgAAAAWAAAAE3wQAGkAAABqAAAAEwAAABN8EABpAAAAawAAABgAAAATfBAAaQAAAGwAAAAbAAAAE3wQAGkAAAAdAQAANgAAABN8EABpAAAAHQEAACUAAAATfBAAaQAAAB8BAAA2AAAAE3wQAGkAAAAfAQAAJQAAABN8EABpAAAA6AAAACIAAAATfBAAaQAAAPIAAAAiAAAAE3wQAGkAAAD3AAAAJgAAABN8EABpAAAA7QAAACYAAAATfBAAaQAAAFcBAAASAAAAE3wQAGkAAABfAQAAGAAAABN8EABpAAAAZQEAABUAAAATfBAAaQAAAG8BAAAbAAAAE3wQAGkAAABxAQAAGgAAABN8EABpAAAAeAEAAB4AAAByYW5rX2lkeFswXTogIHNob3VsZCBiZTogAAAAzH0QAA0AAADZfRAADAAAABN8EABpAAAAdwEAAAkAAAATfBAAaQAAAH8BAAAsAAAAE3wQAGkAAACEAQAAMQAAABN8EABpAAAAiAEAACAAAAATfBAAaQAAAIkBAAAgAAAAE3wQAGkAAABzAQAARQAAABN8EABpAAAAdAEAACEAAAATfBAAaQAAAHMBAAAeAAAAE3wQAGkAAABhAQAAGwAAABN8EABpAAAATwEAACcAAAATfBAAaQAAAFQBAAAWAAAAL1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAqH4QAGsAAACiAAAAGQAAAC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzACR/EABrAAAAogAAABkAAABhc3NlcnRpb24gZmFpbGVkOiB4ID4gMC9Vc2Vycy9keWxhbi8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3J1enN0ZC0wLjguMC9zcmMvZnNlL2ZzZV9kZWNvZGVyLnJzt38QAGUAAAA9AAAABQAAALd/EABlAAAAWgAAACcAAAC3fxAAZQAAAGUAAAAnAAAAt38QAGUAAABwAAAAIwAAALd/EABlAAAAcQAAAB0AAAC3fxAAZQAAAOIAAAApAAAAt38QAGUAAADkAAAAMQAAALd/EABlAAAA5gAAADMAAABhc3NlcnRpb24gZmFpbGVkOiBuYiA8PSBzZWxmLmFjY3VyYWN5X2xvZwAAALd/EABlAAAA6wAAAA0AAAC3fxAAZQAAANIAAAAtAAAAt38QAGUAAADAAAAALQAAALd/EABlAAAAOQEAAEEAAAC3fxAAZQAAAB4BAAAnAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHJvYiA9PSAtMbd/EABlAAAAJAEAABUAAAAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy92ZWMvbW9kLnJzAAAARIEQAG0AAAA9CgAAJAAAAAAAAAAQAAAABAAAANQBAADVAQAA1gEAACAgICA6IAAAAQAAAAAAAADggRAAAgAAACAgICAgICAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2NvcmUvc3JjL3B0ci9tb2QucnMA+4EQAGwAAAALAgAAAQAAAC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvY29yZS9zcmMvc2xpY2UvaW5kZXgucnN4ghAAcAAAAEwDAAA0AAAAeIIQAHAAAABTAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAMoMQAGwAAAD7BwAAHQAAADKDEABsAAAAAwgAAB0AAAAygxAAbAAAAI0FAAAbAAAAL1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5ycwAAANCDEABtAAAAKgIAABEAAADXAQAADAAAAAQAAADYAQAA2QEAANoBAADdAQAADAAAAAQAAADeAQAA3wEAANoBAEGIicIAC4UJAQAAAOABAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5L1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAMeEEABsAAAA3woAAA4AAABFcnJvcgAAAMeEEABsAAAAjQUAABsAAABhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbinHhBAAbAAAAMAFAAANAAAAAAAAABAAAAAEAAAA1AEAANUBAADWAQAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYW55aG93LTEuMC45OC9zcmMvZXJyb3IucnPMhRAAXAAAAGcEAAAOAAAAAQAAAAAAAAA6IAAAQIYQAAIAAAAKCkNhdXNlZCBieToKCgpzdGFjayBiYWNrdHJhY2U6U3RhY2sgYmFja3RyYWNlOgprhhAAEQAAAFMvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2NvcmUvc3JjL2l0ZXIvdHJhaXRzL2l0ZXJhdG9yLnJzAACFhhAAeQAAALMHAAAJAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvanMtc3lzLTAuMy43Ny9zcmMvbGliLnJzAAAQhxAAWgAAAPsYAAABAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvd2FzbS1iaW5kZ2VuLTAuMi4xMDAvc3JjL2NvbnZlcnQvc2xpY2VzLnJzfIcQAGwAAAAkAQAADgAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkSnNWYWx1ZSgpACqIEAAIAAAAMogQAAEAAABMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAESIEAAqAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvb25jZV9jZWxsLTEuMjEuMy9zcmMvbGliLnJzAAAAeIgQAF0AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AADoiBAADgAAAHiIEABdAAAAegIAAA0AQZiSwgALlSMEAAAABAAAAPYBAAAvcnVzdGMvMDVmOTg0NmY4OTNiMDlhMWJlMWZjODU2MGUzM2ZjM2M4MTVjZmVjYi9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAJIkQAEoAAACiAAAAGQAAAC9ydXN0Yy8wNWY5ODQ2Zjg5M2IwOWExYmUxZmM4NTYwZTMzZmMzYzgxNWNmZWNiL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwCAiRAASwAAAI0FAAAbAAAAL3J1c3RjLzA1Zjk4NDZmODkzYjA5YTFiZTFmYzg1NjBlMzNmYzNjODE1Y2ZlY2IvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc9yJEABMAAAAKgIAABEAAAA6AAAA9wEAAAwAAAAEAAAA+AEAAPkBAAD6AQAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNy9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAFSKEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAABUihAAKQAAAK4EAAANAAAAQWNjZXNzRXJyb3JjYW5ub3QgYWNjZXNzIGEgVGhyZWFkIExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uOiAAB4sQAEgAAABsaWJyYXJ5L3N0ZC9zcmMvYmFja3RyYWNlLnJzb3BlcmF0aW9uIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBwbGF0Zm9ybXSLEAAoAAAAJAAAAAIAAACcixAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAFiLEAAcAAAAigEAAB0AAAD7AQAAEAAAAAQAAAD8AQAA/QEAAAEAAAAAAAAAZW50aXR5IG5vdCBmb3VuZHBlcm1pc3Npb24gZGVuaWVkY29ubmVjdGlvbiByZWZ1c2VkY29ubmVjdGlvbiByZXNldGhvc3QgdW5yZWFjaGFibGVuZXR3b3JrIHVucmVhY2hhYmxlY29ubmVjdGlvbiBhYm9ydGVkbm90IGNvbm5lY3RlZGFkZHJlc3MgaW4gdXNlYWRkcmVzcyBub3QgYXZhaWxhYmxlbmV0d29yayBkb3duYnJva2VuIHBpcGVlbnRpdHkgYWxyZWFkeSBleGlzdHNvcGVyYXRpb24gd291bGQgYmxvY2tub3QgYSBkaXJlY3RvcnlpcyBhIGRpcmVjdG9yeWRpcmVjdG9yeSBub3QgZW1wdHlyZWFkLW9ubHkgZmlsZXN5c3RlbSBvciBzdG9yYWdlIG1lZGl1bWZpbGVzeXN0ZW0gbG9vcCBvciBpbmRpcmVjdGlvbiBsaW1pdCAoZS5nLiBzeW1saW5rIGxvb3Apc3RhbGUgbmV0d29yayBmaWxlIGhhbmRsZWludmFsaWQgaW5wdXQgcGFyYW1ldGVyaW52YWxpZCBkYXRhdGltZWQgb3V0d3JpdGUgemVyb25vIHN0b3JhZ2Ugc3BhY2VzZWVrIG9uIHVuc2Vla2FibGUgZmlsZXF1b3RhIGV4Y2VlZGVkZmlsZSB0b28gbGFyZ2VyZXNvdXJjZSBidXN5ZXhlY3V0YWJsZSBmaWxlIGJ1c3lkZWFkbG9ja2Nyb3NzLWRldmljZSBsaW5rIG9yIHJlbmFtZXRvbyBtYW55IGxpbmtzaW52YWxpZCBmaWxlbmFtZWFyZ3VtZW50IGxpc3QgdG9vIGxvbmdvcGVyYXRpb24gaW50ZXJydXB0ZWR1bnN1cHBvcnRlZHVuZXhwZWN0ZWQgZW5kIG9mIGZpbGVvdXQgb2YgbWVtb3J5aW4gcHJvZ3Jlc3NvdGhlciBlcnJvcnVuY2F0ZWdvcml6ZWQgZXJyb3JPcwAAAAAABAAAAAQAAAD+AQAAY29kZQAAAAABAAAAAQAAAP8BAABraW5k9wEAAAwAAAAEAAAAAAIAAG1lc3NhZ2VLaW5kRXJyb3IAAAAACAAAAAQAAAABAgAAAAAAAAQAAAAEAAAAAgIAAEN1c3RvbWVycm9yIChvcyBlcnJvciApAAEAAAAAAAAAZ48QAAsAAAByjxAAAQAAADogY2Fubm90IHJlY3Vyc2l2ZWx5IGFjcXVpcmUgbXV0ZXgAAI6PEAAgAAAAbGlicmFyeS9zdGQvc3JjL3N5cy9zeW5jL211dGV4L25vX3RocmVhZHMucnO4jxAALAAAABMAAAAJAAAAbGlicmFyeS9zdGQvc3JjL3N5bmMvcG9pc29uL29uY2UucnMA9I8QACMAAACbAAAAMgAAAGxpYnJhcnkvc3RkL3NyYy9zeW5jL2xhenlfbG9jay5ycwAAACiQEAAhAAAA0QAAABMAAAA8dW5rbm93bj7vv71tZW1vcnkgYWxsb2NhdGlvbiBvZiAgYnl0ZXMgZmFpbGVkAABokBAAFQAAAH2QEAANAAAAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJznJAQABgAAABjAQAACQAAAAoAAAD3AQAADAAAAAQAAAADAgAAAAAAAAgAAAAEAAAABAIAAAAAAAAIAAAABAAAAAUCAAAGAgAABwIAAAgCAAAJAgAAEAAAAAQAAAAKAgAACwIAAAwCAAANAgAAbGlicmFyeS9zdGQvc3JjLy4uLy4uL2JhY2t0cmFjZS9zcmMvc3ltYm9saXplL21vZC5ycyCREAA0AAAAZwEAADAAAAABAAAAAAAAAIyPEAACAAAAIC0gAAEAAAAAAAAAdJEQAAMAAAAgICAgICAgICAgICAgICAgICAgYXQgAAA4ihAAAQAAAE5vdEZvdW5kUGVybWlzc2lvbkRlbmllZENvbm5lY3Rpb25SZWZ1c2VkQ29ubmVjdGlvblJlc2V0SG9zdFVucmVhY2hhYmxlTmV0d29ya1VucmVhY2hhYmxlQ29ubmVjdGlvbkFib3J0ZWROb3RDb25uZWN0ZWRBZGRySW5Vc2VBZGRyTm90QXZhaWxhYmxlTmV0d29ya0Rvd25Ccm9rZW5QaXBlQWxyZWFkeUV4aXN0c1dvdWxkQmxvY2tOb3RBRGlyZWN0b3J5SXNBRGlyZWN0b3J5RGlyZWN0b3J5Tm90RW1wdHlSZWFkT25seUZpbGVzeXN0ZW1GaWxlc3lzdGVtTG9vcFN0YWxlTmV0d29ya0ZpbGVIYW5kbGVJbnZhbGlkSW5wdXRJbnZhbGlkRGF0YVRpbWVkT3V0V3JpdGVaZXJvU3RvcmFnZUZ1bGxOb3RTZWVrYWJsZVF1b3RhRXhjZWVkZWRGaWxlVG9vTGFyZ2VSZXNvdXJjZUJ1c3lFeGVjdXRhYmxlRmlsZUJ1c3lEZWFkbG9ja0Nyb3NzZXNEZXZpY2VzVG9vTWFueUxpbmtzSW52YWxpZEZpbGVuYW1lQXJndW1lbnRMaXN0VG9vTG9uZ0ludGVycnVwdGVkVW5zdXBwb3J0ZWRVbmV4cGVjdGVkRW9mT3V0T2ZNZW1vcnlJblByb2dyZXNzT3RoZXJVbmNhdGVnb3JpemVkb3BlcmF0aW9uIHN1Y2Nlc3NmdWxPbmNlIGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWTakxAAKgAAAG9uZS10aW1lIGluaXRpYWxpemF0aW9uIG1heSBub3QgYmUgcGVyZm9ybWVkIHJlY3Vyc2l2ZWx5DJQQADgAAAAQAAAAEQAA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",self.location.href));const A=Wt();(typeof E=="string"||typeof Request=="function"&&E instanceof Request||typeof URL=="function"&&E instanceof URL)&&(E=fetch(E));const{instance:g,module:I}=await qt(await E,A);return Vt(g,I)}var oA=Uint8Array,Ng=Uint16Array,Tt=Int32Array,EQ=new oA([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),iQ=new oA([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),vt=new oA([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),sQ=function(E,A){for(var g=new Ng(31),I=0;I<31;++I)g[I]=A+=1<<E[I-1];for(var B=new Tt(g[30]),I=1;I<30;++I)for(var Q=g[I];Q<g[I+1];++Q)B[Q]=Q-g[I]<<5|I;return{b:g,r:B}},eQ=sQ(EQ,2),aQ=eQ.b,zt=eQ.r;aQ[28]=258,zt[258]=28;for(var Xt=sQ(iQ,0),jt=Xt.b,aB=new Ng(32768),_=0;_<32768;++_){var tg=(_&43690)>>1|(_&21845)<<1;tg=(tg&52428)>>2|(tg&13107)<<2,tg=(tg&61680)>>4|(tg&3855)<<4,aB[_]=((tg&65280)>>8|(tg&255)<<8)>>1}for(var $g=function(E,A,g){for(var I=E.length,B=0,Q=new Ng(A);B<I;++B)E[B]&&++Q[E[B]-1];var t=new Ng(A);for(B=1;B<A;++B)t[B]=t[B-1]+Q[B-1]<<1;var C;if(g){C=new Ng(1<<A);var i=15-A;for(B=0;B<I;++B)if(E[B])for(var s=B<<4|E[B],a=A-E[B],e=t[E[B]-1]++<<a,n=e|(1<<a)-1;e<=n;++e)C[aB[e]>>i]=s}else for(C=new Ng(I),B=0;B<I;++B)E[B]&&(C[B]=aB[t[E[B]-1]++]>>15-E[B]);return C},AI=new oA(288),_=0;_<144;++_)AI[_]=8;for(var _=144;_<256;++_)AI[_]=9;for(var _=256;_<280;++_)AI[_]=7;for(var _=280;_<288;++_)AI[_]=8;for(var nQ=new oA(32),_=0;_<32;++_)nQ[_]=5;var Ot=$g(AI,9,1),Pt=$g(nQ,5,1),nB=function(E){for(var A=E[0],g=1;g<E.length;++g)E[g]>A&&(A=E[g]);return A},UA=function(E,A,g){var I=A/8|0;return(E[I]|E[I+1]<<8)>>(A&7)&g},oB=function(E,A){var g=A/8|0;return(E[g]|E[g+1]<<8|E[g+2]<<16)>>(A&7)},oQ=function(E){return(E+7)/8|0},FI=function(E,A,g){return(A==null||A<0)&&(A=0),(g==null||g>E.length)&&(g=E.length),new oA(E.subarray(A,g))},_t=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],mA=function(E,A,g){var I=new Error(A||_t[E]);if(I.code=E,Error.captureStackTrace&&Error.captureStackTrace(I,mA),!g)throw I;return I},$t=function(E,A,g,I){var B=E.length,Q=0;if(!B||A.f&&!A.l)return g||new oA(0);var t=!g,C=t||A.i!=2,i=A.i;t&&(g=new oA(B*3));var s=function(rA){var iA=g.length;if(rA>iA){var L=new oA(Math.max(iA*2,rA));L.set(g),g=L}},a=A.f||0,e=A.p||0,n=A.b||0,o=A.l,r=A.d,h=A.m,c=A.n,w=B*8;do{if(!o){a=UA(E,e,1);var y=UA(E,e+1,3);if(e+=3,y)if(y==1)o=Ot,r=Pt,h=9,c=5;else if(y==2){var F=UA(E,e,31)+257,p=UA(E,e+10,15)+4,d=F+UA(E,e+5,31)+1;e+=14;for(var G=new oA(d),f=new oA(19),N=0;N<p;++N)f[vt[N]]=UA(E,e+N*3,7);e+=p*3;for(var k=nB(f),R=(1<<k)-1,J=$g(f,k,1),N=0;N<d;){var m=J[UA(E,e,R)];e+=m&15;var l=m>>4;if(l<16)G[N++]=l;else{var S=0,Y=0;for(l==16?(Y=3+UA(E,e,3),e+=2,S=G[N-1]):l==17?(Y=3+UA(E,e,7),e+=3):l==18&&(Y=11+UA(E,e,127),e+=7);Y--;)G[N++]=S}}var q=G.subarray(0,F),Z=G.subarray(F);h=nB(q),c=nB(Z),o=$g(q,h,1),r=$g(Z,c,1)}else mA(1);else{var l=oQ(e)+4,u=E[l-4]|E[l-3]<<8,M=l+u;if(M>B){i&&mA(0);break}C&&s(n+u),g.set(E.subarray(l,M),n),A.b=n+=u,A.p=e=M*8,A.f=a;continue}if(e>w){i&&mA(0);break}}C&&s(n+131072);for(var $=(1<<h)-1,O=(1<<c)-1,P=e;;P=e){var S=o[oB(E,e)&$],W=S>>4;if(e+=S&15,e>w){i&&mA(0);break}if(S||mA(2),W<256)g[n++]=W;else if(W==256){P=e,o=null;break}else{var z=W-254;if(W>264){var N=W-257,X=EQ[N];z=UA(E,e,(1<<X)-1)+aQ[N],e+=X}var T=r[oB(E,e)&O],x=T>>4;T||mA(3),e+=T&15;var Z=jt[x];if(x>3){var X=iQ[x];Z+=oB(E,e)&(1<<X)-1,e+=X}if(e>w){i&&mA(0);break}C&&s(n+131072);var NA=n+z;if(n<Z){var yA=Q-Z,b=Math.min(Z,NA);for(yA+n<0&&mA(3);n<b;++n)g[n]=I[yA+n]}for(;n<NA;++n)g[n]=g[n-Z]}}A.l=o,A.p=P,A.b=n,A.f=a,o&&(a=1,A.m=h,A.d=r,A.n=c)}while(!a);return n!=g.length&&t?FI(g,0,n):g.subarray(0,n)},AC=new oA(0),gC=function(E){(E[0]!=31||E[1]!=139||E[2]!=8)&&mA(6,"invalid gzip data");var A=E[3],g=10;A&4&&(g+=(E[10]|E[11]<<8)+2);for(var I=(A>>3&1)+(A>>4&1);I>0;I-=!E[g++]);return g+(A&2)},rB=function(){function E(A,g){typeof A=="function"&&(g=A,A={}),this.ondata=g;var I=A&&A.dictionary&&A.dictionary.subarray(-32768);this.s={i:0,b:I?I.length:0},this.o=new oA(32768),this.p=new oA(0),I&&this.o.set(I)}return E.prototype.e=function(A){if(this.ondata||mA(5),this.d&&mA(4),!this.p.length)this.p=A;else if(A.length){var g=new oA(this.p.length+A.length);g.set(this.p),g.set(A,this.p.length),this.p=g}},E.prototype.c=function(A){this.s.i=+(this.d=A||!1);var g=this.s.b,I=$t(this.p,this.s,this.o);this.ondata(FI(I,g,this.s.b),this.d),this.o=FI(I,this.s.b-32768),this.s.b=this.o.length,this.p=FI(this.p,this.s.p/8|0),this.s.p&=7},E.prototype.push=function(A,g){this.e(A),this.c(g)},E}(),rQ=function(){function E(A,g){this.v=1,this.r=0,rB.call(this,A,g)}return E.prototype.push=function(A,g){if(rB.prototype.e.call(this,A),this.r+=A.length,this.v){var I=this.p.subarray(this.v-1),B=I.length>3?gC(I):4;if(B>I.length){if(!g)return}else this.v>1&&this.onmember&&this.onmember(this.r-I.length);this.p=I.subarray(B),this.v=0}rB.prototype.c.call(this,g),this.s.f&&!this.s.l&&!g&&(this.v=oQ(this.s.p)+9,this.s={i:0},this.o=new oA(0),this.push(new oA(0),g))},E}(),IC=typeof TextDecoder<"u"&&new TextDecoder,BC=0;try{IC.decode(AC,{stream:!0}),BC=1}catch{}/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */const hQ="172",hB=0,QC=1,cQ=1,wQ=100,DQ=204,lQ=205,yQ=3,tC=0,uQ=300,dQ=1e3,gI=1001,MQ=1002,Cg=1003,GQ=1006,CC=1008,kI=1009,wg=1014,EC=1015,pI=1023,iC=1031,Fg=1033,NQ="",LA="srgb",FQ="srgb-linear",kQ="linear",cB="srgb",kg=7680,pQ=519,fQ=35044,sC="300 es",II=2e3,RQ=2001;class BI{addEventListener(A,g){this._listeners===void 0&&(this._listeners={});const I=this._listeners;I[A]===void 0&&(I[A]=[]),I[A].indexOf(g)===-1&&I[A].push(g)}hasEventListener(A,g){if(this._listeners===void 0)return!1;const I=this._listeners;return I[A]!==void 0&&I[A].indexOf(g)!==-1}removeEventListener(A,g){if(this._listeners===void 0)return;const B=this._listeners[A];if(B!==void 0){const Q=B.indexOf(g);Q!==-1&&B.splice(Q,1)}}dispatchEvent(A){if(this._listeners===void 0)return;const I=this._listeners[A.type];if(I!==void 0){A.target=this;const B=I.slice(0);for(let Q=0,t=B.length;Q<t;Q++)B[Q].call(this,A);A.target=null}}}const hA=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];function QI(){const E=Math.random()*4294967295|0,A=Math.random()*4294967295|0,g=Math.random()*4294967295|0,I=Math.random()*4294967295|0;return(hA[E&255]+hA[E>>8&255]+hA[E>>16&255]+hA[E>>24&255]+"-"+hA[A&255]+hA[A>>8&255]+"-"+hA[A>>16&15|64]+hA[A>>24&255]+"-"+hA[g&63|128]+hA[g>>8&255]+"-"+hA[g>>16&255]+hA[g>>24&255]+hA[I&255]+hA[I>>8&255]+hA[I>>16&255]+hA[I>>24&255]).toLowerCase()}function H(E,A,g){return Math.max(A,Math.min(g,E))}function eC(E,A){return(E%A+A)%A}function wB(E,A,g){return(1-g)*E+g*A}function tI(E,A){switch(A.constructor){case Float32Array:return E;case Uint32Array:return E/4294967295;case Uint16Array:return E/65535;case Uint8Array:return E/255;case Int32Array:return Math.max(E/2147483647,-1);case Int16Array:return Math.max(E/32767,-1);case Int8Array:return Math.max(E/127,-1);default:throw new Error("Invalid component type.")}}function uA(E,A){switch(A.constructor){case Float32Array:return E;case Uint32Array:return Math.round(E*4294967295);case Uint16Array:return Math.round(E*65535);case Uint8Array:return Math.round(E*255);case Int32Array:return Math.round(E*2147483647);case Int16Array:return Math.round(E*32767);case Int8Array:return Math.round(E*127);default:throw new Error("Invalid component type.")}}class dA{constructor(A=0,g=0){dA.prototype.isVector2=!0,this.x=A,this.y=g}get width(){return this.x}set width(A){this.x=A}get height(){return this.y}set height(A){this.y=A}set(A,g){return this.x=A,this.y=g,this}setScalar(A){return this.x=A,this.y=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setComponent(A,g){switch(A){case 0:this.x=g;break;case 1:this.y=g;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y)}copy(A){return this.x=A.x,this.y=A.y,this}add(A){return this.x+=A.x,this.y+=A.y,this}addScalar(A){return this.x+=A,this.y+=A,this}addVectors(A,g){return this.x=A.x+g.x,this.y=A.y+g.y,this}addScaledVector(A,g){return this.x+=A.x*g,this.y+=A.y*g,this}sub(A){return this.x-=A.x,this.y-=A.y,this}subScalar(A){return this.x-=A,this.y-=A,this}subVectors(A,g){return this.x=A.x-g.x,this.y=A.y-g.y,this}multiply(A){return this.x*=A.x,this.y*=A.y,this}multiplyScalar(A){return this.x*=A,this.y*=A,this}divide(A){return this.x/=A.x,this.y/=A.y,this}divideScalar(A){return this.multiplyScalar(1/A)}applyMatrix3(A){const g=this.x,I=this.y,B=A.elements;return this.x=B[0]*g+B[3]*I+B[6],this.y=B[1]*g+B[4]*I+B[7],this}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this}clamp(A,g){return this.x=H(this.x,A.x,g.x),this.y=H(this.y,A.y,g.y),this}clampScalar(A,g){return this.x=H(this.x,A,g),this.y=H(this.y,A,g),this}clampLength(A,g){const I=this.length();return this.divideScalar(I||1).multiplyScalar(H(I,A,g))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(A){return this.x*A.x+this.y*A.y}cross(A){return this.x*A.y-this.y*A.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(A){const g=Math.sqrt(this.lengthSq()*A.lengthSq());if(g===0)return Math.PI/2;const I=this.dot(A)/g;return Math.acos(H(I,-1,1))}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const g=this.x-A.x,I=this.y-A.y;return g*g+I*I}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,g){return this.x+=(A.x-this.x)*g,this.y+=(A.y-this.y)*g,this}lerpVectors(A,g,I){return this.x=A.x+(g.x-A.x)*I,this.y=A.y+(g.y-A.y)*I,this}equals(A){return A.x===this.x&&A.y===this.y}fromArray(A,g=0){return this.x=A[g],this.y=A[g+1],this}toArray(A=[],g=0){return A[g]=this.x,A[g+1]=this.y,A}fromBufferAttribute(A,g){return this.x=A.getX(g),this.y=A.getY(g),this}rotateAround(A,g){const I=Math.cos(g),B=Math.sin(g),Q=this.x-A.x,t=this.y-A.y;return this.x=Q*I-t*B+A.x,this.y=Q*B+t*I+A.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class TA{constructor(A,g,I,B,Q,t,C,i,s){TA.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],A!==void 0&&this.set(A,g,I,B,Q,t,C,i,s)}set(A,g,I,B,Q,t,C,i,s){const a=this.elements;return a[0]=A,a[1]=B,a[2]=C,a[3]=g,a[4]=Q,a[5]=i,a[6]=I,a[7]=t,a[8]=s,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(A){const g=this.elements,I=A.elements;return g[0]=I[0],g[1]=I[1],g[2]=I[2],g[3]=I[3],g[4]=I[4],g[5]=I[5],g[6]=I[6],g[7]=I[7],g[8]=I[8],this}extractBasis(A,g,I){return A.setFromMatrix3Column(this,0),g.setFromMatrix3Column(this,1),I.setFromMatrix3Column(this,2),this}setFromMatrix4(A){const g=A.elements;return this.set(g[0],g[4],g[8],g[1],g[5],g[9],g[2],g[6],g[10]),this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,g){const I=A.elements,B=g.elements,Q=this.elements,t=I[0],C=I[3],i=I[6],s=I[1],a=I[4],e=I[7],n=I[2],o=I[5],r=I[8],h=B[0],c=B[3],w=B[6],y=B[1],l=B[4],u=B[7],M=B[2],F=B[5],p=B[8];return Q[0]=t*h+C*y+i*M,Q[3]=t*c+C*l+i*F,Q[6]=t*w+C*u+i*p,Q[1]=s*h+a*y+e*M,Q[4]=s*c+a*l+e*F,Q[7]=s*w+a*u+e*p,Q[2]=n*h+o*y+r*M,Q[5]=n*c+o*l+r*F,Q[8]=n*w+o*u+r*p,this}multiplyScalar(A){const g=this.elements;return g[0]*=A,g[3]*=A,g[6]*=A,g[1]*=A,g[4]*=A,g[7]*=A,g[2]*=A,g[5]*=A,g[8]*=A,this}determinant(){const A=this.elements,g=A[0],I=A[1],B=A[2],Q=A[3],t=A[4],C=A[5],i=A[6],s=A[7],a=A[8];return g*t*a-g*C*s-I*Q*a+I*C*i+B*Q*s-B*t*i}invert(){const A=this.elements,g=A[0],I=A[1],B=A[2],Q=A[3],t=A[4],C=A[5],i=A[6],s=A[7],a=A[8],e=a*t-C*s,n=C*i-a*Q,o=s*Q-t*i,r=g*e+I*n+B*o;if(r===0)return this.set(0,0,0,0,0,0,0,0,0);const h=1/r;return A[0]=e*h,A[1]=(B*s-a*I)*h,A[2]=(C*I-B*t)*h,A[3]=n*h,A[4]=(a*g-B*i)*h,A[5]=(B*Q-C*g)*h,A[6]=o*h,A[7]=(I*i-s*g)*h,A[8]=(t*g-I*Q)*h,this}transpose(){let A;const g=this.elements;return A=g[1],g[1]=g[3],g[3]=A,A=g[2],g[2]=g[6],g[6]=A,A=g[5],g[5]=g[7],g[7]=A,this}getNormalMatrix(A){return this.setFromMatrix4(A).invert().transpose()}transposeIntoArray(A){const g=this.elements;return A[0]=g[0],A[1]=g[3],A[2]=g[6],A[3]=g[1],A[4]=g[4],A[5]=g[7],A[6]=g[2],A[7]=g[5],A[8]=g[8],this}setUvTransform(A,g,I,B,Q,t,C){const i=Math.cos(Q),s=Math.sin(Q);return this.set(I*i,I*s,-I*(i*t+s*C)+t+A,-B*s,B*i,-B*(-s*t+i*C)+C+g,0,0,1),this}scale(A,g){return this.premultiply(DB.makeScale(A,g)),this}rotate(A){return this.premultiply(DB.makeRotation(-A)),this}translate(A,g){return this.premultiply(DB.makeTranslation(A,g)),this}makeTranslation(A,g){return A.isVector2?this.set(1,0,A.x,0,1,A.y,0,0,1):this.set(1,0,A,0,1,g,0,0,1),this}makeRotation(A){const g=Math.cos(A),I=Math.sin(A);return this.set(g,-I,0,I,g,0,0,0,1),this}makeScale(A,g){return this.set(A,0,0,0,g,0,0,0,1),this}equals(A){const g=this.elements,I=A.elements;for(let B=0;B<9;B++)if(g[B]!==I[B])return!1;return!0}fromArray(A,g=0){for(let I=0;I<9;I++)this.elements[I]=A[I+g];return this}toArray(A=[],g=0){const I=this.elements;return A[g]=I[0],A[g+1]=I[1],A[g+2]=I[2],A[g+3]=I[3],A[g+4]=I[4],A[g+5]=I[5],A[g+6]=I[6],A[g+7]=I[7],A[g+8]=I[8],A}clone(){return new this.constructor().fromArray(this.elements)}}const DB=new TA;function aC(E){for(let A=E.length-1;A>=0;--A)if(E[A]>=65535)return!0;return!1}function JQ(E){return document.createElementNS("http://www.w3.org/1999/xhtml",E)}const mQ=new TA().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),SQ=new TA().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function nC(){const E={enabled:!0,workingColorSpace:FQ,spaces:{},convert:function(B,Q,t){return this.enabled===!1||Q===t||!Q||!t||(this.spaces[Q].transfer===cB&&(B.r=XA(B.r),B.g=XA(B.g),B.b=XA(B.b)),this.spaces[Q].primaries!==this.spaces[t].primaries&&(B.applyMatrix3(this.spaces[Q].toXYZ),B.applyMatrix3(this.spaces[t].fromXYZ)),this.spaces[t].transfer===cB&&(B.r=pg(B.r),B.g=pg(B.g),B.b=pg(B.b))),B},fromWorkingColorSpace:function(B,Q){return this.convert(B,this.workingColorSpace,Q)},toWorkingColorSpace:function(B,Q){return this.convert(B,Q,this.workingColorSpace)},getPrimaries:function(B){return this.spaces[B].primaries},getTransfer:function(B){return B===NQ?kQ:this.spaces[B].transfer},getLuminanceCoefficients:function(B,Q=this.workingColorSpace){return B.fromArray(this.spaces[Q].luminanceCoefficients)},define:function(B){Object.assign(this.spaces,B)},_getMatrix:function(B,Q,t){return B.copy(this.spaces[Q].toXYZ).multiply(this.spaces[t].fromXYZ)},_getDrawingBufferColorSpace:function(B){return this.spaces[B].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(B=this.workingColorSpace){return this.spaces[B].workingColorSpaceConfig.unpackColorSpace}},A=[.64,.33,.3,.6,.15,.06],g=[.2126,.7152,.0722],I=[.3127,.329];return E.define({[FQ]:{primaries:A,whitePoint:I,transfer:kQ,toXYZ:mQ,fromXYZ:SQ,luminanceCoefficients:g,workingColorSpaceConfig:{unpackColorSpace:LA},outputColorSpaceConfig:{drawingBufferColorSpace:LA}},[LA]:{primaries:A,whitePoint:I,transfer:cB,toXYZ:mQ,fromXYZ:SQ,luminanceCoefficients:g,outputColorSpaceConfig:{drawingBufferColorSpace:LA}}}),E}const bA=nC();function XA(E){return E<.04045?E*.0773993808:Math.pow(E*.9478672986+.0521327014,2.4)}function pg(E){return E<.0031308?E*12.92:1.055*Math.pow(E,.41666)-.055}let fg;class oC{static getDataURL(A){if(/^data:/i.test(A.src)||typeof HTMLCanvasElement>"u")return A.src;let g;if(A instanceof HTMLCanvasElement)g=A;else{fg===void 0&&(fg=JQ("canvas")),fg.width=A.width,fg.height=A.height;const I=fg.getContext("2d");A instanceof ImageData?I.putImageData(A,0,0):I.drawImage(A,0,0,A.width,A.height),g=fg}return g.width>2048||g.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",A),g.toDataURL("image/jpeg",.6)):g.toDataURL("image/png")}static sRGBToLinear(A){if(typeof HTMLImageElement<"u"&&A instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&A instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&A instanceof ImageBitmap){const g=JQ("canvas");g.width=A.width,g.height=A.height;const I=g.getContext("2d");I.drawImage(A,0,0,A.width,A.height);const B=I.getImageData(0,0,A.width,A.height),Q=B.data;for(let t=0;t<Q.length;t++)Q[t]=XA(Q[t]/255)*255;return I.putImageData(B,0,0),g}else if(A.data){const g=A.data.slice(0);for(let I=0;I<g.length;I++)g instanceof Uint8Array||g instanceof Uint8ClampedArray?g[I]=Math.floor(XA(g[I]/255)*255):g[I]=XA(g[I]);return{data:g,width:A.width,height:A.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),A}}let rC=0;class YQ{constructor(A=null){this.isSource=!0,Object.defineProperty(this,"id",{value:rC++}),this.uuid=QI(),this.data=A,this.dataReady=!0,this.version=0}set needsUpdate(A){A===!0&&this.version++}toJSON(A){const g=A===void 0||typeof A=="string";if(!g&&A.images[this.uuid]!==void 0)return A.images[this.uuid];const I={uuid:this.uuid,url:""},B=this.data;if(B!==null){let Q;if(Array.isArray(B)){Q=[];for(let t=0,C=B.length;t<C;t++)B[t].isDataTexture?Q.push(lB(B[t].image)):Q.push(lB(B[t]))}else Q=lB(B);I.url=Q}return g||(A.images[this.uuid]=I),I}}function lB(E){return typeof HTMLImageElement<"u"&&E instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&E instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&E instanceof ImageBitmap?oC.getDataURL(E):E.data?{data:Array.from(E.data),width:E.width,height:E.height,type:E.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let hC=0;class vA extends BI{constructor(A=vA.DEFAULT_IMAGE,g=vA.DEFAULT_MAPPING,I=gI,B=gI,Q=GQ,t=CC,C=pI,i=kI,s=vA.DEFAULT_ANISOTROPY,a=NQ){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:hC++}),this.uuid=QI(),this.name="",this.source=new YQ(A),this.mipmaps=[],this.mapping=g,this.channel=0,this.wrapS=I,this.wrapT=B,this.magFilter=Q,this.minFilter=t,this.anisotropy=s,this.format=C,this.internalFormat=null,this.type=i,this.offset=new dA(0,0),this.repeat=new dA(1,1),this.center=new dA(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new TA,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=a,this.userData={},this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(A=null){this.source.data=A}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(A){return this.name=A.name,this.source=A.source,this.mipmaps=A.mipmaps.slice(0),this.mapping=A.mapping,this.channel=A.channel,this.wrapS=A.wrapS,this.wrapT=A.wrapT,this.magFilter=A.magFilter,this.minFilter=A.minFilter,this.anisotropy=A.anisotropy,this.format=A.format,this.internalFormat=A.internalFormat,this.type=A.type,this.offset.copy(A.offset),this.repeat.copy(A.repeat),this.center.copy(A.center),this.rotation=A.rotation,this.matrixAutoUpdate=A.matrixAutoUpdate,this.matrix.copy(A.matrix),this.generateMipmaps=A.generateMipmaps,this.premultiplyAlpha=A.premultiplyAlpha,this.flipY=A.flipY,this.unpackAlignment=A.unpackAlignment,this.colorSpace=A.colorSpace,this.renderTarget=A.renderTarget,this.isRenderTargetTexture=A.isRenderTargetTexture,this.userData=JSON.parse(JSON.stringify(A.userData)),this.needsUpdate=!0,this}toJSON(A){const g=A===void 0||typeof A=="string";if(!g&&A.textures[this.uuid]!==void 0)return A.textures[this.uuid];const I={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(A).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(I.userData=this.userData),g||(A.textures[this.uuid]=I),I}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(A){if(this.mapping!==uQ)return A;if(A.applyMatrix3(this.matrix),A.x<0||A.x>1)switch(this.wrapS){case dQ:A.x=A.x-Math.floor(A.x);break;case gI:A.x=A.x<0?0:1;break;case MQ:Math.abs(Math.floor(A.x)%2)===1?A.x=Math.ceil(A.x)-A.x:A.x=A.x-Math.floor(A.x);break}if(A.y<0||A.y>1)switch(this.wrapT){case dQ:A.y=A.y-Math.floor(A.y);break;case gI:A.y=A.y<0?0:1;break;case MQ:Math.abs(Math.floor(A.y)%2)===1?A.y=Math.ceil(A.y)-A.y:A.y=A.y-Math.floor(A.y);break}return this.flipY&&(A.y=1-A.y),A}set needsUpdate(A){A===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(A){A===!0&&this.pmremVersion++}}vA.DEFAULT_IMAGE=null,vA.DEFAULT_MAPPING=uQ,vA.DEFAULT_ANISOTROPY=1;class lA{constructor(A=0,g=0,I=0,B=1){lA.prototype.isVector4=!0,this.x=A,this.y=g,this.z=I,this.w=B}get width(){return this.z}set width(A){this.z=A}get height(){return this.w}set height(A){this.w=A}set(A,g,I,B){return this.x=A,this.y=g,this.z=I,this.w=B,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this.w=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setW(A){return this.w=A,this}setComponent(A,g){switch(A){case 0:this.x=g;break;case 1:this.y=g;break;case 2:this.z=g;break;case 3:this.w=g;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this.w=A.w!==void 0?A.w:1,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this.w+=A.w,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this.w+=A,this}addVectors(A,g){return this.x=A.x+g.x,this.y=A.y+g.y,this.z=A.z+g.z,this.w=A.w+g.w,this}addScaledVector(A,g){return this.x+=A.x*g,this.y+=A.y*g,this.z+=A.z*g,this.w+=A.w*g,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this.w-=A.w,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this.w-=A,this}subVectors(A,g){return this.x=A.x-g.x,this.y=A.y-g.y,this.z=A.z-g.z,this.w=A.w-g.w,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this.w*=A.w,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this.w*=A,this}applyMatrix4(A){const g=this.x,I=this.y,B=this.z,Q=this.w,t=A.elements;return this.x=t[0]*g+t[4]*I+t[8]*B+t[12]*Q,this.y=t[1]*g+t[5]*I+t[9]*B+t[13]*Q,this.z=t[2]*g+t[6]*I+t[10]*B+t[14]*Q,this.w=t[3]*g+t[7]*I+t[11]*B+t[15]*Q,this}divide(A){return this.x/=A.x,this.y/=A.y,this.z/=A.z,this.w/=A.w,this}divideScalar(A){return this.multiplyScalar(1/A)}setAxisAngleFromQuaternion(A){this.w=2*Math.acos(A.w);const g=Math.sqrt(1-A.w*A.w);return g<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=A.x/g,this.y=A.y/g,this.z=A.z/g),this}setAxisAngleFromRotationMatrix(A){let g,I,B,Q;const i=A.elements,s=i[0],a=i[4],e=i[8],n=i[1],o=i[5],r=i[9],h=i[2],c=i[6],w=i[10];if(Math.abs(a-n)<.01&&Math.abs(e-h)<.01&&Math.abs(r-c)<.01){if(Math.abs(a+n)<.1&&Math.abs(e+h)<.1&&Math.abs(r+c)<.1&&Math.abs(s+o+w-3)<.1)return this.set(1,0,0,0),this;g=Math.PI;const l=(s+1)/2,u=(o+1)/2,M=(w+1)/2,F=(a+n)/4,p=(e+h)/4,d=(r+c)/4;return l>u&&l>M?l<.01?(I=0,B=.707106781,Q=.707106781):(I=Math.sqrt(l),B=F/I,Q=p/I):u>M?u<.01?(I=.707106781,B=0,Q=.707106781):(B=Math.sqrt(u),I=F/B,Q=d/B):M<.01?(I=.707106781,B=.707106781,Q=0):(Q=Math.sqrt(M),I=p/Q,B=d/Q),this.set(I,B,Q,g),this}let y=Math.sqrt((c-r)*(c-r)+(e-h)*(e-h)+(n-a)*(n-a));return Math.abs(y)<.001&&(y=1),this.x=(c-r)/y,this.y=(e-h)/y,this.z=(n-a)/y,this.w=Math.acos((s+o+w-1)/2),this}setFromMatrixPosition(A){const g=A.elements;return this.x=g[12],this.y=g[13],this.z=g[14],this.w=g[15],this}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this.w=Math.min(this.w,A.w),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this.w=Math.max(this.w,A.w),this}clamp(A,g){return this.x=H(this.x,A.x,g.x),this.y=H(this.y,A.y,g.y),this.z=H(this.z,A.z,g.z),this.w=H(this.w,A.w,g.w),this}clampScalar(A,g){return this.x=H(this.x,A,g),this.y=H(this.y,A,g),this.z=H(this.z,A,g),this.w=H(this.w,A,g),this}clampLength(A,g){const I=this.length();return this.divideScalar(I||1).multiplyScalar(H(I,A,g))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z+this.w*A.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,g){return this.x+=(A.x-this.x)*g,this.y+=(A.y-this.y)*g,this.z+=(A.z-this.z)*g,this.w+=(A.w-this.w)*g,this}lerpVectors(A,g,I){return this.x=A.x+(g.x-A.x)*I,this.y=A.y+(g.y-A.y)*I,this.z=A.z+(g.z-A.z)*I,this.w=A.w+(g.w-A.w)*I,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z&&A.w===this.w}fromArray(A,g=0){return this.x=A[g],this.y=A[g+1],this.z=A[g+2],this.w=A[g+3],this}toArray(A=[],g=0){return A[g]=this.x,A[g+1]=this.y,A[g+2]=this.z,A[g+3]=this.w,A}fromBufferAttribute(A,g){return this.x=A.getX(g),this.y=A.getY(g),this.z=A.getZ(g),this.w=A.getW(g),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class cC extends BI{constructor(A=1,g=1,I={}){super(),this.isRenderTarget=!0,this.width=A,this.height=g,this.depth=1,this.scissor=new lA(0,0,A,g),this.scissorTest=!1,this.viewport=new lA(0,0,A,g);const B={width:A,height:g,depth:1};I=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:GQ,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},I);const Q=new vA(B,I.mapping,I.wrapS,I.wrapT,I.magFilter,I.minFilter,I.format,I.type,I.anisotropy,I.colorSpace);Q.flipY=!1,Q.generateMipmaps=I.generateMipmaps,Q.internalFormat=I.internalFormat,this.textures=[];const t=I.count;for(let C=0;C<t;C++)this.textures[C]=Q.clone(),this.textures[C].isRenderTargetTexture=!0,this.textures[C].renderTarget=this;this.depthBuffer=I.depthBuffer,this.stencilBuffer=I.stencilBuffer,this.resolveDepthBuffer=I.resolveDepthBuffer,this.resolveStencilBuffer=I.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=I.depthTexture,this.samples=I.samples}get texture(){return this.textures[0]}set texture(A){this.textures[0]=A}set depthTexture(A){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),A!==null&&(A.renderTarget=this),this._depthTexture=A}get depthTexture(){return this._depthTexture}setSize(A,g,I=1){if(this.width!==A||this.height!==g||this.depth!==I){this.width=A,this.height=g,this.depth=I;for(let B=0,Q=this.textures.length;B<Q;B++)this.textures[B].image.width=A,this.textures[B].image.height=g,this.textures[B].image.depth=I;this.dispose()}this.viewport.set(0,0,A,g),this.scissor.set(0,0,A,g)}clone(){return new this.constructor().copy(this)}copy(A){this.width=A.width,this.height=A.height,this.depth=A.depth,this.scissor.copy(A.scissor),this.scissorTest=A.scissorTest,this.viewport.copy(A.viewport),this.textures.length=0;for(let I=0,B=A.textures.length;I<B;I++)this.textures[I]=A.textures[I].clone(),this.textures[I].isRenderTargetTexture=!0,this.textures[I].renderTarget=this;const g=Object.assign({},A.texture.image);return this.texture.source=new YQ(g),this.depthBuffer=A.depthBuffer,this.stencilBuffer=A.stencilBuffer,this.resolveDepthBuffer=A.resolveDepthBuffer,this.resolveStencilBuffer=A.resolveStencilBuffer,A.depthTexture!==null&&(this.depthTexture=A.depthTexture.clone()),this.samples=A.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class wC extends cC{constructor(A=1,g=1,I={}){super(A,g,I),this.isWebGLRenderTarget=!0}}class Eg extends vA{constructor(A=null,g=1,I=1,B=1){super(null),this.isDataArrayTexture=!0,this.image={data:A,width:g,height:I,depth:B},this.magFilter=Cg,this.minFilter=Cg,this.wrapR=gI,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(A){this.layerUpdates.add(A)}clearLayerUpdates(){this.layerUpdates.clear()}}class xQ extends wC{constructor(A=1,g=1,I=1,B={}){super(A,g,B),this.isWebGLArrayRenderTarget=!0,this.depth=I,this.texture=new Eg(null,A,g,I),this.texture.isRenderTargetTexture=!0}}class sA{constructor(A=0,g=0,I=0,B=1){this.isQuaternion=!0,this._x=A,this._y=g,this._z=I,this._w=B}static slerpFlat(A,g,I,B,Q,t,C){let i=I[B+0],s=I[B+1],a=I[B+2],e=I[B+3];const n=Q[t+0],o=Q[t+1],r=Q[t+2],h=Q[t+3];if(C===0){A[g+0]=i,A[g+1]=s,A[g+2]=a,A[g+3]=e;return}if(C===1){A[g+0]=n,A[g+1]=o,A[g+2]=r,A[g+3]=h;return}if(e!==h||i!==n||s!==o||a!==r){let c=1-C;const w=i*n+s*o+a*r+e*h,y=w>=0?1:-1,l=1-w*w;if(l>Number.EPSILON){const M=Math.sqrt(l),F=Math.atan2(M,w*y);c=Math.sin(c*F)/M,C=Math.sin(C*F)/M}const u=C*y;if(i=i*c+n*u,s=s*c+o*u,a=a*c+r*u,e=e*c+h*u,c===1-C){const M=1/Math.sqrt(i*i+s*s+a*a+e*e);i*=M,s*=M,a*=M,e*=M}}A[g]=i,A[g+1]=s,A[g+2]=a,A[g+3]=e}static multiplyQuaternionsFlat(A,g,I,B,Q,t){const C=I[B],i=I[B+1],s=I[B+2],a=I[B+3],e=Q[t],n=Q[t+1],o=Q[t+2],r=Q[t+3];return A[g]=C*r+a*e+i*o-s*n,A[g+1]=i*r+a*n+s*e-C*o,A[g+2]=s*r+a*o+C*n-i*e,A[g+3]=a*r-C*e-i*n-s*o,A}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get w(){return this._w}set w(A){this._w=A,this._onChangeCallback()}set(A,g,I,B){return this._x=A,this._y=g,this._z=I,this._w=B,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(A){return this._x=A.x,this._y=A.y,this._z=A.z,this._w=A.w,this._onChangeCallback(),this}setFromEuler(A,g=!0){const I=A._x,B=A._y,Q=A._z,t=A._order,C=Math.cos,i=Math.sin,s=C(I/2),a=C(B/2),e=C(Q/2),n=i(I/2),o=i(B/2),r=i(Q/2);switch(t){case"XYZ":this._x=n*a*e+s*o*r,this._y=s*o*e-n*a*r,this._z=s*a*r+n*o*e,this._w=s*a*e-n*o*r;break;case"YXZ":this._x=n*a*e+s*o*r,this._y=s*o*e-n*a*r,this._z=s*a*r-n*o*e,this._w=s*a*e+n*o*r;break;case"ZXY":this._x=n*a*e-s*o*r,this._y=s*o*e+n*a*r,this._z=s*a*r+n*o*e,this._w=s*a*e-n*o*r;break;case"ZYX":this._x=n*a*e-s*o*r,this._y=s*o*e+n*a*r,this._z=s*a*r-n*o*e,this._w=s*a*e+n*o*r;break;case"YZX":this._x=n*a*e+s*o*r,this._y=s*o*e+n*a*r,this._z=s*a*r-n*o*e,this._w=s*a*e-n*o*r;break;case"XZY":this._x=n*a*e-s*o*r,this._y=s*o*e-n*a*r,this._z=s*a*r+n*o*e,this._w=s*a*e+n*o*r;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+t)}return g===!0&&this._onChangeCallback(),this}setFromAxisAngle(A,g){const I=g/2,B=Math.sin(I);return this._x=A.x*B,this._y=A.y*B,this._z=A.z*B,this._w=Math.cos(I),this._onChangeCallback(),this}setFromRotationMatrix(A){const g=A.elements,I=g[0],B=g[4],Q=g[8],t=g[1],C=g[5],i=g[9],s=g[2],a=g[6],e=g[10],n=I+C+e;if(n>0){const o=.5/Math.sqrt(n+1);this._w=.25/o,this._x=(a-i)*o,this._y=(Q-s)*o,this._z=(t-B)*o}else if(I>C&&I>e){const o=2*Math.sqrt(1+I-C-e);this._w=(a-i)/o,this._x=.25*o,this._y=(B+t)/o,this._z=(Q+s)/o}else if(C>e){const o=2*Math.sqrt(1+C-I-e);this._w=(Q-s)/o,this._x=(B+t)/o,this._y=.25*o,this._z=(i+a)/o}else{const o=2*Math.sqrt(1+e-I-C);this._w=(t-B)/o,this._x=(Q+s)/o,this._y=(i+a)/o,this._z=.25*o}return this._onChangeCallback(),this}setFromUnitVectors(A,g){let I=A.dot(g)+1;return I<Number.EPSILON?(I=0,Math.abs(A.x)>Math.abs(A.z)?(this._x=-A.y,this._y=A.x,this._z=0,this._w=I):(this._x=0,this._y=-A.z,this._z=A.y,this._w=I)):(this._x=A.y*g.z-A.z*g.y,this._y=A.z*g.x-A.x*g.z,this._z=A.x*g.y-A.y*g.x,this._w=I),this.normalize()}angleTo(A){return 2*Math.acos(Math.abs(H(this.dot(A),-1,1)))}rotateTowards(A,g){const I=this.angleTo(A);if(I===0)return this;const B=Math.min(1,g/I);return this.slerp(A,B),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(A){return this._x*A._x+this._y*A._y+this._z*A._z+this._w*A._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let A=this.length();return A===0?(this._x=0,this._y=0,this._z=0,this._w=1):(A=1/A,this._x=this._x*A,this._y=this._y*A,this._z=this._z*A,this._w=this._w*A),this._onChangeCallback(),this}multiply(A){return this.multiplyQuaternions(this,A)}premultiply(A){return this.multiplyQuaternions(A,this)}multiplyQuaternions(A,g){const I=A._x,B=A._y,Q=A._z,t=A._w,C=g._x,i=g._y,s=g._z,a=g._w;return this._x=I*a+t*C+B*s-Q*i,this._y=B*a+t*i+Q*C-I*s,this._z=Q*a+t*s+I*i-B*C,this._w=t*a-I*C-B*i-Q*s,this._onChangeCallback(),this}slerp(A,g){if(g===0)return this;if(g===1)return this.copy(A);const I=this._x,B=this._y,Q=this._z,t=this._w;let C=t*A._w+I*A._x+B*A._y+Q*A._z;if(C<0?(this._w=-A._w,this._x=-A._x,this._y=-A._y,this._z=-A._z,C=-C):this.copy(A),C>=1)return this._w=t,this._x=I,this._y=B,this._z=Q,this;const i=1-C*C;if(i<=Number.EPSILON){const o=1-g;return this._w=o*t+g*this._w,this._x=o*I+g*this._x,this._y=o*B+g*this._y,this._z=o*Q+g*this._z,this.normalize(),this}const s=Math.sqrt(i),a=Math.atan2(s,C),e=Math.sin((1-g)*a)/s,n=Math.sin(g*a)/s;return this._w=t*e+this._w*n,this._x=I*e+this._x*n,this._y=B*e+this._y*n,this._z=Q*e+this._z*n,this._onChangeCallback(),this}slerpQuaternions(A,g,I){return this.copy(A).slerp(g,I)}random(){const A=2*Math.PI*Math.random(),g=2*Math.PI*Math.random(),I=Math.random(),B=Math.sqrt(1-I),Q=Math.sqrt(I);return this.set(B*Math.sin(A),B*Math.cos(A),Q*Math.sin(g),Q*Math.cos(g))}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._w===this._w}fromArray(A,g=0){return this._x=A[g],this._y=A[g+1],this._z=A[g+2],this._w=A[g+3],this._onChangeCallback(),this}toArray(A=[],g=0){return A[g]=this._x,A[g+1]=this._y,A[g+2]=this._z,A[g+3]=this._w,A}fromBufferAttribute(A,g){return this._x=A.getX(g),this._y=A.getY(g),this._z=A.getZ(g),this._w=A.getW(g),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class D{constructor(A=0,g=0,I=0){D.prototype.isVector3=!0,this.x=A,this.y=g,this.z=I}set(A,g,I){return I===void 0&&(I=this.z),this.x=A,this.y=g,this.z=I,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setComponent(A,g){switch(A){case 0:this.x=g;break;case 1:this.y=g;break;case 2:this.z=g;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this}addVectors(A,g){return this.x=A.x+g.x,this.y=A.y+g.y,this.z=A.z+g.z,this}addScaledVector(A,g){return this.x+=A.x*g,this.y+=A.y*g,this.z+=A.z*g,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this}subVectors(A,g){return this.x=A.x-g.x,this.y=A.y-g.y,this.z=A.z-g.z,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this}multiplyVectors(A,g){return this.x=A.x*g.x,this.y=A.y*g.y,this.z=A.z*g.z,this}applyEuler(A){return this.applyQuaternion(UQ.setFromEuler(A))}applyAxisAngle(A,g){return this.applyQuaternion(UQ.setFromAxisAngle(A,g))}applyMatrix3(A){const g=this.x,I=this.y,B=this.z,Q=A.elements;return this.x=Q[0]*g+Q[3]*I+Q[6]*B,this.y=Q[1]*g+Q[4]*I+Q[7]*B,this.z=Q[2]*g+Q[5]*I+Q[8]*B,this}applyNormalMatrix(A){return this.applyMatrix3(A).normalize()}applyMatrix4(A){const g=this.x,I=this.y,B=this.z,Q=A.elements,t=1/(Q[3]*g+Q[7]*I+Q[11]*B+Q[15]);return this.x=(Q[0]*g+Q[4]*I+Q[8]*B+Q[12])*t,this.y=(Q[1]*g+Q[5]*I+Q[9]*B+Q[13])*t,this.z=(Q[2]*g+Q[6]*I+Q[10]*B+Q[14])*t,this}applyQuaternion(A){const g=this.x,I=this.y,B=this.z,Q=A.x,t=A.y,C=A.z,i=A.w,s=2*(t*B-C*I),a=2*(C*g-Q*B),e=2*(Q*I-t*g);return this.x=g+i*s+t*e-C*a,this.y=I+i*a+C*s-Q*e,this.z=B+i*e+Q*a-t*s,this}project(A){return this.applyMatrix4(A.matrixWorldInverse).applyMatrix4(A.projectionMatrix)}unproject(A){return this.applyMatrix4(A.projectionMatrixInverse).applyMatrix4(A.matrixWorld)}transformDirection(A){const g=this.x,I=this.y,B=this.z,Q=A.elements;return this.x=Q[0]*g+Q[4]*I+Q[8]*B,this.y=Q[1]*g+Q[5]*I+Q[9]*B,this.z=Q[2]*g+Q[6]*I+Q[10]*B,this.normalize()}divide(A){return this.x/=A.x,this.y/=A.y,this.z/=A.z,this}divideScalar(A){return this.multiplyScalar(1/A)}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this}clamp(A,g){return this.x=H(this.x,A.x,g.x),this.y=H(this.y,A.y,g.y),this.z=H(this.z,A.z,g.z),this}clampScalar(A,g){return this.x=H(this.x,A,g),this.y=H(this.y,A,g),this.z=H(this.z,A,g),this}clampLength(A,g){const I=this.length();return this.divideScalar(I||1).multiplyScalar(H(I,A,g))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,g){return this.x+=(A.x-this.x)*g,this.y+=(A.y-this.y)*g,this.z+=(A.z-this.z)*g,this}lerpVectors(A,g,I){return this.x=A.x+(g.x-A.x)*I,this.y=A.y+(g.y-A.y)*I,this.z=A.z+(g.z-A.z)*I,this}cross(A){return this.crossVectors(this,A)}crossVectors(A,g){const I=A.x,B=A.y,Q=A.z,t=g.x,C=g.y,i=g.z;return this.x=B*i-Q*C,this.y=Q*t-I*i,this.z=I*C-B*t,this}projectOnVector(A){const g=A.lengthSq();if(g===0)return this.set(0,0,0);const I=A.dot(this)/g;return this.copy(A).multiplyScalar(I)}projectOnPlane(A){return yB.copy(this).projectOnVector(A),this.sub(yB)}reflect(A){return this.sub(yB.copy(A).multiplyScalar(2*this.dot(A)))}angleTo(A){const g=Math.sqrt(this.lengthSq()*A.lengthSq());if(g===0)return Math.PI/2;const I=this.dot(A)/g;return Math.acos(H(I,-1,1))}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const g=this.x-A.x,I=this.y-A.y,B=this.z-A.z;return g*g+I*I+B*B}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)+Math.abs(this.z-A.z)}setFromSpherical(A){return this.setFromSphericalCoords(A.radius,A.phi,A.theta)}setFromSphericalCoords(A,g,I){const B=Math.sin(g)*A;return this.x=B*Math.sin(I),this.y=Math.cos(g)*A,this.z=B*Math.cos(I),this}setFromCylindrical(A){return this.setFromCylindricalCoords(A.radius,A.theta,A.y)}setFromCylindricalCoords(A,g,I){return this.x=A*Math.sin(g),this.y=I,this.z=A*Math.cos(g),this}setFromMatrixPosition(A){const g=A.elements;return this.x=g[12],this.y=g[13],this.z=g[14],this}setFromMatrixScale(A){const g=this.setFromMatrixColumn(A,0).length(),I=this.setFromMatrixColumn(A,1).length(),B=this.setFromMatrixColumn(A,2).length();return this.x=g,this.y=I,this.z=B,this}setFromMatrixColumn(A,g){return this.fromArray(A.elements,g*4)}setFromMatrix3Column(A,g){return this.fromArray(A.elements,g*3)}setFromEuler(A){return this.x=A._x,this.y=A._y,this.z=A._z,this}setFromColor(A){return this.x=A.r,this.y=A.g,this.z=A.b,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z}fromArray(A,g=0){return this.x=A[g],this.y=A[g+1],this.z=A[g+2],this}toArray(A=[],g=0){return A[g]=this.x,A[g+1]=this.y,A[g+2]=this.z,A}fromBufferAttribute(A,g){return this.x=A.getX(g),this.y=A.getY(g),this.z=A.getZ(g),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const A=Math.random()*Math.PI*2,g=Math.random()*2-1,I=Math.sqrt(1-g*g);return this.x=I*Math.cos(A),this.y=g,this.z=I*Math.sin(A),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const yB=new D,UQ=new sA;class Rg{constructor(A=new D(1/0,1/0,1/0),g=new D(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=A,this.max=g}set(A,g){return this.min.copy(A),this.max.copy(g),this}setFromArray(A){this.makeEmpty();for(let g=0,I=A.length;g<I;g+=3)this.expandByPoint(HA.fromArray(A,g));return this}setFromBufferAttribute(A){this.makeEmpty();for(let g=0,I=A.count;g<I;g++)this.expandByPoint(HA.fromBufferAttribute(A,g));return this}setFromPoints(A){this.makeEmpty();for(let g=0,I=A.length;g<I;g++)this.expandByPoint(A[g]);return this}setFromCenterAndSize(A,g){const I=HA.copy(g).multiplyScalar(.5);return this.min.copy(A).sub(I),this.max.copy(A).add(I),this}setFromObject(A,g=!1){return this.makeEmpty(),this.expandByObject(A,g)}clone(){return new this.constructor().copy(this)}copy(A){return this.min.copy(A.min),this.max.copy(A.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(A){return this.isEmpty()?A.set(0,0,0):A.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(A){return this.isEmpty()?A.set(0,0,0):A.subVectors(this.max,this.min)}expandByPoint(A){return this.min.min(A),this.max.max(A),this}expandByVector(A){return this.min.sub(A),this.max.add(A),this}expandByScalar(A){return this.min.addScalar(-A),this.max.addScalar(A),this}expandByObject(A,g=!1){A.updateWorldMatrix(!1,!1);const I=A.geometry;if(I!==void 0){const Q=I.getAttribute("position");if(g===!0&&Q!==void 0&&A.isInstancedMesh!==!0)for(let t=0,C=Q.count;t<C;t++)A.isMesh===!0?A.getVertexPosition(t,HA):HA.fromBufferAttribute(Q,t),HA.applyMatrix4(A.matrixWorld),this.expandByPoint(HA);else A.boundingBox!==void 0?(A.boundingBox===null&&A.computeBoundingBox(),fI.copy(A.boundingBox)):(I.boundingBox===null&&I.computeBoundingBox(),fI.copy(I.boundingBox)),fI.applyMatrix4(A.matrixWorld),this.union(fI)}const B=A.children;for(let Q=0,t=B.length;Q<t;Q++)this.expandByObject(B[Q],g);return this}containsPoint(A){return A.x>=this.min.x&&A.x<=this.max.x&&A.y>=this.min.y&&A.y<=this.max.y&&A.z>=this.min.z&&A.z<=this.max.z}containsBox(A){return this.min.x<=A.min.x&&A.max.x<=this.max.x&&this.min.y<=A.min.y&&A.max.y<=this.max.y&&this.min.z<=A.min.z&&A.max.z<=this.max.z}getParameter(A,g){return g.set((A.x-this.min.x)/(this.max.x-this.min.x),(A.y-this.min.y)/(this.max.y-this.min.y),(A.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(A){return A.max.x>=this.min.x&&A.min.x<=this.max.x&&A.max.y>=this.min.y&&A.min.y<=this.max.y&&A.max.z>=this.min.z&&A.min.z<=this.max.z}intersectsSphere(A){return this.clampPoint(A.center,HA),HA.distanceToSquared(A.center)<=A.radius*A.radius}intersectsPlane(A){let g,I;return A.normal.x>0?(g=A.normal.x*this.min.x,I=A.normal.x*this.max.x):(g=A.normal.x*this.max.x,I=A.normal.x*this.min.x),A.normal.y>0?(g+=A.normal.y*this.min.y,I+=A.normal.y*this.max.y):(g+=A.normal.y*this.max.y,I+=A.normal.y*this.min.y),A.normal.z>0?(g+=A.normal.z*this.min.z,I+=A.normal.z*this.max.z):(g+=A.normal.z*this.max.z,I+=A.normal.z*this.min.z),g<=-A.constant&&I>=-A.constant}intersectsTriangle(A){if(this.isEmpty())return!1;this.getCenter(CI),RI.subVectors(this.max,CI),Jg.subVectors(A.a,CI),mg.subVectors(A.b,CI),Sg.subVectors(A.c,CI),ig.subVectors(mg,Jg),sg.subVectors(Sg,mg),Dg.subVectors(Jg,Sg);let g=[0,-ig.z,ig.y,0,-sg.z,sg.y,0,-Dg.z,Dg.y,ig.z,0,-ig.x,sg.z,0,-sg.x,Dg.z,0,-Dg.x,-ig.y,ig.x,0,-sg.y,sg.x,0,-Dg.y,Dg.x,0];return!uB(g,Jg,mg,Sg,RI)||(g=[1,0,0,0,1,0,0,0,1],!uB(g,Jg,mg,Sg,RI))?!1:(JI.crossVectors(ig,sg),g=[JI.x,JI.y,JI.z],uB(g,Jg,mg,Sg,RI))}clampPoint(A,g){return g.copy(A).clamp(this.min,this.max)}distanceToPoint(A){return this.clampPoint(A,HA).distanceTo(A)}getBoundingSphere(A){return this.isEmpty()?A.makeEmpty():(this.getCenter(A.center),A.radius=this.getSize(HA).length()*.5),A}intersect(A){return this.min.max(A.min),this.max.min(A.max),this.isEmpty()&&this.makeEmpty(),this}union(A){return this.min.min(A.min),this.max.max(A.max),this}applyMatrix4(A){return this.isEmpty()?this:(jA[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(A),jA[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(A),jA[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(A),jA[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(A),jA[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(A),jA[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(A),jA[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(A),jA[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(A),this.setFromPoints(jA),this)}translate(A){return this.min.add(A),this.max.add(A),this}equals(A){return A.min.equals(this.min)&&A.max.equals(this.max)}}const jA=[new D,new D,new D,new D,new D,new D,new D,new D],HA=new D,fI=new Rg,Jg=new D,mg=new D,Sg=new D,ig=new D,sg=new D,Dg=new D,CI=new D,RI=new D,JI=new D,lg=new D;function uB(E,A,g,I,B){for(let Q=0,t=E.length-3;Q<=t;Q+=3){lg.fromArray(E,Q);const C=B.x*Math.abs(lg.x)+B.y*Math.abs(lg.y)+B.z*Math.abs(lg.z),i=A.dot(lg),s=g.dot(lg),a=I.dot(lg);if(Math.max(-Math.max(i,s,a),Math.min(i,s,a))>C)return!1}return!0}const DC=new Rg,EI=new D,dB=new D;class LQ{constructor(A=new D,g=-1){this.isSphere=!0,this.center=A,this.radius=g}set(A,g){return this.center.copy(A),this.radius=g,this}setFromPoints(A,g){const I=this.center;g!==void 0?I.copy(g):DC.setFromPoints(A).getCenter(I);let B=0;for(let Q=0,t=A.length;Q<t;Q++)B=Math.max(B,I.distanceToSquared(A[Q]));return this.radius=Math.sqrt(B),this}copy(A){return this.center.copy(A.center),this.radius=A.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(A){return A.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(A){return A.distanceTo(this.center)-this.radius}intersectsSphere(A){const g=this.radius+A.radius;return A.center.distanceToSquared(this.center)<=g*g}intersectsBox(A){return A.intersectsSphere(this)}intersectsPlane(A){return Math.abs(A.distanceToPoint(this.center))<=this.radius}clampPoint(A,g){const I=this.center.distanceToSquared(A);return g.copy(A),I>this.radius*this.radius&&(g.sub(this.center).normalize(),g.multiplyScalar(this.radius).add(this.center)),g}getBoundingBox(A){return this.isEmpty()?(A.makeEmpty(),A):(A.set(this.center,this.center),A.expandByScalar(this.radius),A)}applyMatrix4(A){return this.center.applyMatrix4(A),this.radius=this.radius*A.getMaxScaleOnAxis(),this}translate(A){return this.center.add(A),this}expandByPoint(A){if(this.isEmpty())return this.center.copy(A),this.radius=0,this;EI.subVectors(A,this.center);const g=EI.lengthSq();if(g>this.radius*this.radius){const I=Math.sqrt(g),B=(I-this.radius)*.5;this.center.addScaledVector(EI,B/I),this.radius+=B}return this}union(A){return A.isEmpty()?this:this.isEmpty()?(this.copy(A),this):(this.center.equals(A.center)===!0?this.radius=Math.max(this.radius,A.radius):(dB.subVectors(A.center,this.center).setLength(A.radius),this.expandByPoint(EI.copy(A.center).add(dB)),this.expandByPoint(EI.copy(A.center).sub(dB))),this)}equals(A){return A.center.equals(this.center)&&A.radius===this.radius}clone(){return new this.constructor().copy(this)}}const OA=new D,MB=new D,mI=new D,eg=new D,GB=new D,SI=new D,NB=new D;class lC{constructor(A=new D,g=new D(0,0,-1)){this.origin=A,this.direction=g}set(A,g){return this.origin.copy(A),this.direction.copy(g),this}copy(A){return this.origin.copy(A.origin),this.direction.copy(A.direction),this}at(A,g){return g.copy(this.origin).addScaledVector(this.direction,A)}lookAt(A){return this.direction.copy(A).sub(this.origin).normalize(),this}recast(A){return this.origin.copy(this.at(A,OA)),this}closestPointToPoint(A,g){g.subVectors(A,this.origin);const I=g.dot(this.direction);return I<0?g.copy(this.origin):g.copy(this.origin).addScaledVector(this.direction,I)}distanceToPoint(A){return Math.sqrt(this.distanceSqToPoint(A))}distanceSqToPoint(A){const g=OA.subVectors(A,this.origin).dot(this.direction);return g<0?this.origin.distanceToSquared(A):(OA.copy(this.origin).addScaledVector(this.direction,g),OA.distanceToSquared(A))}distanceSqToSegment(A,g,I,B){MB.copy(A).add(g).multiplyScalar(.5),mI.copy(g).sub(A).normalize(),eg.copy(this.origin).sub(MB);const Q=A.distanceTo(g)*.5,t=-this.direction.dot(mI),C=eg.dot(this.direction),i=-eg.dot(mI),s=eg.lengthSq(),a=Math.abs(1-t*t);let e,n,o,r;if(a>0)if(e=t*i-C,n=t*C-i,r=Q*a,e>=0)if(n>=-r)if(n<=r){const h=1/a;e*=h,n*=h,o=e*(e+t*n+2*C)+n*(t*e+n+2*i)+s}else n=Q,e=Math.max(0,-(t*n+C)),o=-e*e+n*(n+2*i)+s;else n=-Q,e=Math.max(0,-(t*n+C)),o=-e*e+n*(n+2*i)+s;else n<=-r?(e=Math.max(0,-(-t*Q+C)),n=e>0?-Q:Math.min(Math.max(-Q,-i),Q),o=-e*e+n*(n+2*i)+s):n<=r?(e=0,n=Math.min(Math.max(-Q,-i),Q),o=n*(n+2*i)+s):(e=Math.max(0,-(t*Q+C)),n=e>0?Q:Math.min(Math.max(-Q,-i),Q),o=-e*e+n*(n+2*i)+s);else n=t>0?-Q:Q,e=Math.max(0,-(t*n+C)),o=-e*e+n*(n+2*i)+s;return I&&I.copy(this.origin).addScaledVector(this.direction,e),B&&B.copy(MB).addScaledVector(mI,n),o}intersectSphere(A,g){OA.subVectors(A.center,this.origin);const I=OA.dot(this.direction),B=OA.dot(OA)-I*I,Q=A.radius*A.radius;if(B>Q)return null;const t=Math.sqrt(Q-B),C=I-t,i=I+t;return i<0?null:C<0?this.at(i,g):this.at(C,g)}intersectsSphere(A){return this.distanceSqToPoint(A.center)<=A.radius*A.radius}distanceToPlane(A){const g=A.normal.dot(this.direction);if(g===0)return A.distanceToPoint(this.origin)===0?0:null;const I=-(this.origin.dot(A.normal)+A.constant)/g;return I>=0?I:null}intersectPlane(A,g){const I=this.distanceToPlane(A);return I===null?null:this.at(I,g)}intersectsPlane(A){const g=A.distanceToPoint(this.origin);return g===0||A.normal.dot(this.direction)*g<0}intersectBox(A,g){let I,B,Q,t,C,i;const s=1/this.direction.x,a=1/this.direction.y,e=1/this.direction.z,n=this.origin;return s>=0?(I=(A.min.x-n.x)*s,B=(A.max.x-n.x)*s):(I=(A.max.x-n.x)*s,B=(A.min.x-n.x)*s),a>=0?(Q=(A.min.y-n.y)*a,t=(A.max.y-n.y)*a):(Q=(A.max.y-n.y)*a,t=(A.min.y-n.y)*a),I>t||Q>B||((Q>I||isNaN(I))&&(I=Q),(t<B||isNaN(B))&&(B=t),e>=0?(C=(A.min.z-n.z)*e,i=(A.max.z-n.z)*e):(C=(A.max.z-n.z)*e,i=(A.min.z-n.z)*e),I>i||C>B)||((C>I||I!==I)&&(I=C),(i<B||B!==B)&&(B=i),B<0)?null:this.at(I>=0?I:B,g)}intersectsBox(A){return this.intersectBox(A,OA)!==null}intersectTriangle(A,g,I,B,Q){GB.subVectors(g,A),SI.subVectors(I,A),NB.crossVectors(GB,SI);let t=this.direction.dot(NB),C;if(t>0){if(B)return null;C=1}else if(t<0)C=-1,t=-t;else return null;eg.subVectors(this.origin,A);const i=C*this.direction.dot(SI.crossVectors(eg,SI));if(i<0)return null;const s=C*this.direction.dot(GB.cross(eg));if(s<0||i+s>t)return null;const a=-C*eg.dot(NB);return a<0?null:this.at(a/t,Q)}applyMatrix4(A){return this.origin.applyMatrix4(A),this.direction.transformDirection(A),this}equals(A){return A.origin.equals(this.origin)&&A.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class cA{constructor(A,g,I,B,Q,t,C,i,s,a,e,n,o,r,h,c){cA.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],A!==void 0&&this.set(A,g,I,B,Q,t,C,i,s,a,e,n,o,r,h,c)}set(A,g,I,B,Q,t,C,i,s,a,e,n,o,r,h,c){const w=this.elements;return w[0]=A,w[4]=g,w[8]=I,w[12]=B,w[1]=Q,w[5]=t,w[9]=C,w[13]=i,w[2]=s,w[6]=a,w[10]=e,w[14]=n,w[3]=o,w[7]=r,w[11]=h,w[15]=c,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new cA().fromArray(this.elements)}copy(A){const g=this.elements,I=A.elements;return g[0]=I[0],g[1]=I[1],g[2]=I[2],g[3]=I[3],g[4]=I[4],g[5]=I[5],g[6]=I[6],g[7]=I[7],g[8]=I[8],g[9]=I[9],g[10]=I[10],g[11]=I[11],g[12]=I[12],g[13]=I[13],g[14]=I[14],g[15]=I[15],this}copyPosition(A){const g=this.elements,I=A.elements;return g[12]=I[12],g[13]=I[13],g[14]=I[14],this}setFromMatrix3(A){const g=A.elements;return this.set(g[0],g[3],g[6],0,g[1],g[4],g[7],0,g[2],g[5],g[8],0,0,0,0,1),this}extractBasis(A,g,I){return A.setFromMatrixColumn(this,0),g.setFromMatrixColumn(this,1),I.setFromMatrixColumn(this,2),this}makeBasis(A,g,I){return this.set(A.x,g.x,I.x,0,A.y,g.y,I.y,0,A.z,g.z,I.z,0,0,0,0,1),this}extractRotation(A){const g=this.elements,I=A.elements,B=1/Yg.setFromMatrixColumn(A,0).length(),Q=1/Yg.setFromMatrixColumn(A,1).length(),t=1/Yg.setFromMatrixColumn(A,2).length();return g[0]=I[0]*B,g[1]=I[1]*B,g[2]=I[2]*B,g[3]=0,g[4]=I[4]*Q,g[5]=I[5]*Q,g[6]=I[6]*Q,g[7]=0,g[8]=I[8]*t,g[9]=I[9]*t,g[10]=I[10]*t,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,this}makeRotationFromEuler(A){const g=this.elements,I=A.x,B=A.y,Q=A.z,t=Math.cos(I),C=Math.sin(I),i=Math.cos(B),s=Math.sin(B),a=Math.cos(Q),e=Math.sin(Q);if(A.order==="XYZ"){const n=t*a,o=t*e,r=C*a,h=C*e;g[0]=i*a,g[4]=-i*e,g[8]=s,g[1]=o+r*s,g[5]=n-h*s,g[9]=-C*i,g[2]=h-n*s,g[6]=r+o*s,g[10]=t*i}else if(A.order==="YXZ"){const n=i*a,o=i*e,r=s*a,h=s*e;g[0]=n+h*C,g[4]=r*C-o,g[8]=t*s,g[1]=t*e,g[5]=t*a,g[9]=-C,g[2]=o*C-r,g[6]=h+n*C,g[10]=t*i}else if(A.order==="ZXY"){const n=i*a,o=i*e,r=s*a,h=s*e;g[0]=n-h*C,g[4]=-t*e,g[8]=r+o*C,g[1]=o+r*C,g[5]=t*a,g[9]=h-n*C,g[2]=-t*s,g[6]=C,g[10]=t*i}else if(A.order==="ZYX"){const n=t*a,o=t*e,r=C*a,h=C*e;g[0]=i*a,g[4]=r*s-o,g[8]=n*s+h,g[1]=i*e,g[5]=h*s+n,g[9]=o*s-r,g[2]=-s,g[6]=C*i,g[10]=t*i}else if(A.order==="YZX"){const n=t*i,o=t*s,r=C*i,h=C*s;g[0]=i*a,g[4]=h-n*e,g[8]=r*e+o,g[1]=e,g[5]=t*a,g[9]=-C*a,g[2]=-s*a,g[6]=o*e+r,g[10]=n-h*e}else if(A.order==="XZY"){const n=t*i,o=t*s,r=C*i,h=C*s;g[0]=i*a,g[4]=-e,g[8]=s*a,g[1]=n*e+h,g[5]=t*a,g[9]=o*e-r,g[2]=r*e-o,g[6]=C*a,g[10]=h*e+n}return g[3]=0,g[7]=0,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,this}makeRotationFromQuaternion(A){return this.compose(yC,A,uC)}lookAt(A,g,I){const B=this.elements;return kA.subVectors(A,g),kA.lengthSq()===0&&(kA.z=1),kA.normalize(),ag.crossVectors(I,kA),ag.lengthSq()===0&&(Math.abs(I.z)===1?kA.x+=1e-4:kA.z+=1e-4,kA.normalize(),ag.crossVectors(I,kA)),ag.normalize(),YI.crossVectors(kA,ag),B[0]=ag.x,B[4]=YI.x,B[8]=kA.x,B[1]=ag.y,B[5]=YI.y,B[9]=kA.y,B[2]=ag.z,B[6]=YI.z,B[10]=kA.z,this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,g){const I=A.elements,B=g.elements,Q=this.elements,t=I[0],C=I[4],i=I[8],s=I[12],a=I[1],e=I[5],n=I[9],o=I[13],r=I[2],h=I[6],c=I[10],w=I[14],y=I[3],l=I[7],u=I[11],M=I[15],F=B[0],p=B[4],d=B[8],G=B[12],f=B[1],N=B[5],k=B[9],R=B[13],J=B[2],m=B[6],S=B[10],Y=B[14],q=B[3],Z=B[7],$=B[11],O=B[15];return Q[0]=t*F+C*f+i*J+s*q,Q[4]=t*p+C*N+i*m+s*Z,Q[8]=t*d+C*k+i*S+s*$,Q[12]=t*G+C*R+i*Y+s*O,Q[1]=a*F+e*f+n*J+o*q,Q[5]=a*p+e*N+n*m+o*Z,Q[9]=a*d+e*k+n*S+o*$,Q[13]=a*G+e*R+n*Y+o*O,Q[2]=r*F+h*f+c*J+w*q,Q[6]=r*p+h*N+c*m+w*Z,Q[10]=r*d+h*k+c*S+w*$,Q[14]=r*G+h*R+c*Y+w*O,Q[3]=y*F+l*f+u*J+M*q,Q[7]=y*p+l*N+u*m+M*Z,Q[11]=y*d+l*k+u*S+M*$,Q[15]=y*G+l*R+u*Y+M*O,this}multiplyScalar(A){const g=this.elements;return g[0]*=A,g[4]*=A,g[8]*=A,g[12]*=A,g[1]*=A,g[5]*=A,g[9]*=A,g[13]*=A,g[2]*=A,g[6]*=A,g[10]*=A,g[14]*=A,g[3]*=A,g[7]*=A,g[11]*=A,g[15]*=A,this}determinant(){const A=this.elements,g=A[0],I=A[4],B=A[8],Q=A[12],t=A[1],C=A[5],i=A[9],s=A[13],a=A[2],e=A[6],n=A[10],o=A[14],r=A[3],h=A[7],c=A[11],w=A[15];return r*(+Q*i*e-B*s*e-Q*C*n+I*s*n+B*C*o-I*i*o)+h*(+g*i*o-g*s*n+Q*t*n-B*t*o+B*s*a-Q*i*a)+c*(+g*s*e-g*C*o-Q*t*e+I*t*o+Q*C*a-I*s*a)+w*(-B*C*a-g*i*e+g*C*n+B*t*e-I*t*n+I*i*a)}transpose(){const A=this.elements;let g;return g=A[1],A[1]=A[4],A[4]=g,g=A[2],A[2]=A[8],A[8]=g,g=A[6],A[6]=A[9],A[9]=g,g=A[3],A[3]=A[12],A[12]=g,g=A[7],A[7]=A[13],A[13]=g,g=A[11],A[11]=A[14],A[14]=g,this}setPosition(A,g,I){const B=this.elements;return A.isVector3?(B[12]=A.x,B[13]=A.y,B[14]=A.z):(B[12]=A,B[13]=g,B[14]=I),this}invert(){const A=this.elements,g=A[0],I=A[1],B=A[2],Q=A[3],t=A[4],C=A[5],i=A[6],s=A[7],a=A[8],e=A[9],n=A[10],o=A[11],r=A[12],h=A[13],c=A[14],w=A[15],y=e*c*s-h*n*s+h*i*o-C*c*o-e*i*w+C*n*w,l=r*n*s-a*c*s-r*i*o+t*c*o+a*i*w-t*n*w,u=a*h*s-r*e*s+r*C*o-t*h*o-a*C*w+t*e*w,M=r*e*i-a*h*i-r*C*n+t*h*n+a*C*c-t*e*c,F=g*y+I*l+B*u+Q*M;if(F===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const p=1/F;return A[0]=y*p,A[1]=(h*n*Q-e*c*Q-h*B*o+I*c*o+e*B*w-I*n*w)*p,A[2]=(C*c*Q-h*i*Q+h*B*s-I*c*s-C*B*w+I*i*w)*p,A[3]=(e*i*Q-C*n*Q-e*B*s+I*n*s+C*B*o-I*i*o)*p,A[4]=l*p,A[5]=(a*c*Q-r*n*Q+r*B*o-g*c*o-a*B*w+g*n*w)*p,A[6]=(r*i*Q-t*c*Q-r*B*s+g*c*s+t*B*w-g*i*w)*p,A[7]=(t*n*Q-a*i*Q+a*B*s-g*n*s-t*B*o+g*i*o)*p,A[8]=u*p,A[9]=(r*e*Q-a*h*Q-r*I*o+g*h*o+a*I*w-g*e*w)*p,A[10]=(t*h*Q-r*C*Q+r*I*s-g*h*s-t*I*w+g*C*w)*p,A[11]=(a*C*Q-t*e*Q-a*I*s+g*e*s+t*I*o-g*C*o)*p,A[12]=M*p,A[13]=(a*h*B-r*e*B+r*I*n-g*h*n-a*I*c+g*e*c)*p,A[14]=(r*C*B-t*h*B-r*I*i+g*h*i+t*I*c-g*C*c)*p,A[15]=(t*e*B-a*C*B+a*I*i-g*e*i-t*I*n+g*C*n)*p,this}scale(A){const g=this.elements,I=A.x,B=A.y,Q=A.z;return g[0]*=I,g[4]*=B,g[8]*=Q,g[1]*=I,g[5]*=B,g[9]*=Q,g[2]*=I,g[6]*=B,g[10]*=Q,g[3]*=I,g[7]*=B,g[11]*=Q,this}getMaxScaleOnAxis(){const A=this.elements,g=A[0]*A[0]+A[1]*A[1]+A[2]*A[2],I=A[4]*A[4]+A[5]*A[5]+A[6]*A[6],B=A[8]*A[8]+A[9]*A[9]+A[10]*A[10];return Math.sqrt(Math.max(g,I,B))}makeTranslation(A,g,I){return A.isVector3?this.set(1,0,0,A.x,0,1,0,A.y,0,0,1,A.z,0,0,0,1):this.set(1,0,0,A,0,1,0,g,0,0,1,I,0,0,0,1),this}makeRotationX(A){const g=Math.cos(A),I=Math.sin(A);return this.set(1,0,0,0,0,g,-I,0,0,I,g,0,0,0,0,1),this}makeRotationY(A){const g=Math.cos(A),I=Math.sin(A);return this.set(g,0,I,0,0,1,0,0,-I,0,g,0,0,0,0,1),this}makeRotationZ(A){const g=Math.cos(A),I=Math.sin(A);return this.set(g,-I,0,0,I,g,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(A,g){const I=Math.cos(g),B=Math.sin(g),Q=1-I,t=A.x,C=A.y,i=A.z,s=Q*t,a=Q*C;return this.set(s*t+I,s*C-B*i,s*i+B*C,0,s*C+B*i,a*C+I,a*i-B*t,0,s*i-B*C,a*i+B*t,Q*i*i+I,0,0,0,0,1),this}makeScale(A,g,I){return this.set(A,0,0,0,0,g,0,0,0,0,I,0,0,0,0,1),this}makeShear(A,g,I,B,Q,t){return this.set(1,I,Q,0,A,1,t,0,g,B,1,0,0,0,0,1),this}compose(A,g,I){const B=this.elements,Q=g._x,t=g._y,C=g._z,i=g._w,s=Q+Q,a=t+t,e=C+C,n=Q*s,o=Q*a,r=Q*e,h=t*a,c=t*e,w=C*e,y=i*s,l=i*a,u=i*e,M=I.x,F=I.y,p=I.z;return B[0]=(1-(h+w))*M,B[1]=(o+u)*M,B[2]=(r-l)*M,B[3]=0,B[4]=(o-u)*F,B[5]=(1-(n+w))*F,B[6]=(c+y)*F,B[7]=0,B[8]=(r+l)*p,B[9]=(c-y)*p,B[10]=(1-(n+h))*p,B[11]=0,B[12]=A.x,B[13]=A.y,B[14]=A.z,B[15]=1,this}decompose(A,g,I){const B=this.elements;let Q=Yg.set(B[0],B[1],B[2]).length();const t=Yg.set(B[4],B[5],B[6]).length(),C=Yg.set(B[8],B[9],B[10]).length();this.determinant()<0&&(Q=-Q),A.x=B[12],A.y=B[13],A.z=B[14],ZA.copy(this);const s=1/Q,a=1/t,e=1/C;return ZA.elements[0]*=s,ZA.elements[1]*=s,ZA.elements[2]*=s,ZA.elements[4]*=a,ZA.elements[5]*=a,ZA.elements[6]*=a,ZA.elements[8]*=e,ZA.elements[9]*=e,ZA.elements[10]*=e,g.setFromRotationMatrix(ZA),I.x=Q,I.y=t,I.z=C,this}makePerspective(A,g,I,B,Q,t,C=II){const i=this.elements,s=2*Q/(g-A),a=2*Q/(I-B),e=(g+A)/(g-A),n=(I+B)/(I-B);let o,r;if(C===II)o=-(t+Q)/(t-Q),r=-2*t*Q/(t-Q);else if(C===RQ)o=-t/(t-Q),r=-t*Q/(t-Q);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+C);return i[0]=s,i[4]=0,i[8]=e,i[12]=0,i[1]=0,i[5]=a,i[9]=n,i[13]=0,i[2]=0,i[6]=0,i[10]=o,i[14]=r,i[3]=0,i[7]=0,i[11]=-1,i[15]=0,this}makeOrthographic(A,g,I,B,Q,t,C=II){const i=this.elements,s=1/(g-A),a=1/(I-B),e=1/(t-Q),n=(g+A)*s,o=(I+B)*a;let r,h;if(C===II)r=(t+Q)*e,h=-2*e;else if(C===RQ)r=Q*e,h=-1*e;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+C);return i[0]=2*s,i[4]=0,i[8]=0,i[12]=-n,i[1]=0,i[5]=2*a,i[9]=0,i[13]=-o,i[2]=0,i[6]=0,i[10]=h,i[14]=-r,i[3]=0,i[7]=0,i[11]=0,i[15]=1,this}equals(A){const g=this.elements,I=A.elements;for(let B=0;B<16;B++)if(g[B]!==I[B])return!1;return!0}fromArray(A,g=0){for(let I=0;I<16;I++)this.elements[I]=A[I+g];return this}toArray(A=[],g=0){const I=this.elements;return A[g]=I[0],A[g+1]=I[1],A[g+2]=I[2],A[g+3]=I[3],A[g+4]=I[4],A[g+5]=I[5],A[g+6]=I[6],A[g+7]=I[7],A[g+8]=I[8],A[g+9]=I[9],A[g+10]=I[10],A[g+11]=I[11],A[g+12]=I[12],A[g+13]=I[13],A[g+14]=I[14],A[g+15]=I[15],A}}const Yg=new D,ZA=new cA,yC=new D(0,0,0),uC=new D(1,1,1),ag=new D,YI=new D,kA=new D,bQ=new cA,HQ=new sA;class yg{constructor(A=0,g=0,I=0,B=yg.DEFAULT_ORDER){this.isEuler=!0,this._x=A,this._y=g,this._z=I,this._order=B}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get order(){return this._order}set order(A){this._order=A,this._onChangeCallback()}set(A,g,I,B=this._order){return this._x=A,this._y=g,this._z=I,this._order=B,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(A){return this._x=A._x,this._y=A._y,this._z=A._z,this._order=A._order,this._onChangeCallback(),this}setFromRotationMatrix(A,g=this._order,I=!0){const B=A.elements,Q=B[0],t=B[4],C=B[8],i=B[1],s=B[5],a=B[9],e=B[2],n=B[6],o=B[10];switch(g){case"XYZ":this._y=Math.asin(H(C,-1,1)),Math.abs(C)<.9999999?(this._x=Math.atan2(-a,o),this._z=Math.atan2(-t,Q)):(this._x=Math.atan2(n,s),this._z=0);break;case"YXZ":this._x=Math.asin(-H(a,-1,1)),Math.abs(a)<.9999999?(this._y=Math.atan2(C,o),this._z=Math.atan2(i,s)):(this._y=Math.atan2(-e,Q),this._z=0);break;case"ZXY":this._x=Math.asin(H(n,-1,1)),Math.abs(n)<.9999999?(this._y=Math.atan2(-e,o),this._z=Math.atan2(-t,s)):(this._y=0,this._z=Math.atan2(i,Q));break;case"ZYX":this._y=Math.asin(-H(e,-1,1)),Math.abs(e)<.9999999?(this._x=Math.atan2(n,o),this._z=Math.atan2(i,Q)):(this._x=0,this._z=Math.atan2(-t,s));break;case"YZX":this._z=Math.asin(H(i,-1,1)),Math.abs(i)<.9999999?(this._x=Math.atan2(-a,s),this._y=Math.atan2(-e,Q)):(this._x=0,this._y=Math.atan2(C,o));break;case"XZY":this._z=Math.asin(-H(t,-1,1)),Math.abs(t)<.9999999?(this._x=Math.atan2(n,s),this._y=Math.atan2(C,Q)):(this._x=Math.atan2(-a,o),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+g)}return this._order=g,I===!0&&this._onChangeCallback(),this}setFromQuaternion(A,g,I){return bQ.makeRotationFromQuaternion(A),this.setFromRotationMatrix(bQ,g,I)}setFromVector3(A,g=this._order){return this.set(A.x,A.y,A.z,g)}reorder(A){return HQ.setFromEuler(this),this.setFromQuaternion(HQ,A)}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._order===this._order}fromArray(A){return this._x=A[0],this._y=A[1],this._z=A[2],A[3]!==void 0&&(this._order=A[3]),this._onChangeCallback(),this}toArray(A=[],g=0){return A[g]=this._x,A[g+1]=this._y,A[g+2]=this._z,A[g+3]=this._order,A}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}yg.DEFAULT_ORDER="XYZ";class dC{constructor(){this.mask=1}set(A){this.mask=(1<<A|0)>>>0}enable(A){this.mask|=1<<A|0}enableAll(){this.mask=-1}toggle(A){this.mask^=1<<A|0}disable(A){this.mask&=~(1<<A|0)}disableAll(){this.mask=0}test(A){return(this.mask&A.mask)!==0}isEnabled(A){return(this.mask&(1<<A|0))!==0}}let MC=0;const ZQ=new D,xg=new sA,PA=new cA,xI=new D,iI=new D,GC=new D,NC=new sA,KQ=new D(1,0,0),qQ=new D(0,1,0),WQ=new D(0,0,1),VQ={type:"added"},FC={type:"removed"},Ug={type:"childadded",child:null},FB={type:"childremoved",child:null};class MA extends BI{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:MC++}),this.uuid=QI(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=MA.DEFAULT_UP.clone();const A=new D,g=new yg,I=new sA,B=new D(1,1,1);function Q(){I.setFromEuler(g,!1)}function t(){g.setFromQuaternion(I,void 0,!1)}g._onChange(Q),I._onChange(t),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:A},rotation:{configurable:!0,enumerable:!0,value:g},quaternion:{configurable:!0,enumerable:!0,value:I},scale:{configurable:!0,enumerable:!0,value:B},modelViewMatrix:{value:new cA},normalMatrix:{value:new TA}}),this.matrix=new cA,this.matrixWorld=new cA,this.matrixAutoUpdate=MA.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=MA.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new dC,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(A){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(A),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(A){return this.quaternion.premultiply(A),this}setRotationFromAxisAngle(A,g){this.quaternion.setFromAxisAngle(A,g)}setRotationFromEuler(A){this.quaternion.setFromEuler(A,!0)}setRotationFromMatrix(A){this.quaternion.setFromRotationMatrix(A)}setRotationFromQuaternion(A){this.quaternion.copy(A)}rotateOnAxis(A,g){return xg.setFromAxisAngle(A,g),this.quaternion.multiply(xg),this}rotateOnWorldAxis(A,g){return xg.setFromAxisAngle(A,g),this.quaternion.premultiply(xg),this}rotateX(A){return this.rotateOnAxis(KQ,A)}rotateY(A){return this.rotateOnAxis(qQ,A)}rotateZ(A){return this.rotateOnAxis(WQ,A)}translateOnAxis(A,g){return ZQ.copy(A).applyQuaternion(this.quaternion),this.position.add(ZQ.multiplyScalar(g)),this}translateX(A){return this.translateOnAxis(KQ,A)}translateY(A){return this.translateOnAxis(qQ,A)}translateZ(A){return this.translateOnAxis(WQ,A)}localToWorld(A){return this.updateWorldMatrix(!0,!1),A.applyMatrix4(this.matrixWorld)}worldToLocal(A){return this.updateWorldMatrix(!0,!1),A.applyMatrix4(PA.copy(this.matrixWorld).invert())}lookAt(A,g,I){A.isVector3?xI.copy(A):xI.set(A,g,I);const B=this.parent;this.updateWorldMatrix(!0,!1),iI.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?PA.lookAt(iI,xI,this.up):PA.lookAt(xI,iI,this.up),this.quaternion.setFromRotationMatrix(PA),B&&(PA.extractRotation(B.matrixWorld),xg.setFromRotationMatrix(PA),this.quaternion.premultiply(xg.invert()))}add(A){if(arguments.length>1){for(let g=0;g<arguments.length;g++)this.add(arguments[g]);return this}return A===this?(console.error("THREE.Object3D.add: object can\'t be added as a child of itself.",A),this):(A&&A.isObject3D?(A.removeFromParent(),A.parent=this,this.children.push(A),A.dispatchEvent(VQ),Ug.child=A,this.dispatchEvent(Ug),Ug.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",A),this)}remove(A){if(arguments.length>1){for(let I=0;I<arguments.length;I++)this.remove(arguments[I]);return this}const g=this.children.indexOf(A);return g!==-1&&(A.parent=null,this.children.splice(g,1),A.dispatchEvent(FC),FB.child=A,this.dispatchEvent(FB),FB.child=null),this}removeFromParent(){const A=this.parent;return A!==null&&A.remove(this),this}clear(){return this.remove(...this.children)}attach(A){return this.updateWorldMatrix(!0,!1),PA.copy(this.matrixWorld).invert(),A.parent!==null&&(A.parent.updateWorldMatrix(!0,!1),PA.multiply(A.parent.matrixWorld)),A.applyMatrix4(PA),A.removeFromParent(),A.parent=this,this.children.push(A),A.updateWorldMatrix(!1,!0),A.dispatchEvent(VQ),Ug.child=A,this.dispatchEvent(Ug),Ug.child=null,this}getObjectById(A){return this.getObjectByProperty("id",A)}getObjectByName(A){return this.getObjectByProperty("name",A)}getObjectByProperty(A,g){if(this[A]===g)return this;for(let I=0,B=this.children.length;I<B;I++){const t=this.children[I].getObjectByProperty(A,g);if(t!==void 0)return t}}getObjectsByProperty(A,g,I=[]){this[A]===g&&I.push(this);const B=this.children;for(let Q=0,t=B.length;Q<t;Q++)B[Q].getObjectsByProperty(A,g,I);return I}getWorldPosition(A){return this.updateWorldMatrix(!0,!1),A.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(A){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(iI,A,GC),A}getWorldScale(A){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(iI,NC,A),A}getWorldDirection(A){this.updateWorldMatrix(!0,!1);const g=this.matrixWorld.elements;return A.set(g[8],g[9],g[10]).normalize()}raycast(){}traverse(A){A(this);const g=this.children;for(let I=0,B=g.length;I<B;I++)g[I].traverse(A)}traverseVisible(A){if(this.visible===!1)return;A(this);const g=this.children;for(let I=0,B=g.length;I<B;I++)g[I].traverseVisible(A)}traverseAncestors(A){const g=this.parent;g!==null&&(A(g),g.traverseAncestors(A))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(A){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||A)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,A=!0);const g=this.children;for(let I=0,B=g.length;I<B;I++)g[I].updateMatrixWorld(A)}updateWorldMatrix(A,g){const I=this.parent;if(A===!0&&I!==null&&I.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),g===!0){const B=this.children;for(let Q=0,t=B.length;Q<t;Q++)B[Q].updateWorldMatrix(!1,!0)}}toJSON(A){const g=A===void 0||typeof A=="string",I={};g&&(A={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},I.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const B={};B.uuid=this.uuid,B.type=this.type,this.name!==""&&(B.name=this.name),this.castShadow===!0&&(B.castShadow=!0),this.receiveShadow===!0&&(B.receiveShadow=!0),this.visible===!1&&(B.visible=!1),this.frustumCulled===!1&&(B.frustumCulled=!1),this.renderOrder!==0&&(B.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(B.userData=this.userData),B.layers=this.layers.mask,B.matrix=this.matrix.toArray(),B.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(B.matrixAutoUpdate=!1),this.isInstancedMesh&&(B.type="InstancedMesh",B.count=this.count,B.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(B.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(B.type="BatchedMesh",B.perObjectFrustumCulled=this.perObjectFrustumCulled,B.sortObjects=this.sortObjects,B.drawRanges=this._drawRanges,B.reservedRanges=this._reservedRanges,B.visibility=this._visibility,B.active=this._active,B.bounds=this._bounds.map(C=>({boxInitialized:C.boxInitialized,boxMin:C.box.min.toArray(),boxMax:C.box.max.toArray(),sphereInitialized:C.sphereInitialized,sphereRadius:C.sphere.radius,sphereCenter:C.sphere.center.toArray()})),B.maxInstanceCount=this._maxInstanceCount,B.maxVertexCount=this._maxVertexCount,B.maxIndexCount=this._maxIndexCount,B.geometryInitialized=this._geometryInitialized,B.geometryCount=this._geometryCount,B.matricesTexture=this._matricesTexture.toJSON(A),this._colorsTexture!==null&&(B.colorsTexture=this._colorsTexture.toJSON(A)),this.boundingSphere!==null&&(B.boundingSphere={center:B.boundingSphere.center.toArray(),radius:B.boundingSphere.radius}),this.boundingBox!==null&&(B.boundingBox={min:B.boundingBox.min.toArray(),max:B.boundingBox.max.toArray()}));function Q(C,i){return C[i.uuid]===void 0&&(C[i.uuid]=i.toJSON(A)),i.uuid}if(this.isScene)this.background&&(this.background.isColor?B.background=this.background.toJSON():this.background.isTexture&&(B.background=this.background.toJSON(A).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(B.environment=this.environment.toJSON(A).uuid);else if(this.isMesh||this.isLine||this.isPoints){B.geometry=Q(A.geometries,this.geometry);const C=this.geometry.parameters;if(C!==void 0&&C.shapes!==void 0){const i=C.shapes;if(Array.isArray(i))for(let s=0,a=i.length;s<a;s++){const e=i[s];Q(A.shapes,e)}else Q(A.shapes,i)}}if(this.isSkinnedMesh&&(B.bindMode=this.bindMode,B.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(Q(A.skeletons,this.skeleton),B.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const C=[];for(let i=0,s=this.material.length;i<s;i++)C.push(Q(A.materials,this.material[i]));B.material=C}else B.material=Q(A.materials,this.material);if(this.children.length>0){B.children=[];for(let C=0;C<this.children.length;C++)B.children.push(this.children[C].toJSON(A).object)}if(this.animations.length>0){B.animations=[];for(let C=0;C<this.animations.length;C++){const i=this.animations[C];B.animations.push(Q(A.animations,i))}}if(g){const C=t(A.geometries),i=t(A.materials),s=t(A.textures),a=t(A.images),e=t(A.shapes),n=t(A.skeletons),o=t(A.animations),r=t(A.nodes);C.length>0&&(I.geometries=C),i.length>0&&(I.materials=i),s.length>0&&(I.textures=s),a.length>0&&(I.images=a),e.length>0&&(I.shapes=e),n.length>0&&(I.skeletons=n),o.length>0&&(I.animations=o),r.length>0&&(I.nodes=r)}return I.object=B,I;function t(C){const i=[];for(const s in C){const a=C[s];delete a.metadata,i.push(a)}return i}}clone(A){return new this.constructor().copy(this,A)}copy(A,g=!0){if(this.name=A.name,this.up.copy(A.up),this.position.copy(A.position),this.rotation.order=A.rotation.order,this.quaternion.copy(A.quaternion),this.scale.copy(A.scale),this.matrix.copy(A.matrix),this.matrixWorld.copy(A.matrixWorld),this.matrixAutoUpdate=A.matrixAutoUpdate,this.matrixWorldAutoUpdate=A.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=A.matrixWorldNeedsUpdate,this.layers.mask=A.layers.mask,this.visible=A.visible,this.castShadow=A.castShadow,this.receiveShadow=A.receiveShadow,this.frustumCulled=A.frustumCulled,this.renderOrder=A.renderOrder,this.animations=A.animations.slice(),this.userData=JSON.parse(JSON.stringify(A.userData)),g===!0)for(let I=0;I<A.children.length;I++){const B=A.children[I];this.add(B.clone())}return this}}MA.DEFAULT_UP=new D(0,1,0),MA.DEFAULT_MATRIX_AUTO_UPDATE=!0,MA.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const KA=new D,_A=new D,kB=new D,$A=new D,Lg=new D,bg=new D,TQ=new D,pB=new D,fB=new D,RB=new D,JB=new lA,mB=new lA,SB=new lA;class qA{constructor(A=new D,g=new D,I=new D){this.a=A,this.b=g,this.c=I}static getNormal(A,g,I,B){B.subVectors(I,g),KA.subVectors(A,g),B.cross(KA);const Q=B.lengthSq();return Q>0?B.multiplyScalar(1/Math.sqrt(Q)):B.set(0,0,0)}static getBarycoord(A,g,I,B,Q){KA.subVectors(B,g),_A.subVectors(I,g),kB.subVectors(A,g);const t=KA.dot(KA),C=KA.dot(_A),i=KA.dot(kB),s=_A.dot(_A),a=_A.dot(kB),e=t*s-C*C;if(e===0)return Q.set(0,0,0),null;const n=1/e,o=(s*i-C*a)*n,r=(t*a-C*i)*n;return Q.set(1-o-r,r,o)}static containsPoint(A,g,I,B){return this.getBarycoord(A,g,I,B,$A)===null?!1:$A.x>=0&&$A.y>=0&&$A.x+$A.y<=1}static getInterpolation(A,g,I,B,Q,t,C,i){return this.getBarycoord(A,g,I,B,$A)===null?(i.x=0,i.y=0,"z"in i&&(i.z=0),"w"in i&&(i.w=0),null):(i.setScalar(0),i.addScaledVector(Q,$A.x),i.addScaledVector(t,$A.y),i.addScaledVector(C,$A.z),i)}static getInterpolatedAttribute(A,g,I,B,Q,t){return JB.setScalar(0),mB.setScalar(0),SB.setScalar(0),JB.fromBufferAttribute(A,g),mB.fromBufferAttribute(A,I),SB.fromBufferAttribute(A,B),t.setScalar(0),t.addScaledVector(JB,Q.x),t.addScaledVector(mB,Q.y),t.addScaledVector(SB,Q.z),t}static isFrontFacing(A,g,I,B){return KA.subVectors(I,g),_A.subVectors(A,g),KA.cross(_A).dot(B)<0}set(A,g,I){return this.a.copy(A),this.b.copy(g),this.c.copy(I),this}setFromPointsAndIndices(A,g,I,B){return this.a.copy(A[g]),this.b.copy(A[I]),this.c.copy(A[B]),this}setFromAttributeAndIndices(A,g,I,B){return this.a.fromBufferAttribute(A,g),this.b.fromBufferAttribute(A,I),this.c.fromBufferAttribute(A,B),this}clone(){return new this.constructor().copy(this)}copy(A){return this.a.copy(A.a),this.b.copy(A.b),this.c.copy(A.c),this}getArea(){return KA.subVectors(this.c,this.b),_A.subVectors(this.a,this.b),KA.cross(_A).length()*.5}getMidpoint(A){return A.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(A){return qA.getNormal(this.a,this.b,this.c,A)}getPlane(A){return A.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(A,g){return qA.getBarycoord(A,this.a,this.b,this.c,g)}getInterpolation(A,g,I,B,Q){return qA.getInterpolation(A,this.a,this.b,this.c,g,I,B,Q)}containsPoint(A){return qA.containsPoint(A,this.a,this.b,this.c)}isFrontFacing(A){return qA.isFrontFacing(this.a,this.b,this.c,A)}intersectsBox(A){return A.intersectsTriangle(this)}closestPointToPoint(A,g){const I=this.a,B=this.b,Q=this.c;let t,C;Lg.subVectors(B,I),bg.subVectors(Q,I),pB.subVectors(A,I);const i=Lg.dot(pB),s=bg.dot(pB);if(i<=0&&s<=0)return g.copy(I);fB.subVectors(A,B);const a=Lg.dot(fB),e=bg.dot(fB);if(a>=0&&e<=a)return g.copy(B);const n=i*e-a*s;if(n<=0&&i>=0&&a<=0)return t=i/(i-a),g.copy(I).addScaledVector(Lg,t);RB.subVectors(A,Q);const o=Lg.dot(RB),r=bg.dot(RB);if(r>=0&&o<=r)return g.copy(Q);const h=o*s-i*r;if(h<=0&&s>=0&&r<=0)return C=s/(s-r),g.copy(I).addScaledVector(bg,C);const c=a*r-o*e;if(c<=0&&e-a>=0&&o-r>=0)return TQ.subVectors(Q,B),C=(e-a)/(e-a+(o-r)),g.copy(B).addScaledVector(TQ,C);const w=1/(c+h+n);return t=h*w,C=n*w,g.copy(I).addScaledVector(Lg,t).addScaledVector(bg,C)}equals(A){return A.a.equals(this.a)&&A.b.equals(this.b)&&A.c.equals(this.c)}}const vQ={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},ng={h:0,s:0,l:0},UI={h:0,s:0,l:0};function YB(E,A,g){return g<0&&(g+=1),g>1&&(g-=1),g<1/6?E+(A-E)*6*g:g<1/2?A:g<2/3?E+(A-E)*6*(2/3-g):E}class ug{constructor(A,g,I){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(A,g,I)}set(A,g,I){if(g===void 0&&I===void 0){const B=A;B&&B.isColor?this.copy(B):typeof B=="number"?this.setHex(B):typeof B=="string"&&this.setStyle(B)}else this.setRGB(A,g,I);return this}setScalar(A){return this.r=A,this.g=A,this.b=A,this}setHex(A,g=LA){return A=Math.floor(A),this.r=(A>>16&255)/255,this.g=(A>>8&255)/255,this.b=(A&255)/255,bA.toWorkingColorSpace(this,g),this}setRGB(A,g,I,B=bA.workingColorSpace){return this.r=A,this.g=g,this.b=I,bA.toWorkingColorSpace(this,B),this}setHSL(A,g,I,B=bA.workingColorSpace){if(A=eC(A,1),g=H(g,0,1),I=H(I,0,1),g===0)this.r=this.g=this.b=I;else{const Q=I<=.5?I*(1+g):I+g-I*g,t=2*I-Q;this.r=YB(t,Q,A+1/3),this.g=YB(t,Q,A),this.b=YB(t,Q,A-1/3)}return bA.toWorkingColorSpace(this,B),this}setStyle(A,g=LA){function I(Q){Q!==void 0&&parseFloat(Q)<1&&console.warn("THREE.Color: Alpha component of "+A+" will be ignored.")}let B;if(B=/^(\\w+)\\(([^\\)]*)\\)/.exec(A)){let Q;const t=B[1],C=B[2];switch(t){case"rgb":case"rgba":if(Q=/^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(C))return I(Q[4]),this.setRGB(Math.min(255,parseInt(Q[1],10))/255,Math.min(255,parseInt(Q[2],10))/255,Math.min(255,parseInt(Q[3],10))/255,g);if(Q=/^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(C))return I(Q[4]),this.setRGB(Math.min(100,parseInt(Q[1],10))/100,Math.min(100,parseInt(Q[2],10))/100,Math.min(100,parseInt(Q[3],10))/100,g);break;case"hsl":case"hsla":if(Q=/^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(C))return I(Q[4]),this.setHSL(parseFloat(Q[1])/360,parseFloat(Q[2])/100,parseFloat(Q[3])/100,g);break;default:console.warn("THREE.Color: Unknown color model "+A)}}else if(B=/^\\#([A-Fa-f\\d]+)$/.exec(A)){const Q=B[1],t=Q.length;if(t===3)return this.setRGB(parseInt(Q.charAt(0),16)/15,parseInt(Q.charAt(1),16)/15,parseInt(Q.charAt(2),16)/15,g);if(t===6)return this.setHex(parseInt(Q,16),g);console.warn("THREE.Color: Invalid hex color "+A)}else if(A&&A.length>0)return this.setColorName(A,g);return this}setColorName(A,g=LA){const I=vQ[A.toLowerCase()];return I!==void 0?this.setHex(I,g):console.warn("THREE.Color: Unknown color "+A),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(A){return this.r=A.r,this.g=A.g,this.b=A.b,this}copySRGBToLinear(A){return this.r=XA(A.r),this.g=XA(A.g),this.b=XA(A.b),this}copyLinearToSRGB(A){return this.r=pg(A.r),this.g=pg(A.g),this.b=pg(A.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(A=LA){return bA.fromWorkingColorSpace(wA.copy(this),A),Math.round(H(wA.r*255,0,255))*65536+Math.round(H(wA.g*255,0,255))*256+Math.round(H(wA.b*255,0,255))}getHexString(A=LA){return("000000"+this.getHex(A).toString(16)).slice(-6)}getHSL(A,g=bA.workingColorSpace){bA.fromWorkingColorSpace(wA.copy(this),g);const I=wA.r,B=wA.g,Q=wA.b,t=Math.max(I,B,Q),C=Math.min(I,B,Q);let i,s;const a=(C+t)/2;if(C===t)i=0,s=0;else{const e=t-C;switch(s=a<=.5?e/(t+C):e/(2-t-C),t){case I:i=(B-Q)/e+(B<Q?6:0);break;case B:i=(Q-I)/e+2;break;case Q:i=(I-B)/e+4;break}i/=6}return A.h=i,A.s=s,A.l=a,A}getRGB(A,g=bA.workingColorSpace){return bA.fromWorkingColorSpace(wA.copy(this),g),A.r=wA.r,A.g=wA.g,A.b=wA.b,A}getStyle(A=LA){bA.fromWorkingColorSpace(wA.copy(this),A);const g=wA.r,I=wA.g,B=wA.b;return A!==LA?`color(${A} ${g.toFixed(3)} ${I.toFixed(3)} ${B.toFixed(3)})`:`rgb(${Math.round(g*255)},${Math.round(I*255)},${Math.round(B*255)})`}offsetHSL(A,g,I){return this.getHSL(ng),this.setHSL(ng.h+A,ng.s+g,ng.l+I)}add(A){return this.r+=A.r,this.g+=A.g,this.b+=A.b,this}addColors(A,g){return this.r=A.r+g.r,this.g=A.g+g.g,this.b=A.b+g.b,this}addScalar(A){return this.r+=A,this.g+=A,this.b+=A,this}sub(A){return this.r=Math.max(0,this.r-A.r),this.g=Math.max(0,this.g-A.g),this.b=Math.max(0,this.b-A.b),this}multiply(A){return this.r*=A.r,this.g*=A.g,this.b*=A.b,this}multiplyScalar(A){return this.r*=A,this.g*=A,this.b*=A,this}lerp(A,g){return this.r+=(A.r-this.r)*g,this.g+=(A.g-this.g)*g,this.b+=(A.b-this.b)*g,this}lerpColors(A,g,I){return this.r=A.r+(g.r-A.r)*I,this.g=A.g+(g.g-A.g)*I,this.b=A.b+(g.b-A.b)*I,this}lerpHSL(A,g){this.getHSL(ng),A.getHSL(UI);const I=wB(ng.h,UI.h,g),B=wB(ng.s,UI.s,g),Q=wB(ng.l,UI.l,g);return this.setHSL(I,B,Q),this}setFromVector3(A){return this.r=A.x,this.g=A.y,this.b=A.z,this}applyMatrix3(A){const g=this.r,I=this.g,B=this.b,Q=A.elements;return this.r=Q[0]*g+Q[3]*I+Q[6]*B,this.g=Q[1]*g+Q[4]*I+Q[7]*B,this.b=Q[2]*g+Q[5]*I+Q[8]*B,this}equals(A){return A.r===this.r&&A.g===this.g&&A.b===this.b}fromArray(A,g=0){return this.r=A[g],this.g=A[g+1],this.b=A[g+2],this}toArray(A=[],g=0){return A[g]=this.r,A[g+1]=this.g,A[g+2]=this.b,A}fromBufferAttribute(A,g){return this.r=A.getX(g),this.g=A.getY(g),this.b=A.getZ(g),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const wA=new ug;ug.NAMES=vQ;let kC=0;class zQ extends BI{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:kC++}),this.uuid=QI(),this.name="",this.type="Material",this.blending=cQ,this.side=hB,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=DQ,this.blendDst=lQ,this.blendEquation=wQ,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new ug(0,0,0),this.blendAlpha=0,this.depthFunc=yQ,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=pQ,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=kg,this.stencilZFail=kg,this.stencilZPass=kg,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(A){this._alphaTest>0!=A>0&&this.version++,this._alphaTest=A}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(A){if(A!==void 0)for(const g in A){const I=A[g];if(I===void 0){console.warn(`THREE.Material: parameter \'${g}\' has value of undefined.`);continue}const B=this[g];if(B===void 0){console.warn(`THREE.Material: \'${g}\' is not a property of THREE.${this.type}.`);continue}B&&B.isColor?B.set(I):B&&B.isVector3&&I&&I.isVector3?B.copy(I):this[g]=I}}toJSON(A){const g=A===void 0||typeof A=="string";g&&(A={textures:{},images:{}});const I={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};I.uuid=this.uuid,I.type=this.type,this.name!==""&&(I.name=this.name),this.color&&this.color.isColor&&(I.color=this.color.getHex()),this.roughness!==void 0&&(I.roughness=this.roughness),this.metalness!==void 0&&(I.metalness=this.metalness),this.sheen!==void 0&&(I.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(I.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(I.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(I.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(I.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(I.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(I.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(I.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(I.shininess=this.shininess),this.clearcoat!==void 0&&(I.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(I.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(I.clearcoatMap=this.clearcoatMap.toJSON(A).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(I.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(A).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(I.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(A).uuid,I.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(I.dispersion=this.dispersion),this.iridescence!==void 0&&(I.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(I.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(I.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(I.iridescenceMap=this.iridescenceMap.toJSON(A).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(I.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(A).uuid),this.anisotropy!==void 0&&(I.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(I.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(I.anisotropyMap=this.anisotropyMap.toJSON(A).uuid),this.map&&this.map.isTexture&&(I.map=this.map.toJSON(A).uuid),this.matcap&&this.matcap.isTexture&&(I.matcap=this.matcap.toJSON(A).uuid),this.alphaMap&&this.alphaMap.isTexture&&(I.alphaMap=this.alphaMap.toJSON(A).uuid),this.lightMap&&this.lightMap.isTexture&&(I.lightMap=this.lightMap.toJSON(A).uuid,I.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(I.aoMap=this.aoMap.toJSON(A).uuid,I.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(I.bumpMap=this.bumpMap.toJSON(A).uuid,I.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(I.normalMap=this.normalMap.toJSON(A).uuid,I.normalMapType=this.normalMapType,I.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(I.displacementMap=this.displacementMap.toJSON(A).uuid,I.displacementScale=this.displacementScale,I.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(I.roughnessMap=this.roughnessMap.toJSON(A).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(I.metalnessMap=this.metalnessMap.toJSON(A).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(I.emissiveMap=this.emissiveMap.toJSON(A).uuid),this.specularMap&&this.specularMap.isTexture&&(I.specularMap=this.specularMap.toJSON(A).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(I.specularIntensityMap=this.specularIntensityMap.toJSON(A).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(I.specularColorMap=this.specularColorMap.toJSON(A).uuid),this.envMap&&this.envMap.isTexture&&(I.envMap=this.envMap.toJSON(A).uuid,this.combine!==void 0&&(I.combine=this.combine)),this.envMapRotation!==void 0&&(I.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(I.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(I.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(I.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(I.gradientMap=this.gradientMap.toJSON(A).uuid),this.transmission!==void 0&&(I.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(I.transmissionMap=this.transmissionMap.toJSON(A).uuid),this.thickness!==void 0&&(I.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(I.thicknessMap=this.thicknessMap.toJSON(A).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(I.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(I.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(I.size=this.size),this.shadowSide!==null&&(I.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(I.sizeAttenuation=this.sizeAttenuation),this.blending!==cQ&&(I.blending=this.blending),this.side!==hB&&(I.side=this.side),this.vertexColors===!0&&(I.vertexColors=!0),this.opacity<1&&(I.opacity=this.opacity),this.transparent===!0&&(I.transparent=!0),this.blendSrc!==DQ&&(I.blendSrc=this.blendSrc),this.blendDst!==lQ&&(I.blendDst=this.blendDst),this.blendEquation!==wQ&&(I.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(I.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(I.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(I.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(I.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(I.blendAlpha=this.blendAlpha),this.depthFunc!==yQ&&(I.depthFunc=this.depthFunc),this.depthTest===!1&&(I.depthTest=this.depthTest),this.depthWrite===!1&&(I.depthWrite=this.depthWrite),this.colorWrite===!1&&(I.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(I.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==pQ&&(I.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(I.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(I.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==kg&&(I.stencilFail=this.stencilFail),this.stencilZFail!==kg&&(I.stencilZFail=this.stencilZFail),this.stencilZPass!==kg&&(I.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(I.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(I.rotation=this.rotation),this.polygonOffset===!0&&(I.polygonOffset=!0),this.polygonOffsetFactor!==0&&(I.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(I.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(I.linewidth=this.linewidth),this.dashSize!==void 0&&(I.dashSize=this.dashSize),this.gapSize!==void 0&&(I.gapSize=this.gapSize),this.scale!==void 0&&(I.scale=this.scale),this.dithering===!0&&(I.dithering=!0),this.alphaTest>0&&(I.alphaTest=this.alphaTest),this.alphaHash===!0&&(I.alphaHash=!0),this.alphaToCoverage===!0&&(I.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(I.premultipliedAlpha=!0),this.forceSinglePass===!0&&(I.forceSinglePass=!0),this.wireframe===!0&&(I.wireframe=!0),this.wireframeLinewidth>1&&(I.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(I.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(I.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(I.flatShading=!0),this.visible===!1&&(I.visible=!1),this.toneMapped===!1&&(I.toneMapped=!1),this.fog===!1&&(I.fog=!1),Object.keys(this.userData).length>0&&(I.userData=this.userData);function B(Q){const t=[];for(const C in Q){const i=Q[C];delete i.metadata,t.push(i)}return t}if(g){const Q=B(A.textures),t=B(A.images);Q.length>0&&(I.textures=Q),t.length>0&&(I.images=t)}return I}clone(){return new this.constructor().copy(this)}copy(A){this.name=A.name,this.blending=A.blending,this.side=A.side,this.vertexColors=A.vertexColors,this.opacity=A.opacity,this.transparent=A.transparent,this.blendSrc=A.blendSrc,this.blendDst=A.blendDst,this.blendEquation=A.blendEquation,this.blendSrcAlpha=A.blendSrcAlpha,this.blendDstAlpha=A.blendDstAlpha,this.blendEquationAlpha=A.blendEquationAlpha,this.blendColor.copy(A.blendColor),this.blendAlpha=A.blendAlpha,this.depthFunc=A.depthFunc,this.depthTest=A.depthTest,this.depthWrite=A.depthWrite,this.stencilWriteMask=A.stencilWriteMask,this.stencilFunc=A.stencilFunc,this.stencilRef=A.stencilRef,this.stencilFuncMask=A.stencilFuncMask,this.stencilFail=A.stencilFail,this.stencilZFail=A.stencilZFail,this.stencilZPass=A.stencilZPass,this.stencilWrite=A.stencilWrite;const g=A.clippingPlanes;let I=null;if(g!==null){const B=g.length;I=new Array(B);for(let Q=0;Q!==B;++Q)I[Q]=g[Q].clone()}return this.clippingPlanes=I,this.clipIntersection=A.clipIntersection,this.clipShadows=A.clipShadows,this.shadowSide=A.shadowSide,this.colorWrite=A.colorWrite,this.precision=A.precision,this.polygonOffset=A.polygonOffset,this.polygonOffsetFactor=A.polygonOffsetFactor,this.polygonOffsetUnits=A.polygonOffsetUnits,this.dithering=A.dithering,this.alphaTest=A.alphaTest,this.alphaHash=A.alphaHash,this.alphaToCoverage=A.alphaToCoverage,this.premultipliedAlpha=A.premultipliedAlpha,this.forceSinglePass=A.forceSinglePass,this.visible=A.visible,this.toneMapped=A.toneMapped,this.userData=JSON.parse(JSON.stringify(A.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(A){A===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class pC extends zQ{constructor(A){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new ug(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new yg,this.combine=tC,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.color.copy(A.color),this.map=A.map,this.lightMap=A.lightMap,this.lightMapIntensity=A.lightMapIntensity,this.aoMap=A.aoMap,this.aoMapIntensity=A.aoMapIntensity,this.specularMap=A.specularMap,this.alphaMap=A.alphaMap,this.envMap=A.envMap,this.envMapRotation.copy(A.envMapRotation),this.combine=A.combine,this.reflectivity=A.reflectivity,this.refractionRatio=A.refractionRatio,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.wireframeLinecap=A.wireframeLinecap,this.wireframeLinejoin=A.wireframeLinejoin,this.fog=A.fog,this}}const IA=new D,LI=new dA;class Hg{constructor(A,g,I=!1){if(Array.isArray(A))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=A,this.itemSize=g,this.count=A!==void 0?A.length/g:0,this.normalized=I,this.usage=fQ,this.updateRanges=[],this.gpuType=EC,this.version=0}onUploadCallback(){}set needsUpdate(A){A===!0&&this.version++}setUsage(A){return this.usage=A,this}addUpdateRange(A,g){this.updateRanges.push({start:A,count:g})}clearUpdateRanges(){this.updateRanges.length=0}copy(A){return this.name=A.name,this.array=new A.array.constructor(A.array),this.itemSize=A.itemSize,this.count=A.count,this.normalized=A.normalized,this.usage=A.usage,this.gpuType=A.gpuType,this}copyAt(A,g,I){A*=this.itemSize,I*=g.itemSize;for(let B=0,Q=this.itemSize;B<Q;B++)this.array[A+B]=g.array[I+B];return this}copyArray(A){return this.array.set(A),this}applyMatrix3(A){if(this.itemSize===2)for(let g=0,I=this.count;g<I;g++)LI.fromBufferAttribute(this,g),LI.applyMatrix3(A),this.setXY(g,LI.x,LI.y);else if(this.itemSize===3)for(let g=0,I=this.count;g<I;g++)IA.fromBufferAttribute(this,g),IA.applyMatrix3(A),this.setXYZ(g,IA.x,IA.y,IA.z);return this}applyMatrix4(A){for(let g=0,I=this.count;g<I;g++)IA.fromBufferAttribute(this,g),IA.applyMatrix4(A),this.setXYZ(g,IA.x,IA.y,IA.z);return this}applyNormalMatrix(A){for(let g=0,I=this.count;g<I;g++)IA.fromBufferAttribute(this,g),IA.applyNormalMatrix(A),this.setXYZ(g,IA.x,IA.y,IA.z);return this}transformDirection(A){for(let g=0,I=this.count;g<I;g++)IA.fromBufferAttribute(this,g),IA.transformDirection(A),this.setXYZ(g,IA.x,IA.y,IA.z);return this}set(A,g=0){return this.array.set(A,g),this}getComponent(A,g){let I=this.array[A*this.itemSize+g];return this.normalized&&(I=tI(I,this.array)),I}setComponent(A,g,I){return this.normalized&&(I=uA(I,this.array)),this.array[A*this.itemSize+g]=I,this}getX(A){let g=this.array[A*this.itemSize];return this.normalized&&(g=tI(g,this.array)),g}setX(A,g){return this.normalized&&(g=uA(g,this.array)),this.array[A*this.itemSize]=g,this}getY(A){let g=this.array[A*this.itemSize+1];return this.normalized&&(g=tI(g,this.array)),g}setY(A,g){return this.normalized&&(g=uA(g,this.array)),this.array[A*this.itemSize+1]=g,this}getZ(A){let g=this.array[A*this.itemSize+2];return this.normalized&&(g=tI(g,this.array)),g}setZ(A,g){return this.normalized&&(g=uA(g,this.array)),this.array[A*this.itemSize+2]=g,this}getW(A){let g=this.array[A*this.itemSize+3];return this.normalized&&(g=tI(g,this.array)),g}setW(A,g){return this.normalized&&(g=uA(g,this.array)),this.array[A*this.itemSize+3]=g,this}setXY(A,g,I){return A*=this.itemSize,this.normalized&&(g=uA(g,this.array),I=uA(I,this.array)),this.array[A+0]=g,this.array[A+1]=I,this}setXYZ(A,g,I,B){return A*=this.itemSize,this.normalized&&(g=uA(g,this.array),I=uA(I,this.array),B=uA(B,this.array)),this.array[A+0]=g,this.array[A+1]=I,this.array[A+2]=B,this}setXYZW(A,g,I,B,Q){return A*=this.itemSize,this.normalized&&(g=uA(g,this.array),I=uA(I,this.array),B=uA(B,this.array),Q=uA(Q,this.array)),this.array[A+0]=g,this.array[A+1]=I,this.array[A+2]=B,this.array[A+3]=Q,this}onUpload(A){return this.onUploadCallback=A,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const A={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(A.name=this.name),this.usage!==fQ&&(A.usage=this.usage),A}}class fC extends Hg{constructor(A,g,I){super(new Uint16Array(A),g,I)}}class RC extends Hg{constructor(A,g,I){super(new Uint32Array(A),g,I)}}class bI extends Hg{constructor(A,g,I){super(new Float32Array(A),g,I)}}let JC=0;const SA=new cA,xB=new MA,Zg=new D,pA=new Rg,sI=new Rg,eA=new D;class HI extends BI{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:JC++}),this.uuid=QI(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(A){return Array.isArray(A)?this.index=new(aC(A)?RC:fC)(A,1):this.index=A,this}setIndirect(A){return this.indirect=A,this}getIndirect(){return this.indirect}getAttribute(A){return this.attributes[A]}setAttribute(A,g){return this.attributes[A]=g,this}deleteAttribute(A){return delete this.attributes[A],this}hasAttribute(A){return this.attributes[A]!==void 0}addGroup(A,g,I=0){this.groups.push({start:A,count:g,materialIndex:I})}clearGroups(){this.groups=[]}setDrawRange(A,g){this.drawRange.start=A,this.drawRange.count=g}applyMatrix4(A){const g=this.attributes.position;g!==void 0&&(g.applyMatrix4(A),g.needsUpdate=!0);const I=this.attributes.normal;if(I!==void 0){const Q=new TA().getNormalMatrix(A);I.applyNormalMatrix(Q),I.needsUpdate=!0}const B=this.attributes.tangent;return B!==void 0&&(B.transformDirection(A),B.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(A){return SA.makeRotationFromQuaternion(A),this.applyMatrix4(SA),this}rotateX(A){return SA.makeRotationX(A),this.applyMatrix4(SA),this}rotateY(A){return SA.makeRotationY(A),this.applyMatrix4(SA),this}rotateZ(A){return SA.makeRotationZ(A),this.applyMatrix4(SA),this}translate(A,g,I){return SA.makeTranslation(A,g,I),this.applyMatrix4(SA),this}scale(A,g,I){return SA.makeScale(A,g,I),this.applyMatrix4(SA),this}lookAt(A){return xB.lookAt(A),xB.updateMatrix(),this.applyMatrix4(xB.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Zg).negate(),this.translate(Zg.x,Zg.y,Zg.z),this}setFromPoints(A){const g=this.getAttribute("position");if(g===void 0){const I=[];for(let B=0,Q=A.length;B<Q;B++){const t=A[B];I.push(t.x,t.y,t.z||0)}this.setAttribute("position",new bI(I,3))}else{const I=Math.min(A.length,g.count);for(let B=0;B<I;B++){const Q=A[B];g.setXYZ(B,Q.x,Q.y,Q.z||0)}A.length>g.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),g.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Rg);const A=this.attributes.position,g=this.morphAttributes.position;if(A&&A.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new D(-1/0,-1/0,-1/0),new D(1/0,1/0,1/0));return}if(A!==void 0){if(this.boundingBox.setFromBufferAttribute(A),g)for(let I=0,B=g.length;I<B;I++){const Q=g[I];pA.setFromBufferAttribute(Q),this.morphTargetsRelative?(eA.addVectors(this.boundingBox.min,pA.min),this.boundingBox.expandByPoint(eA),eA.addVectors(this.boundingBox.max,pA.max),this.boundingBox.expandByPoint(eA)):(this.boundingBox.expandByPoint(pA.min),this.boundingBox.expandByPoint(pA.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error(\'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.\',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new LQ);const A=this.attributes.position,g=this.morphAttributes.position;if(A&&A.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new D,1/0);return}if(A){const I=this.boundingSphere.center;if(pA.setFromBufferAttribute(A),g)for(let Q=0,t=g.length;Q<t;Q++){const C=g[Q];sI.setFromBufferAttribute(C),this.morphTargetsRelative?(eA.addVectors(pA.min,sI.min),pA.expandByPoint(eA),eA.addVectors(pA.max,sI.max),pA.expandByPoint(eA)):(pA.expandByPoint(sI.min),pA.expandByPoint(sI.max))}pA.getCenter(I);let B=0;for(let Q=0,t=A.count;Q<t;Q++)eA.fromBufferAttribute(A,Q),B=Math.max(B,I.distanceToSquared(eA));if(g)for(let Q=0,t=g.length;Q<t;Q++){const C=g[Q],i=this.morphTargetsRelative;for(let s=0,a=C.count;s<a;s++)eA.fromBufferAttribute(C,s),i&&(Zg.fromBufferAttribute(A,s),eA.add(Zg)),B=Math.max(B,I.distanceToSquared(eA))}this.boundingSphere.radius=Math.sqrt(B),isNaN(this.boundingSphere.radius)&&console.error(\'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.\',this)}}computeTangents(){const A=this.index,g=this.attributes;if(A===null||g.position===void 0||g.normal===void 0||g.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const I=g.position,B=g.normal,Q=g.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Hg(new Float32Array(4*I.count),4));const t=this.getAttribute("tangent"),C=[],i=[];for(let d=0;d<I.count;d++)C[d]=new D,i[d]=new D;const s=new D,a=new D,e=new D,n=new dA,o=new dA,r=new dA,h=new D,c=new D;function w(d,G,f){s.fromBufferAttribute(I,d),a.fromBufferAttribute(I,G),e.fromBufferAttribute(I,f),n.fromBufferAttribute(Q,d),o.fromBufferAttribute(Q,G),r.fromBufferAttribute(Q,f),a.sub(s),e.sub(s),o.sub(n),r.sub(n);const N=1/(o.x*r.y-r.x*o.y);isFinite(N)&&(h.copy(a).multiplyScalar(r.y).addScaledVector(e,-o.y).multiplyScalar(N),c.copy(e).multiplyScalar(o.x).addScaledVector(a,-r.x).multiplyScalar(N),C[d].add(h),C[G].add(h),C[f].add(h),i[d].add(c),i[G].add(c),i[f].add(c))}let y=this.groups;y.length===0&&(y=[{start:0,count:A.count}]);for(let d=0,G=y.length;d<G;++d){const f=y[d],N=f.start,k=f.count;for(let R=N,J=N+k;R<J;R+=3)w(A.getX(R+0),A.getX(R+1),A.getX(R+2))}const l=new D,u=new D,M=new D,F=new D;function p(d){M.fromBufferAttribute(B,d),F.copy(M);const G=C[d];l.copy(G),l.sub(M.multiplyScalar(M.dot(G))).normalize(),u.crossVectors(F,G);const N=u.dot(i[d])<0?-1:1;t.setXYZW(d,l.x,l.y,l.z,N)}for(let d=0,G=y.length;d<G;++d){const f=y[d],N=f.start,k=f.count;for(let R=N,J=N+k;R<J;R+=3)p(A.getX(R+0)),p(A.getX(R+1)),p(A.getX(R+2))}}computeVertexNormals(){const A=this.index,g=this.getAttribute("position");if(g!==void 0){let I=this.getAttribute("normal");if(I===void 0)I=new Hg(new Float32Array(g.count*3),3),this.setAttribute("normal",I);else for(let n=0,o=I.count;n<o;n++)I.setXYZ(n,0,0,0);const B=new D,Q=new D,t=new D,C=new D,i=new D,s=new D,a=new D,e=new D;if(A)for(let n=0,o=A.count;n<o;n+=3){const r=A.getX(n+0),h=A.getX(n+1),c=A.getX(n+2);B.fromBufferAttribute(g,r),Q.fromBufferAttribute(g,h),t.fromBufferAttribute(g,c),a.subVectors(t,Q),e.subVectors(B,Q),a.cross(e),C.fromBufferAttribute(I,r),i.fromBufferAttribute(I,h),s.fromBufferAttribute(I,c),C.add(a),i.add(a),s.add(a),I.setXYZ(r,C.x,C.y,C.z),I.setXYZ(h,i.x,i.y,i.z),I.setXYZ(c,s.x,s.y,s.z)}else for(let n=0,o=g.count;n<o;n+=3)B.fromBufferAttribute(g,n+0),Q.fromBufferAttribute(g,n+1),t.fromBufferAttribute(g,n+2),a.subVectors(t,Q),e.subVectors(B,Q),a.cross(e),I.setXYZ(n+0,a.x,a.y,a.z),I.setXYZ(n+1,a.x,a.y,a.z),I.setXYZ(n+2,a.x,a.y,a.z);this.normalizeNormals(),I.needsUpdate=!0}}normalizeNormals(){const A=this.attributes.normal;for(let g=0,I=A.count;g<I;g++)eA.fromBufferAttribute(A,g),eA.normalize(),A.setXYZ(g,eA.x,eA.y,eA.z)}toNonIndexed(){function A(C,i){const s=C.array,a=C.itemSize,e=C.normalized,n=new s.constructor(i.length*a);let o=0,r=0;for(let h=0,c=i.length;h<c;h++){C.isInterleavedBufferAttribute?o=i[h]*C.data.stride+C.offset:o=i[h]*a;for(let w=0;w<a;w++)n[r++]=s[o++]}return new Hg(n,a,e)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const g=new HI,I=this.index.array,B=this.attributes;for(const C in B){const i=B[C],s=A(i,I);g.setAttribute(C,s)}const Q=this.morphAttributes;for(const C in Q){const i=[],s=Q[C];for(let a=0,e=s.length;a<e;a++){const n=s[a],o=A(n,I);i.push(o)}g.morphAttributes[C]=i}g.morphTargetsRelative=this.morphTargetsRelative;const t=this.groups;for(let C=0,i=t.length;C<i;C++){const s=t[C];g.addGroup(s.start,s.count,s.materialIndex)}return g}toJSON(){const A={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(A.uuid=this.uuid,A.type=this.type,this.name!==""&&(A.name=this.name),Object.keys(this.userData).length>0&&(A.userData=this.userData),this.parameters!==void 0){const i=this.parameters;for(const s in i)i[s]!==void 0&&(A[s]=i[s]);return A}A.data={attributes:{}};const g=this.index;g!==null&&(A.data.index={type:g.array.constructor.name,array:Array.prototype.slice.call(g.array)});const I=this.attributes;for(const i in I){const s=I[i];A.data.attributes[i]=s.toJSON(A.data)}const B={};let Q=!1;for(const i in this.morphAttributes){const s=this.morphAttributes[i],a=[];for(let e=0,n=s.length;e<n;e++){const o=s[e];a.push(o.toJSON(A.data))}a.length>0&&(B[i]=a,Q=!0)}Q&&(A.data.morphAttributes=B,A.data.morphTargetsRelative=this.morphTargetsRelative);const t=this.groups;t.length>0&&(A.data.groups=JSON.parse(JSON.stringify(t)));const C=this.boundingSphere;return C!==null&&(A.data.boundingSphere={center:C.center.toArray(),radius:C.radius}),A}clone(){return new this.constructor().copy(this)}copy(A){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const g={};this.name=A.name;const I=A.index;I!==null&&this.setIndex(I.clone(g));const B=A.attributes;for(const s in B){const a=B[s];this.setAttribute(s,a.clone(g))}const Q=A.morphAttributes;for(const s in Q){const a=[],e=Q[s];for(let n=0,o=e.length;n<o;n++)a.push(e[n].clone(g));this.morphAttributes[s]=a}this.morphTargetsRelative=A.morphTargetsRelative;const t=A.groups;for(let s=0,a=t.length;s<a;s++){const e=t[s];this.addGroup(e.start,e.count,e.materialIndex)}const C=A.boundingBox;C!==null&&(this.boundingBox=C.clone());const i=A.boundingSphere;return i!==null&&(this.boundingSphere=i.clone()),this.drawRange.start=A.drawRange.start,this.drawRange.count=A.drawRange.count,this.userData=A.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const XQ=new cA,dg=new lC,ZI=new LQ,jQ=new D,KI=new D,qI=new D,WI=new D,UB=new D,VI=new D,OQ=new D,TI=new D;class PQ extends MA{constructor(A=new HI,g=new pC){super(),this.isMesh=!0,this.type="Mesh",this.geometry=A,this.material=g,this.updateMorphTargets()}copy(A,g){return super.copy(A,g),A.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=A.morphTargetInfluences.slice()),A.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},A.morphTargetDictionary)),this.material=Array.isArray(A.material)?A.material.slice():A.material,this.geometry=A.geometry,this}updateMorphTargets(){const g=this.geometry.morphAttributes,I=Object.keys(g);if(I.length>0){const B=g[I[0]];if(B!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let Q=0,t=B.length;Q<t;Q++){const C=B[Q].name||String(Q);this.morphTargetInfluences.push(0),this.morphTargetDictionary[C]=Q}}}}getVertexPosition(A,g){const I=this.geometry,B=I.attributes.position,Q=I.morphAttributes.position,t=I.morphTargetsRelative;g.fromBufferAttribute(B,A);const C=this.morphTargetInfluences;if(Q&&C){VI.set(0,0,0);for(let i=0,s=Q.length;i<s;i++){const a=C[i],e=Q[i];a!==0&&(UB.fromBufferAttribute(e,A),t?VI.addScaledVector(UB,a):VI.addScaledVector(UB.sub(g),a))}g.add(VI)}return g}raycast(A,g){const I=this.geometry,B=this.material,Q=this.matrixWorld;B!==void 0&&(I.boundingSphere===null&&I.computeBoundingSphere(),ZI.copy(I.boundingSphere),ZI.applyMatrix4(Q),dg.copy(A.ray).recast(A.near),!(ZI.containsPoint(dg.origin)===!1&&(dg.intersectSphere(ZI,jQ)===null||dg.origin.distanceToSquared(jQ)>(A.far-A.near)**2))&&(XQ.copy(Q).invert(),dg.copy(A.ray).applyMatrix4(XQ),!(I.boundingBox!==null&&dg.intersectsBox(I.boundingBox)===!1)&&this._computeIntersections(A,g,dg)))}_computeIntersections(A,g,I){let B;const Q=this.geometry,t=this.material,C=Q.index,i=Q.attributes.position,s=Q.attributes.uv,a=Q.attributes.uv1,e=Q.attributes.normal,n=Q.groups,o=Q.drawRange;if(C!==null)if(Array.isArray(t))for(let r=0,h=n.length;r<h;r++){const c=n[r],w=t[c.materialIndex],y=Math.max(c.start,o.start),l=Math.min(C.count,Math.min(c.start+c.count,o.start+o.count));for(let u=y,M=l;u<M;u+=3){const F=C.getX(u),p=C.getX(u+1),d=C.getX(u+2);B=vI(this,w,A,I,s,a,e,F,p,d),B&&(B.faceIndex=Math.floor(u/3),B.face.materialIndex=c.materialIndex,g.push(B))}}else{const r=Math.max(0,o.start),h=Math.min(C.count,o.start+o.count);for(let c=r,w=h;c<w;c+=3){const y=C.getX(c),l=C.getX(c+1),u=C.getX(c+2);B=vI(this,t,A,I,s,a,e,y,l,u),B&&(B.faceIndex=Math.floor(c/3),g.push(B))}}else if(i!==void 0)if(Array.isArray(t))for(let r=0,h=n.length;r<h;r++){const c=n[r],w=t[c.materialIndex],y=Math.max(c.start,o.start),l=Math.min(i.count,Math.min(c.start+c.count,o.start+o.count));for(let u=y,M=l;u<M;u+=3){const F=u,p=u+1,d=u+2;B=vI(this,w,A,I,s,a,e,F,p,d),B&&(B.faceIndex=Math.floor(u/3),B.face.materialIndex=c.materialIndex,g.push(B))}}else{const r=Math.max(0,o.start),h=Math.min(i.count,o.start+o.count);for(let c=r,w=h;c<w;c+=3){const y=c,l=c+1,u=c+2;B=vI(this,t,A,I,s,a,e,y,l,u),B&&(B.faceIndex=Math.floor(c/3),g.push(B))}}}}function mC(E,A,g,I,B,Q,t,C){let i;if(A.side===QC?i=I.intersectTriangle(t,Q,B,!0,C):i=I.intersectTriangle(B,Q,t,A.side===hB,C),i===null)return null;TI.copy(C),TI.applyMatrix4(E.matrixWorld);const s=g.ray.origin.distanceTo(TI);return s<g.near||s>g.far?null:{distance:s,point:TI.clone(),object:E}}function vI(E,A,g,I,B,Q,t,C,i,s){E.getVertexPosition(C,KI),E.getVertexPosition(i,qI),E.getVertexPosition(s,WI);const a=mC(E,A,g,I,KI,qI,WI,OQ);if(a){const e=new D;qA.getBarycoord(OQ,KI,qI,WI,e),B&&(a.uv=qA.getInterpolatedAttribute(B,C,i,s,e,new dA)),Q&&(a.uv1=qA.getInterpolatedAttribute(Q,C,i,s,e,new dA)),t&&(a.normal=qA.getInterpolatedAttribute(t,C,i,s,e,new D),a.normal.dot(I.direction)>0&&a.normal.multiplyScalar(-1));const n={a:C,b:i,c:s,normal:new D,materialIndex:0};qA.getNormal(KI,qI,WI,n.normal),a.face=n,a.barycoord=e}return a}function SC(E){const A={};for(const g in E){A[g]={};for(const I in E[g]){const B=E[g][I];B&&(B.isColor||B.isMatrix3||B.isMatrix4||B.isVector2||B.isVector3||B.isVector4||B.isTexture||B.isQuaternion)?B.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),A[g][I]=null):A[g][I]=B.clone():Array.isArray(B)?A[g][I]=B.slice():A[g][I]=B}}return A}function YC(E){const A=[];for(let g=0;g<E.length;g++)A.push(E[g].clone());return A}var xC=`void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}`,UC=`void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}`;class LC extends zQ{constructor(A){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=xC,this.fragmentShader=UC,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,A!==void 0&&this.setValues(A)}copy(A){return super.copy(A),this.fragmentShader=A.fragmentShader,this.vertexShader=A.vertexShader,this.uniforms=SC(A.uniforms),this.uniformsGroups=YC(A.uniformsGroups),this.defines=Object.assign({},A.defines),this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.fog=A.fog,this.lights=A.lights,this.clipping=A.clipping,this.extensions=Object.assign({},A.extensions),this.glslVersion=A.glslVersion,this}toJSON(A){const g=super.toJSON(A);g.glslVersion=this.glslVersion,g.uniforms={};for(const B in this.uniforms){const t=this.uniforms[B].value;t&&t.isTexture?g.uniforms[B]={type:"t",value:t.toJSON(A).uuid}:t&&t.isColor?g.uniforms[B]={type:"c",value:t.getHex()}:t&&t.isVector2?g.uniforms[B]={type:"v2",value:t.toArray()}:t&&t.isVector3?g.uniforms[B]={type:"v3",value:t.toArray()}:t&&t.isVector4?g.uniforms[B]={type:"v4",value:t.toArray()}:t&&t.isMatrix3?g.uniforms[B]={type:"m3",value:t.toArray()}:t&&t.isMatrix4?g.uniforms[B]={type:"m4",value:t.toArray()}:g.uniforms[B]={value:t}}Object.keys(this.defines).length>0&&(g.defines=this.defines),g.vertexShader=this.vertexShader,g.fragmentShader=this.fragmentShader,g.lights=this.lights,g.clipping=this.clipping;const I={};for(const B in this.extensions)this.extensions[B]===!0&&(I[B]=!0);return Object.keys(I).length>0&&(g.extensions=I),g}}class _Q extends MA{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new cA,this.projectionMatrix=new cA,this.projectionMatrixInverse=new cA,this.coordinateSystem=II}copy(A,g){return super.copy(A,g),this.matrixWorldInverse.copy(A.matrixWorldInverse),this.projectionMatrix.copy(A.projectionMatrix),this.projectionMatrixInverse.copy(A.projectionMatrixInverse),this.coordinateSystem=A.coordinateSystem,this}getWorldDirection(A){return super.getWorldDirection(A).negate()}updateMatrixWorld(A){super.updateMatrixWorld(A),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(A,g){super.updateWorldMatrix(A,g),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class $Q extends MA{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new yg,this.environmentIntensity=1,this.environmentRotation=new yg,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(A,g){return super.copy(A,g),A.background!==null&&(this.background=A.background.clone()),A.environment!==null&&(this.environment=A.environment.clone()),A.fog!==null&&(this.fog=A.fog.clone()),this.backgroundBlurriness=A.backgroundBlurriness,this.backgroundIntensity=A.backgroundIntensity,this.backgroundRotation.copy(A.backgroundRotation),this.environmentIntensity=A.environmentIntensity,this.environmentRotation.copy(A.environmentRotation),A.overrideMaterial!==null&&(this.overrideMaterial=A.overrideMaterial.clone()),this.matrixAutoUpdate=A.matrixAutoUpdate,this}toJSON(A){const g=super.toJSON(A);return this.fog!==null&&(g.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(g.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(g.object.backgroundIntensity=this.backgroundIntensity),g.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(g.object.environmentIntensity=this.environmentIntensity),g.object.environmentRotation=this.environmentRotation.toArray(),g}}class bC extends vA{constructor(A=null,g=1,I=1,B,Q,t,C,i,s=Cg,a=Cg,e,n){super(null,t,C,i,s,a,B,Q,e,n),this.isDataTexture=!0,this.image={data:A,width:g,height:I},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class zI extends HI{constructor(A=1,g=1,I=1,B=1){super(),this.type="PlaneGeometry",this.parameters={width:A,height:g,widthSegments:I,heightSegments:B};const Q=A/2,t=g/2,C=Math.floor(I),i=Math.floor(B),s=C+1,a=i+1,e=A/C,n=g/i,o=[],r=[],h=[],c=[];for(let w=0;w<a;w++){const y=w*n-t;for(let l=0;l<s;l++){const u=l*e-Q;r.push(u,-y,0),h.push(0,0,1),c.push(l/C),c.push(1-w/i)}}for(let w=0;w<i;w++)for(let y=0;y<C;y++){const l=y+s*w,u=y+s*(w+1),M=y+1+s*(w+1),F=y+1+s*w;o.push(l,u,F),o.push(u,M,F)}this.setIndex(o),this.setAttribute("position",new bI(r,3)),this.setAttribute("normal",new bI(h,3)),this.setAttribute("uv",new bI(c,2))}copy(A){return super.copy(A),this.parameters=Object.assign({},A.parameters),this}static fromJSON(A){return new zI(A.width,A.height,A.widthSegments,A.heightSegments)}}class LB extends LC{constructor(A){super(A),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class bB{constructor(A,g,I,B){bB.prototype.isMatrix2=!0,this.elements=[1,0,0,1],A!==void 0&&this.set(A,g,I,B)}identity(){return this.set(1,0,0,1),this}fromArray(A,g=0){for(let I=0;I<4;I++)this.elements[I]=A[I+g];return this}set(A,g,I,B){const Q=this.elements;return Q[0]=A,Q[2]=g,Q[1]=I,Q[3]=B,this}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:hQ}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=hQ);const WA=-9,Ag=(9-WA)/254,HB=Math.exp(WA),HC=11,ZC=11,v=1<<HC,zA=1<<ZC,At=1,gt=!0;function Kg(E){return E==="int"||E==="ivec2"||E==="ivec3"||E==="ivec4"}function qg(E){return E==="uint"||E==="uvec2"||E==="uvec3"||E==="uvec4"}function KC(E){return E==="float"||E==="vec2"||E==="vec3"||E==="vec4"}function qC(E){return E==="mat2"||E==="mat2x2"||E==="mat2x3"||E==="mat2x4"||E==="mat3"||E==="mat3x2"||E==="mat3x3"||E==="mat3x4"||E==="mat4"||E==="mat4x2"||E==="mat4x3"||E==="mat4x4"}function XI(E){return KC(E)||qC(E)}function Wg(E){return E==="mat2"||E==="mat2x2"}function Vg(E){return E==="mat3"||E==="mat3x3"}function Tg(E){return E==="mat4"||E==="mat4x4"}function CA(E){return Math.trunc(E).toString()}function EA(E){return`${Math.max(0,Math.trunc(E)).toString()}u`}function V(E){return E===Number.POSITIVE_INFINITY?"INFINITY":E===Number.NEGATIVE_INFINITY?"-INFINITY":Number.isInteger(E)?E.toFixed(1):E.toString()}function Mg(E){return E instanceof Gg?E.type:E.dynoOut().type}class Gg{constructor(A){this.__isDynoValue=!0,this.type=A}}class fA extends Gg{constructor(A,g){super(A.outTypes[g]),this.dyno=A,this.key=g}}class jI extends Gg{constructor(A,g){super(A),this.literal=g}getLiteral(){return this.literal}}class WC extends jI{constructor(A,g){super(A,""),this.value=g}getLiteral(){const{type:A,value:g}=this;switch(A){case"bool":return g?"true":"false";case"uint":return EA(g);case"int":return CA(g);case"float":return V(g);case"bvec2":{const I=g;return`bvec2(${I[0]}, ${I[1]})`}case"uvec2":{if(g instanceof dA)return`uvec2(${EA(g.x)}, ${EA(g.y)})`;const I=g;return`uvec2(${EA(I[0])}, ${EA(I[1])})`}case"ivec2":{if(g instanceof dA)return`ivec2(${CA(g.x)}, ${CA(g.y)})`;const I=g;return`ivec2(${CA(I[0])}, ${CA(I[1])})`}case"vec2":{if(g instanceof dA)return`vec2(${V(g.x)}, ${V(g.y)})`;const I=g;return`vec2(${V(I[0])}, ${V(I[1])})`}case"bvec3":{const I=g;return`bvec3(${I[0]}, ${I[1]}, ${I[2]})`}case"uvec3":{if(g instanceof D)return`uvec3(${EA(g.x)}, ${EA(g.y)}, ${EA(g.z)})`;const I=g;return`uvec3(${EA(I[0])}, ${EA(I[1])}, ${EA(I[2])})`}case"ivec3":{if(g instanceof D)return`ivec3(${CA(g.x)}, ${CA(g.y)}, ${CA(g.z)})`;const I=g;return`ivec3(${CA(I[0])}, ${CA(I[1])}, ${CA(I[2])})`}case"vec3":{if(g instanceof D)return`vec3(${V(g.x)}, ${V(g.y)}, ${V(g.z)})`;const I=g;return`vec3(${V(I[0])}, ${V(I[1])}, ${V(I[2])})`}case"bvec4":{const I=g;return`bvec4(${I[0]}, ${I[1]}, ${I[2]}, ${I[3]})`}case"uvec4":{if(g instanceof lA)return`uvec4(${EA(g.x)}, ${EA(g.y)}, ${EA(g.z)}, ${EA(g.w)})`;const I=g;return`uvec4(${EA(I[0])}, ${EA(I[1])}, ${EA(I[2])}, ${EA(I[3])})`}case"ivec4":{if(g instanceof lA)return`ivec4(${CA(g.x)}, ${CA(g.y)}, ${CA(g.z)}, ${CA(g.w)})`;const I=g;return`ivec4(${CA(I[0])}, ${CA(I[1])}, ${CA(I[2])}, ${CA(I[3])})`}case"vec4":{if(g instanceof lA)return`vec4(${V(g.x)}, ${V(g.y)}, ${V(g.z)}, ${V(g.w)})`;if(g instanceof sA)return`vec4(${V(g.x)}, ${V(g.y)}, ${V(g.z)}, ${V(g.w)})`;const I=g;return`vec4(${V(I[0])}, ${V(I[1])}, ${V(I[2])}, ${V(I[3])})`}case"mat2":case"mat2x2":{const I=g,B=I instanceof bB?I.elements:g,Q=new Array(4).fill(0).map((t,C)=>V(B[C]));return`${A}(${Q.join(", ")})`}case"mat2x3":{const I=g,B=new Array(6).fill(0).map((Q,t)=>V(I[t]));return`${A}(${B.join(", ")})`}case"mat2x4":{const I=g,B=new Array(8).fill(0).map((Q,t)=>V(I[t]));return`${A}(${B.join(", ")})`}case"mat3":case"mat3x3":{const I=g,B=I instanceof TA?I.elements:g,Q=new Array(9).fill(0).map((t,C)=>V(B[C]));return`${A}(${Q.join(", ")})`}case"mat3x2":{const I=g,B=new Array(6).fill(0).map((Q,t)=>V(I[t]));return`${A}(${B.join(", ")})`}case"mat3x4":{const I=g,B=new Array(12).fill(0).map((Q,t)=>V(I[t]));return`${A}(${B.join(", ")})`}case"mat4":case"mat4x4":{const I=g,B=I instanceof cA?I.elements:g,Q=new Array(16).fill(0).map((t,C)=>V(B[C]));return`${A}(${Q.join(", ")})`}case"mat4x2":{const I=g,B=new Array(8).fill(0).map((Q,t)=>V(I[t]));return`${A}(${B.join(", ")})`}case"mat4x3":{const I=g,B=new Array(12).fill(0).map((Q,t)=>V(I[t]));return`${A}(${B.join(", ")})`}default:throw new Error(`Type not implemented: ${String(A)}`)}}}function VC(E,A){return new WC(E,A)}const It="    ";class TC{constructor({indent:A}={}){this.globals=new Set,this.statements=[],this.uniforms={},this.declares=new Set,this.updaters=[],this.sequence=0,this.indent=It,this.indent=A??It}nextSequence(){return this.sequence++}}class DA{constructor({inTypes:A,outTypes:g,inputs:I,update:B,globals:Q,statements:t,generate:C}){this.inTypes=A??{},this.outTypes=g??{},this.inputs=I??{},this.update=B,this.globals=Q,this.statements=t,this.generate=C??(({inputs:i,outputs:s,compile:a})=>{var e,n;return{globals:(e=this.globals)==null?void 0:e.call(this,{inputs:i,outputs:s,compile:a}),statements:(n=this.statements)==null?void 0:n.call(this,{inputs:i,outputs:s,compile:a})}})}get outputs(){const A={};for(const g in this.outTypes)A[g]=new fA(this,g);return A}apply(A){return Object.assign(this.inputs,A),this.outputs}compile({inputs:A,outputs:g,compile:I}){const B=[`// ${this.constructor.name}(${Object.values(A).join(", ")}) => (${Object.values(g).join(", ")})`],Q=[];for(const s in g){const a=g[s];a&&!I.declares.has(a)&&(I.declares.add(a),Q.push(s))}const{globals:t,statements:C,uniforms:i}=this.generate({inputs:A,outputs:g,compile:I});for(const s of t??[])I.globals.add(s);for(const s in i)I.uniforms[s]=i[s];this.update&&I.updaters.push(this.update);for(const s of Q){const a=g[s];a&&(I.uniforms[a]||B.push(`${Bt(a,this.outTypes[s])};`))}return C!=null&&C.length&&(B.push("{"),B.push(...C.map(s=>I.indent+s)),B.push("}")),B}}class vC extends DA{constructor({inTypes:A,outTypes:g,inputs:I,update:B,globals:Q,construct:t}){super({inTypes:A,outTypes:g,inputs:I,update:B,globals:Q,generate:C=>this.generateBlock(C)}),this.construct=t}generateBlock({inputs:A,outputs:g,compile:I}){var r,h;const B={},Q={};for(const c in A)A[c]!=null&&(B[c]=new jI(this.inTypes[c],A[c]));for(const c in g)g[c]!=null&&(Q[c]=new Gg(this.outTypes[c]));const t={roots:[]},C=this.construct(B,Q,t);for(const c of((r=this.globals)==null?void 0:r.call(this,{inputs:A,outputs:g,compile:I}))??[])I.globals.add(c);const i=[],s=new Map;function a(c,w,y){let l=s.get(c);if(!l){l={sequence:I.nextSequence(),outNames:new Map,newOuts:new Set},s.set(c,l);for(const u in c.inputs){let M=c.inputs[u];for(;M;){if(M instanceof Gg){M instanceof fA&&a(M.dyno,M.key);break}M=M.dynoOut()}}i.push(c)}w&&(y||l.newOuts.add(w),l.outNames.set(w,y??`${w}_${l.sequence}`))}for(const c of t.roots)a(c);for(const c in Q){let w=(C==null?void 0:C[c])??Q[c];for(;w;){if(w instanceof Gg){w instanceof fA&&a(w.dyno,w.key,g[c]);break}w=w.dynoOut()}Q[c]=w}const e=[];for(const c of i){const w={},y={};for(const M in c.inputs){let F=c.inputs[M];for(;F;){if(F instanceof Gg){if(F instanceof jI)w[M]=F.getLiteral();else if(F instanceof fA){const p=(h=s.get(F.dyno))==null?void 0:h.outNames.get(F.key);if(!p)throw new Error(`Source not found for ${F.dyno.constructor.name}.${F.key}`);w[M]=p}break}F=F.dynoOut()}}const l=s.get(c)??{outNames:new Map};for(const[M,F]of l.outNames.entries())y[M]=F;const u=c.compile({inputs:w,outputs:y,compile:I});e.push(u)}const n=[];for(const c in g)Q[c]instanceof jI&&n.push(`${g[c]} = ${Q[c].getLiteral()};`);return n.length>0&&e.push(n),{statements:e.flatMap((c,w)=>w===0?c:["",...c])}}}function OI(E,A,g,{update:I,globals:B}={}){return new vC({inTypes:E,outTypes:A,construct:g,update:I,globals:B})}function ZB({inTypes:E,outTypes:A,inputs:g,update:I,globals:B,statements:Q,generate:t}){return new DA({inTypes:E,outTypes:A,inputs:g,update:I,globals:B,statements:Q,generate:t})}function Bt(E,A,g){const I=typeof A=="string"?A:A.type;if(!I)throw new Error(`Invalid DynoType: ${String(A)}`);return`${I} ${E}${g!=null?`[${g}]`:""}`}function gg(E){var Q;let A=!1;const g=E.split(`\n`).map(t=>{const C=t.trimEnd();return A?C:C.length>0?(A=!0,C):null}).filter(t=>t!=null);for(;g.length>0&&g[g.length-1].length===0;)g.pop();if(g.length===0)return[];const I=(Q=g[0].match(/^\\s*/))==null?void 0:Q[0];if(!I)return g;const B=new RegExp(`^${I}`);return g.map(t=>t.replace(B,""))}function VA(E){return gg(E).join(`\n`)}class zC extends DA{constructor({a:A,outKey:g,outTypeFunc:I}){const B={a:Mg(A)},Q=I(Mg(A)),t={[g]:Q};super({inTypes:B,outTypes:t,inputs:{a:A}}),this.outKey=g}dynoOut(){return new fA(this,this.outKey)}}class PI extends DA{constructor({a:A,b:g,outKey:I,outTypeFunc:B}){const Q={a:Mg(A),b:Mg(g)},t=B(Mg(A),Mg(g)),C={[I]:t};super({inTypes:Q,outTypes:C,inputs:{a:A,b:g}}),this.outKey=I}dynoOut(){return new fA(this,this.outKey)}}const KB=new Float32Array(1),Qt=new Uint32Array(KB.buffer);function vg(E){KB[0]=E;const A=Qt[0],g=A>>31&1,I=A>>23&255,B=A&8388607,Q=g<<15;if(I===255)return B!==0?Q|32767:Q|31744;const t=I-127+15;if(t>=31)return Q|31744;if(t<=0){if(t<-10)return Q;const i=(B|8388608)>>1-t+13;return Q|i}const C=B>>13;return Q|t<<10|C}function gA(E){const A=E>>15&1,g=E>>10&31,I=E&1023;let B;if(g===0)if(I===0)B=A<<31;else{let Q=I,t=-14;for(;(Q&1024)===0;)Q<<=1,t--;Q&=1023;const C=t+127,i=Q<<13;B=A<<31|C<<23|i}else if(g===31)I===0?B=A<<31|2139095040:B=A<<31|2143289344;else{const Q=g-15+127,t=I<<13;B=A<<31|Q<<23|t}return Qt[0]=B,KB[0]}function og(E){return Math.max(0,Math.min(255,Math.round(E*255)))}function tt(E){const A=[],g=new Set;function I(B){B&&typeof B=="object"&&!g.has(B)&&(g.add(B),B instanceof ArrayBuffer?A.push(B):ArrayBuffer.isView(B)?A.push(B.buffer):Array.isArray(B)?B.forEach(I):Object.values(B).forEach(I))}return I(E),A}function eI(E,A,g,I,B,Q,t,C,i,s,a,e,n,o,r,h){const c=og(o),w=og(r),y=og(h),l=og(n),u=Ct(new sA(i,s,a,e)),M=u&255,F=u>>>8&255,p=u>>>16&255,d=Q===0?0:Math.min(255,Math.max(0,Math.round((Math.log(Q)-WA)/Ag)+1)),G=t===0?0:Math.min(255,Math.max(0,Math.round((Math.log(t)-WA)/Ag)+1)),f=C===0?0:Math.min(255,Math.max(0,Math.round((Math.log(C)-WA)/Ag)+1)),N=vg(g),k=vg(I),R=vg(B),J=A*4;E[J]=c|w<<8|y<<16|l<<24,E[J+1]=N|k<<16,E[J+2]=R|M<<16|F<<24,E[J+3]=d|G<<8|f<<16|p<<24}function XC(E,A,g,I,B){const Q=vg(g),t=vg(I),C=vg(B),i=A*4;E[i+1]=Q|t<<16,E[i+2]=C|E[i+2]&4294901760}function jC(E,A,g,I,B){const Q=g===0?0:Math.min(255,Math.max(0,Math.round((Math.log(g)-WA)/Ag)+1)),t=I===0?0:Math.min(255,Math.max(0,Math.round((Math.log(I)-WA)/Ag)+1)),C=B===0?0:Math.min(255,Math.max(0,Math.round((Math.log(B)-WA)/Ag)+1)),i=A*4;E[i+3]=Q|t<<8|C<<16|E[i+3]&4278190080}function OC(E,A,g,I,B,Q){const t=Ct(new sA(g,I,B,Q)),C=t&255,i=t>>>8&255,s=t>>>16&255,a=A*4;E[a+2]=E[a+2]&65535|C<<16|i<<24,E[a+3]=E[a+3]&16777215|s<<24}function PC(E,A,g,I,B){const Q=og(g),t=og(I),C=og(B),i=A*4;E[i]=Q|t<<8|C<<16|E[i]&4278190080}function _C(E,A,g){const I=og(g),B=A*4;E[B]=E[B]&16777215|I<<24}const $C=new D,AE=new D,gE=new sA,IE=new ug,BE={center:$C,scales:AE,quaternion:gE,color:IE,opacity:0};function qB(E,A){const g=BE,I=A*4,B=E[I],Q=E[I+1],t=E[I+2],C=E[I+3];g.color.set((B&255)/255,(B>>>8&255)/255,(B>>>16&255)/255),g.opacity=(B>>>24&255)/255,g.center.set(gA(Q&65535),gA(Q>>>16&65535),gA(t&65535));const i=C&255;g.scales.x=i===0?0:Math.exp(WA+(i-1)*Ag);const s=C>>>8&255;g.scales.y=s===0?0:Math.exp(WA+(s-1)*Ag);const a=C>>>16&255;g.scales.z=a===0?0:Math.exp(WA+(a-1)*Ag);const e=t>>>16&65535|C>>>8&16711680;return tE(e,g.quaternion),g}function RA(E){const A=v,g=Math.max(At,Math.min(zA,Math.ceil(E/A))),I=Math.ceil(E/(A*g)),B=A*g*I;return{width:A,height:g,depth:I,maxSplats:B}}function WB(E){const A=v,g=Math.max(At,Math.min(zA,Math.ceil(E/A))),I=Math.ceil(E/(A*g));return A*g*I}const QE=VA(`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n`);function Ct(E){const A=E.clone().normalize();A.w<0&&A.set(-A.x,-A.y,-A.z,-A.w);const g=2*Math.acos(A.w),I=Math.sqrt(A.x*A.x+A.y*A.y+A.z*A.z),B=I<1e-6?new D(1,0,0):new D(A.x,A.y,A.z).divideScalar(I),Q=Math.abs(B.x)+Math.abs(B.y)+Math.abs(B.z);let t=B.x/Q,C=B.y/Q;if(B.z<0){const o=t;t=(1-Math.abs(C))*(t>=0?1:-1),C=(1-Math.abs(o))*(C>=0?1:-1)}const i=t*.5+.5,s=C*.5+.5,a=Math.round(i*255),e=Math.round(s*255);return Math.round(g*(255/Math.PI))<<16|e<<8|a}function tE(E,A){const g=E&255,I=E>>>8&255,B=E>>>16&255,Q=g/255,t=I/255;let C=(Q-.5)*2,i=(t-.5)*2;const s=1-(Math.abs(C)+Math.abs(i)),a=Math.max(-s,0);C+=C>=0?-a:a,i+=i>=0?-a:a;const e=new D(C,i,s).normalize(),o=B/255*Math.PI*.5,r=Math.sin(o),h=Math.cos(o);return A.set(e.x*r,e.y*r,e.z*r,h),A}function _I(E,A,g,I){const B=Math.max(-127,Math.min(127,E*127)),Q=Math.max(-127,Math.min(127,A*127)),t=Math.max(-127,Math.min(127,g*127)),C=Math.max(-127,Math.min(127,I*127));return B&255|(Q&255)<<8|(t&255)<<16|(C&255)<<24}function VB(E,A,g){const I=A*2;for(let B=0;B<9;++B){const Q=Math.max(-63,Math.min(63,g[B]*63))&127,t=B*7,C=t+7,i=Math.floor(t/32),s=t-i*32,a=Q<<s&4294967295;if(E[I+i]|=a,C>i*32+32){const e=Q>>>32-s&4294967295;E[I+i+1]|=e}}}function TB(E,A,g){E[A*4+0]=_I(g[0],g[1],g[2],g[3]),E[A*4+1]=_I(g[4],g[5],g[6],g[7]),E[A*4+2]=_I(g[8],g[9],g[10],g[11]),E[A*4+3]=_I(g[12],g[13],g[14],0)}function vB(E,A,g){const I=A*4;for(let B=0;B<21;++B){const Q=Math.max(-31,Math.min(31,g[B]*31))&63,t=B*6,C=t+6,i=Math.floor(t/32),s=t-i*32,a=Q<<s&4294967295;if(E[I+i]|=a,C>i*32+32){const e=Q>>>32-s&4294967295;E[I+i+1]|=e}}}function CE(E,A){const g=[];let I=0,B=null;const Q=new rQ((i,s)=>{if(g.push(i),I+=i.length,s||I>=A){const a=new Uint8Array(I);let e=0;for(const n of g)a.set(n,e),e+=n.length;B=a.slice(0,A)}}),t=1024;let C=0;for(;B==null&&C<E.length;){const i=E.slice(C,C+t);Q.push(i,!1),C+=t}if(B==null&&(Q.push(new Uint8Array,!0),B==null))throw new Error("Failed to decompress partial gzip");return B}class EE{constructor({fileBytes:A,chunkBytes:g=64*1024}){this.fileBytes=A,this.chunkBytes=g,this.offset=0,this.chunks=[],this.totalBytes=0,this.gunzip=new rQ((I,B)=>{this.chunks.push(I),this.totalBytes+=I.length})}read(A){for(;this.totalBytes<A&&this.offset<this.fileBytes.length;){const Q=Math.min(this.offset+this.chunkBytes,this.fileBytes.length);this.gunzip.push(this.fileBytes.subarray(this.offset,Q),!1),this.offset=Q}if(this.totalBytes<A&&this.offset>=this.fileBytes.length&&this.gunzip.push(new Uint8Array(0),!0),this.totalBytes<A)throw new Error(`Unexpected EOF: needed ${A}, got ${this.totalBytes}`);const g=new Uint8Array(this.totalBytes);let I=0;for(const Q of this.chunks)g.set(Q,I),I+=Q.length;const B=g.subarray(0,A);return this.chunks=[g.subarray(A)],this.totalBytes-=A,B}}function Et(E,A,g){const I=Math.floor(E.length/32);if(I*32!==E.length)throw new Error("Invalid .splat file size");A(I);const B=new Float32Array(E.buffer);for(let Q=0;Q<I;++Q){const t=Q*32,C=Q*8,i=B[C+0],s=B[C+1],a=B[C+2],e=B[C+3],n=B[C+4],o=B[C+5],r=E[t+24]/255,h=E[t+25]/255,c=E[t+26]/255,w=E[t+27]/255,y=(E[t+28]-128)/128,l=(E[t+29]-128)/128,u=(E[t+30]-128)/128,M=(E[t+31]-128)/128;g(Q,i,s,a,e,n,o,l,u,M,y,w,r,h,c)}}function iE(E){let A=0,g=0,I=new Uint32Array(0);return Et(E,B=>{A=B,g=WB(A),I=new Uint32Array(g*4)},(B,Q,t,C,i,s,a,e,n,o,r,h,c,w,y)=>{eI(I,B,Q,t,C,i,s,a,e,n,o,r,h,c,w,y)}),{packedArray:I,numSplats:A}}const $I={0:{bytesPerCenter:12,bytesPerScale:12,bytesPerRotation:16,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:4,scaleOffsetBytes:12,rotationOffsetBytes:24,colorOffsetBytes:40,sphericalHarmonicsOffsetBytes:44,scaleRange:1},1:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:2,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767},2:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:1,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767}},it={0:0,1:9,2:24,3:45};function sE(E,A,g,I){var o;let t=0;const C=new DataView(E.buffer,t,4096);t+=4096;const i=C.getUint8(0),s=C.getUint8(1);if(i!==0||s<1)throw new Error(`Unsupported .ksplat version: ${i}.${s}`);const a=C.getUint32(4,!0);C.getUint32(16,!0);const e=C.getUint16(20,!0);if(e<0||e>2)throw new Error(`Invalid .ksplat compression level: ${e}`);C.getFloat32(36,!0),C.getFloat32(40,!0);let n=4096+a*1024;for(let r=0;r<a;++r){const h=new DataView(E.buffer,t,1024);t+=1024;const c=h.getUint32(0,!0),w=h.getUint32(4,!0),y=h.getUint32(8,!0),l=h.getUint32(12,!0),u=h.getFloat32(16,!0),M=h.getUint16(20,!0),F=(h.getUint32(24,!0)||((o=$I[e])==null?void 0:o.scaleRange))??1,d=h.getUint32(36,!0)*4,G=M*l+d,f=h.getUint16(40,!0),N=it[f],{bytesPerCenter:k,bytesPerScale:R,bytesPerRotation:J,bytesPerColor:m,bytesPerSphericalHarmonicsComponent:S,scaleOffsetBytes:Y,rotationOffsetBytes:q,colorOffsetBytes:Z,sphericalHarmonicsOffsetBytes:$}=$I[e],O=k+R+J+m+N*S,P=O*w,W=P+G,z=f>=1?new Float32Array(3*3):void 0,X=f>=2?new Float32Array(5*3):void 0,T=f>=3?new Float32Array(7*3):void 0,x=u/2/F,NA=n+d,yA=n+G,b=new DataView(E.buffer,yA,P),rA=new Float32Array(E.buffer,NA,l*3);for(let iA=0;iA<c;++iA){const L=iA*O,JA=Math.floor(iA/y),FA=e===0?b.getFloat32(L+0,!0):(b.getUint16(L+0,!0)-F)*x+rA[3*JA+0],YA=e===0?b.getFloat32(L+4,!0):(b.getUint16(L+2,!0)-F)*x+rA[3*JA+1],xA=e===0?b.getFloat32(L+8,!0):(b.getUint16(L+4,!0)-F)*x+rA[3*JA+2],U=e===0?b.getFloat32(L+Y+0,!0):gA(b.getUint16(L+Y+0,!0)),QA=e===0?b.getFloat32(L+Y+4,!0):gA(b.getUint16(L+Y+2,!0)),AA=e===0?b.getFloat32(L+Y+8,!0):gA(b.getUint16(L+Y+4,!0)),K=e===0?b.getFloat32(L+q+0,!0):gA(b.getUint16(L+q+0,!0)),Qg=e===0?b.getFloat32(L+q+4,!0):gA(b.getUint16(L+q+2,!0)),hI=e===0?b.getFloat32(L+q+8,!0):gA(b.getUint16(L+q+4,!0)),cI=e===0?b.getFloat32(L+q+12,!0):gA(b.getUint16(L+q+6,!0)),wI=b.getUint8(L+Z+0)/255,DI=b.getUint8(L+Z+1)/255,lI=b.getUint8(L+Z+2)/255,yI=b.getUint8(L+Z+3)/255;g(iA,FA,YA,xA,U,QA,AA,Qg,hI,cI,K,yI,wI,DI,lI),f>=1&&z&&(I==null||I(iA,z,X,T))}n+=W}}function eE(E){var w;let I=0;const B=new DataView(E.buffer,I,4096);I+=4096;const Q=B.getUint8(0),t=B.getUint8(1);if(Q!==0||t<1)throw new Error(`Unsupported .ksplat version: ${Q}.${t}`);const C=B.getUint32(4,!0),i=B.getUint32(16,!0),s=B.getUint16(20,!0);if(s<0||s>2)throw new Error(`Invalid .ksplat compression level: ${s}`);const a=B.getFloat32(36,!0)||-1.5,e=B.getFloat32(40,!0)||1.5,n=i,o=WB(n),r=new Uint32Array(o*4),h={};let c=4096+C*1024;for(let y=0;y<C;++y){let l=function(AA,K){if(s===0)return U.getFloat32(AA+X+K*4,!0);if(s===1)return gA(U.getUint16(AA+X+K*2,!0));const Qg=U.getUint8(AA+X+K)/255;return a+Qg*(e-a)};const u=new DataView(E.buffer,I,1024);I+=1024;const M=u.getUint32(0,!0),F=u.getUint32(4,!0),p=u.getUint32(8,!0),d=u.getUint32(12,!0),G=u.getFloat32(16,!0),f=u.getUint16(20,!0),N=(u.getUint32(24,!0)||((w=$I[s])==null?void 0:w.scaleRange))??1,R=u.getUint32(36,!0)*4,J=f*d+R,m=u.getUint16(40,!0),S=it[m],{bytesPerCenter:Y,bytesPerScale:q,bytesPerRotation:Z,bytesPerColor:$,bytesPerSphericalHarmonicsComponent:O,scaleOffsetBytes:P,rotationOffsetBytes:W,colorOffsetBytes:z,sphericalHarmonicsOffsetBytes:X}=$I[s],T=Y+q+Z+$+S*O,x=T*F,NA=x+J,yA=[0,3,6,1,4,7,2,5,8],b=[9,14,19,10,15,20,11,16,21,12,17,22,13,18,23],rA=[24,31,38,25,32,39,26,33,40,27,34,41,28,35,42,29,36,43,30,37,44],iA=m>=1?new Float32Array(3*3):void 0,L=m>=2?new Float32Array(5*3):void 0,JA=m>=3?new Float32Array(7*3):void 0,FA=G/2/N,YA=c+R,xA=c+J,U=new DataView(E.buffer,xA,x),QA=new Float32Array(E.buffer,YA,d*3);for(let AA=0;AA<M;++AA){const K=AA*T,Qg=Math.floor(AA/p),hI=s===0?U.getFloat32(K+0,!0):(U.getUint16(K+0,!0)-N)*FA+QA[3*Qg+0],cI=s===0?U.getFloat32(K+4,!0):(U.getUint16(K+2,!0)-N)*FA+QA[3*Qg+1],wI=s===0?U.getFloat32(K+8,!0):(U.getUint16(K+4,!0)-N)*FA+QA[3*Qg+2],DI=s===0?U.getFloat32(K+P+0,!0):gA(U.getUint16(K+P+0,!0)),lI=s===0?U.getFloat32(K+P+4,!0):gA(U.getUint16(K+P+2,!0)),yI=s===0?U.getFloat32(K+P+8,!0):gA(U.getUint16(K+P+4,!0)),gQ=s===0?U.getFloat32(K+W+0,!0):gA(U.getUint16(K+W+0,!0)),IQ=s===0?U.getFloat32(K+W+4,!0):gA(U.getUint16(K+W+2,!0)),wi=s===0?U.getFloat32(K+W+8,!0):gA(U.getUint16(K+W+4,!0)),Di=s===0?U.getFloat32(K+W+12,!0):gA(U.getUint16(K+W+6,!0)),li=U.getUint8(K+z+0)/255,yi=U.getUint8(K+z+1)/255,ui=U.getUint8(K+z+2)/255,di=U.getUint8(K+z+3)/255;if(eI(r,AA,hI,cI,wI,DI,lI,yI,IQ,wi,Di,gQ,di,li,yi,ui),m>=1){if(iA){h.sh1||(h.sh1=new Uint32Array(n*2));for(const[uI,dI]of yA.entries())iA[uI]=l(K,dI);VB(h.sh1,AA,iA)}if(L){h.sh2||(h.sh2=new Uint32Array(n*4));for(const[uI,dI]of b.entries())L[uI]=l(K,dI);TB(h.sh2,AA,L)}if(JA){h.sh3||(h.sh3=new Uint32Array(n*4));for(const[uI,dI]of rA.entries())JA[uI]=l(K,dI);vB(h.sh3,AA,JA)}}}c+=NA}return{packedArray:r,numSplats:n,extra:h}}const Pg=class Pg{constructor({fileBytes:A}){this.header="",this.littleEndian=!0,this.elements={},this.comments=[],this.data=null,this.numSplats=0,this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A}async parseHeader(){const g=new ReadableStream({start:t=>{t.enqueue(this.fileBytes.slice(0,65536)),t.close()}}).pipeThrough(new TextDecoderStream).getReader();this.header="";const I=`end_header\n`;for(;;){const{value:t,done:C}=await g.read();if(C)throw new Error("Failed to read header");this.header+=t;const i=this.header.indexOf(I);if(i>=0){this.header=this.header.slice(0,i+I.length);break}}const B=new TextEncoder().encode(this.header).length;this.data=new DataView(this.fileBytes.buffer,B),this.elements={};let Q=null;this.comments=[],this.header.trim().split(`\n`).forEach((t,C)=>{const i=t.trim();if(C===0){if(i!=="ply")throw new Error("Invalid PLY header");return}if(i.length===0)return;const s=i.split(" ");switch(s[0]){case"format":if(s[1]==="binary_little_endian")this.littleEndian=!0;else if(s[1]==="binary_big_endian")this.littleEndian=!1;else throw new Error(`Unsupported PLY format: ${s[1]}`);if(s[2]!=="1.0")throw new Error(`Unsupported PLY version: ${s[2]}`);break;case"end_header":break;case"comment":this.comments.push(i.slice(8));break;case"element":{const a=s[1];Q={name:a,count:Number.parseInt(s[2]),properties:{}},this.elements[a]=Q;break}case"property":if(Q==null)throw new Error("Property must be inside an element");s[1]==="list"?Q.properties[s[4]]={isList:!0,type:s[3],countType:s[2]}:Q.properties[s[2]]={isList:!1,type:s[1]};break}}),this.elements.vertex&&(this.numSplats=this.elements.vertex.count)}parseData(A){let g=0;const I=this.data;if(I==null)throw new Error("No data to parse");for(const B in this.elements){const Q=this.elements[B],{count:t,properties:C}=Q,i={},s=[];for(const[e,n]of Object.entries(C))n.isList?(i[e]=[],s.push(()=>{const o=i[e];o.length=gB[n.countType](I,g,this.littleEndian),g+=zg[n.countType];for(let r=0;r<o.length;r++)o[r]=gB[n.type](I,g,this.littleEndian),g+=zg[n.type]})):(i[e]=0,s.push(()=>{i[e]=gB[n.type](I,g,this.littleEndian),g+=zg[n.type]}));const a=A(Q)??(()=>{});for(let e=0;e<t;e++){for(const n of s)n();a(e,i)}}}parseSplats(A,g){if(this.elements.vertex==null)throw new Error("No vertex element found");let I=!1;const B=[];let Q=0,t=[],C=[],i=[],s,a,e;function n(){const w=nE[Q];t=new Array(3).fill(null).flatMap((y,l)=>[0,1,2].map((u,M)=>`f_rest_${l+M*w/3}`)),C=new Array(5).fill(null).flatMap((y,l)=>[0,1,2].map((u,M)=>`f_rest_${3+l+M*w/3}`)),i=new Array(7).fill(null).flatMap((y,l)=>[0,1,2].map((u,M)=>`f_rest_${8+l+M*w/3}`)),s=Q>=1?new Float32Array(3*3):void 0,a=Q>=2?new Float32Array(5*3):void 0,e=Q>=3?new Float32Array(7*3):void 0}function o(w,y){if(!s)throw new Error("Missing sh1");for(const[l,u]of t.entries())s[l]=y[u]*8/255-4;if(a)for(const[l,u]of C.entries())a[l]=y[u]*8/255-4;if(e)for(const[l,u]of i.entries())e[l]=y[u]*8/255-4;g==null||g(w,s,a,e)}function r(w){const{min_x:y,min_y:l,min_z:u,max_x:M,max_y:F,max_z:p,min_scale_x:d,min_scale_y:G,min_scale_z:f,max_scale_x:N,max_scale_y:k,max_scale_z:R,min_r:J,min_g:m,min_b:S,max_r:Y,max_g:q,max_b:Z}=w.properties;if(!y||!l||!u||!M||!F||!p||!d||!G||!f||!N||!k||!R||!J||!m||!S||!Y||!q||!Z)throw new Error("Missing PLY chunk properties");return I=!0,($,O)=>{const{min_x:P,min_y:W,min_z:z,max_x:X,max_y:T,max_z:x,min_scale_x:NA,min_scale_y:yA,min_scale_z:b,max_scale_x:rA,max_scale_y:iA,max_scale_z:L,min_r:JA,min_g:FA,min_b:YA,max_r:xA,max_g:U,max_b:QA}=O;B.push({min_x:P,min_y:W,min_z:z,max_x:X,max_y:T,max_z:x,min_scale_x:NA,min_scale_y:yA,min_scale_z:b,max_scale_x:rA,max_scale_y:iA,max_scale_z:L,min_r:JA,min_g:FA,min_b:YA,max_r:xA,max_g:U,max_b:QA})}}function h(w){if(g&&w.name==="sh")return Q=et(w.properties),n(),o;if(w.name!=="vertex")return null;const{packed_position:y,packed_rotation:l,packed_scale:u,packed_color:M}=w.properties;if(!y||!l||!u||!M)throw new Error("Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color");const F=Math.sqrt(2);return(p,d)=>{const G=B[p>>>8];if(G==null)throw new Error("Missing PLY chunk");const{min_x:f,min_y:N,min_z:k,max_x:R,max_y:J,max_z:m,min_scale_x:S,min_scale_y:Y,min_scale_z:q,max_scale_x:Z,max_scale_y:$,max_scale_z:O,min_r:P,min_g:W,min_b:z,max_r:X,max_g:T,max_b:x}=G,{packed_position:NA,packed_rotation:yA,packed_scale:b,packed_color:rA}=d,iA=(NA>>>21&2047)/2047*(R-f)+f,L=(NA>>>11&1023)/1023*(J-N)+N,JA=(NA&2047)/2047*(m-k)+k,FA=((yA>>>20&1023)/1023-.5)*F,YA=((yA>>>10&1023)/1023-.5)*F,xA=((yA&1023)/1023-.5)*F,U=Math.sqrt(Math.max(0,1-FA*FA-YA*YA-xA*xA)),QA=yA>>>30,AA=QA===0?FA:QA===1?U:YA,K=QA<=1?YA:QA===2?U:xA,Qg=QA<=2?xA:U,hI=QA===0?U:FA,cI=Math.exp((b>>>21&2047)/2047*(Z-S)+S),wI=Math.exp((b>>>11&1023)/1023*($-Y)+Y),DI=Math.exp((b&2047)/2047*(O-q)+q),lI=(rA>>>24&255)/255*(X-P)+P,yI=(rA>>>16&255)/255*(T-W)+W,gQ=(rA>>>8&255)/255*(x-z)+z,IQ=(rA&255)/255;A(p,iA,L,JA,cI,wI,DI,AA,K,Qg,hI,IQ,lI,yI,gQ)}}const c=w=>{if(w.name==="chunk"&&this.comments.some(T=>T.toLowerCase().includes("supersplat")))return r(w);if(I)return h(w);if(w.name!=="vertex")return null;const{x:y,y:l,z:u,scale_0:M,scale_1:F,scale_2:p,rot_0:d,rot_1:G,rot_2:f,rot_3:N,opacity:k,f_dc_0:R,f_dc_1:J,f_dc_2:m,red:S,green:Y,blue:q,alpha:Z}=w.properties;if(!y||!l||!u)throw new Error("Missing PLY properties: x, y, z");const $=M&&F&&p,O=d&&G&&f&&N,P=Z!=null?IB[Z.type]:1,W=S!=null?IB[S.type]:1,z=Y!=null?IB[Y.type]:1,X=q!=null?IB[q.type]:1;return Q=et(w.properties),n(),(T,x)=>{const NA=$?Math.exp(x.scale_0):Pg.defaultPointScale,yA=$?Math.exp(x.scale_1):Pg.defaultPointScale,b=$?Math.exp(x.scale_2):Pg.defaultPointScale,rA=O?x.rot_1:0,iA=O?x.rot_2:0,L=O?x.rot_3:0,JA=O?x.rot_0:1,FA=k!=null?1/(1+Math.exp(-x.opacity)):Z!=null?x.alpha/P:1,YA=R!=null?x.f_dc_0*AB+.5:S!=null?x.red/W:1,xA=J!=null?x.f_dc_1*AB+.5:Y!=null?x.green/z:1,U=m!=null?x.f_dc_2*AB+.5:q!=null?x.blue/X:1;if(A(T,x.x,x.y,x.z,NA,yA,b,rA,iA,L,JA,FA,YA,xA,U),g&&s){if(s)for(const[QA,AA]of t.entries())s[QA]=x[AA];if(a)for(const[QA,AA]of C.entries())a[QA]=x[AA];if(e)for(const[QA,AA]of i.entries())e[QA]=x[AA];g(T,s,a,e)}}};this.parseData(c)}injectRgba(A){let g=0;const I=this.data;if(I==null)throw new Error("No parsed data");if(A.length!==this.numSplats*4)throw new Error("Invalid RGBA array length");for(const B in this.elements){const Q=this.elements[B],{count:t,properties:C}=Q,i=[];let s=0;const a=B==="vertex";if(a){for(const e of["opacity","f_dc_0","f_dc_1","f_dc_2"])if(!C[e]||C[e].type!=="float")throw new Error(`Can\'t injectRgba due to property: ${e}`)}for(const[e,n]of Object.entries(C))if(n.isList)i.push(()=>{const o=gB[n.countType](I,g,this.littleEndian);g+=zg[n.countType],g+=o*zg[n.type]});else{if(a)if(e==="f_dc_0"||e==="f_dc_1"||e==="f_dc_2"){const o=Number.parseInt(e.slice(5));i.push(()=>{const r=(A[s+o]/255-.5)/AB;st[n.type](I,g,this.littleEndian,r)})}else e==="opacity"&&i.push(()=>{const o=Math.max(-100,Math.min(100,-Math.log(1/(A[s+3]/255)-1)));st[n.type](I,g,this.littleEndian,o)});i.push(()=>{g+=zg[n.type]})}for(let e=0;e<t;e++){for(const n of i)n();a&&(s+=4)}}}};Pg.defaultPointScale=.001;let aI=Pg;const AB=.28209479177387814,gB={char:(E,A,g)=>E.getInt8(A),uchar:(E,A,g)=>E.getUint8(A),short:(E,A,g)=>E.getInt16(A,g),ushort:(E,A,g)=>E.getUint16(A,g),int:(E,A,g)=>E.getInt32(A,g),uint:(E,A,g)=>E.getUint32(A,g),float:(E,A,g)=>E.getFloat32(A,g),double:(E,A,g)=>E.getFloat64(A,g)},st={char:(E,A,g,I)=>{E.setInt8(A,I)},uchar:(E,A,g,I)=>{E.setUint8(A,I)},short:(E,A,g,I)=>{E.setInt16(A,I,g)},ushort:(E,A,g,I)=>{E.setUint16(A,I,g)},int:(E,A,g,I)=>{E.setInt32(A,I,g)},uint:(E,A,g,I)=>{E.setUint32(A,I,g)},float:(E,A,g,I)=>{E.setFloat32(A,I,g)},double:(E,A,g,I)=>{E.setFloat64(A,I,g)}},zg={char:1,uchar:1,short:2,ushort:2,int:4,uint:4,float:4,double:8},IB={char:127,uchar:255,short:32767,ushort:65535,int:2147483647,uint:4294967295,float:1,double:1},aE={0:0,9:1,24:2,45:3},nE={0:0,1:9,2:24,3:45};function et(E){let A=0;for(;E[`f_rest_${A}`];)A+=1;const g=aE[A];if(g==null)throw new Error(`Unsupported number of SH coefficients: ${A}`);return g}const GA={type:"Gsplat"},zB={type:"PackedSplats"},oE=(E,A)=>new cE({packedSplats:E,index:A}),rE=(E,A,g,I)=>new wE({packedSplats:E,index:A,base:g,count:I}),BB=E=>new DE({gsplat:E}),XB=({gsplat:E,flags:A,index:g,center:I,scales:B,quaternion:Q,rgba:t,rgb:C,opacity:i,x:s,y:a,z:e,r:n,g:o,b:r})=>new lE({gsplat:E,flags:A,index:g,center:I,scales:B,quaternion:Q,rgba:t,rgb:C,opacity:i,x:s,y:a,z:e,r:n,g:o,b:r}),hE=(E,{scale:A,rotate:g,translate:I,recolor:B})=>new yE({gsplat:E,scale:A,rotate:g,translate:I,recolor:B}),Ig=VA(`\n  struct Gsplat {\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n`),jB=VA(`\n  struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n  };\n`),at=VA(`\n  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\n      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);\n      return true;\n    } else {\n      return false;\n    }\n  }\n`);class cE extends DA{constructor({packedSplats:A,index:g}){super({inTypes:{packedSplats:zB,index:"int"},outTypes:{gsplat:GA},inputs:{packedSplats:A,index:g},globals:()=>[Ig,jB,at],statements:({inputs:I,outputs:B})=>{const{gsplat:Q}=B;if(!Q)return[];const{packedSplats:t,index:C}=I;let i;return t&&C?i=gg(`\n            if (readPackedSplat(${t}.texture, ${t}.numSplats, ${C}, ${Q})) {\n              bool zeroSize = all(equal(${Q}.scales, vec3(0.0, 0.0, 0.0)));\n              ${Q}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } else {\n              ${Q}.flags = 0u;\n            }\n          `):i=[`${Q}.flags = 0u;`],i.push(`${Q}.index = ${C??"0"};`),i}})}dynoOut(){return new fA(this,"gsplat")}}class wE extends DA{constructor({packedSplats:A,index:g,base:I,count:B}){super({inTypes:{packedSplats:zB,index:"int",base:"int",count:"int"},outTypes:{gsplat:GA},inputs:{packedSplats:A,index:g,base:I,count:B},globals:()=>[Ig,jB,at],statements:({inputs:Q,outputs:t})=>{const{gsplat:C}=t;if(!C)return[];const{packedSplats:i,index:s,base:a,count:e}=Q;let n;return i&&s&&a&&e?n=gg(`\n            ${C}.flags = 0u;\n            if ((${s} >= ${a}) && (${s} < (${a} + ${e}))) {\n              if (readPackedSplat(${i}.texture, ${i}.numSplats, ${s}, ${C})) {\n                bool zeroSize = all(equal(${C}.scales, vec3(0.0, 0.0, 0.0)));\n                ${C}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          `):n=[`${C}.flags = 0u;`],n.push(`${C}.index = ${s??"0"};`),n}})}dynoOut(){return new fA(this,"gsplat")}}class DE extends DA{constructor({gsplat:A}){super({inTypes:{gsplat:GA},outTypes:{flags:"uint",active:"bool",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},inputs:{gsplat:A},globals:()=>[Ig],statements:({inputs:g,outputs:I})=>{const{gsplat:B}=g,{flags:Q,active:t,index:C,center:i,scales:s,quaternion:a,rgba:e,rgb:n,opacity:o,x:r,y:h,z:c,r:w,g:y,b:l}=I;return[Q?`${Q} = ${B?`${B}.flags`:"0u"};`:null,t?`${t} = isGsplatActive(${B?`${B}.flags`:"0u"});`:null,C?`${C} = ${B?`${B}.index`:"0"};`:null,i?`${i} = ${B?`${B}.center`:"vec3(0.0, 0.0, 0.0)"};`:null,s?`${s} = ${B?`${B}.scales`:"vec3(0.0, 0.0, 0.0)"};`:null,a?`${a} = ${B?`${B}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)"};`:null,e?`${e} = ${B?`${B}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)"};`:null,n?`${n} = ${B?`${B}.rgba.rgb`:"vec3(0.0, 0.0, 0.0)"};`:null,o?`${o} = ${B?`${B}.rgba.a`:"0.0"};`:null,r?`${r} = ${B?`${B}.center.x`:"0.0"};`:null,h?`${h} = ${B?`${B}.center.y`:"0.0"};`:null,c?`${c} = ${B?`${B}.center.z`:"0.0"};`:null,w?`${w} = ${B?`${B}.rgba.r`:"0.0"};`:null,y?`${y} = ${B?`${B}.rgba.g`:"0.0"};`:null,l?`${l} = ${B?`${B}.rgba.b`:"0.0"};`:null].filter(Boolean)}})}}class lE extends DA{constructor({gsplat:A,flags:g,index:I,center:B,scales:Q,quaternion:t,rgba:C,rgb:i,opacity:s,x:a,y:e,z:n,r:o,g:r,b:h}){super({inTypes:{gsplat:GA,flags:"uint",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},outTypes:{gsplat:GA},inputs:{gsplat:A,flags:g,index:I,center:B,scales:Q,quaternion:t,rgba:C,rgb:i,opacity:s,x:a,y:e,z:n,r:o,g:r,b:h},globals:()=>[Ig],statements:({inputs:c,outputs:w})=>{const{gsplat:y}=w;if(!y)return[];const{gsplat:l,flags:u,index:M,center:F,scales:p,quaternion:d,rgba:G,rgb:f,opacity:N,x:k,y:R,z:J,r:m,g:S,b:Y}=c;return[`${y}.flags = ${u??(l?`${l}.flags`:"0u")};`,`${y}.index = ${M??(l?`${l}.index`:"0")};`,`${y}.center = ${F??(l?`${l}.center`:"vec3(0.0, 0.0, 0.0)")};`,`${y}.scales = ${p??(l?`${l}.scales`:"vec3(0.0, 0.0, 0.0)")};`,`${y}.quaternion = ${d??(l?`${l}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)")};`,`${y}.rgba = ${G??(l?`${l}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)")};`,f?`${y}.rgba.rgb = ${f};`:null,N?`${y}.rgba.a = ${N};`:null,k?`${y}.center.x = ${k};`:null,R?`${y}.center.y = ${R};`:null,J?`${y}.center.z = ${J};`:null,m?`${y}.rgba.r = ${m};`:null,S?`${y}.rgba.g = ${S};`:null,Y?`${y}.rgba.b = ${Y};`:null].filter(Boolean)}})}dynoOut(){return new fA(this,"gsplat")}}VA(`\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if (scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if (scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n      normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, normal);\n  }\n`);class yE extends DA{constructor({gsplat:A,scale:g,rotate:I,translate:B,recolor:Q}){super({inTypes:{gsplat:GA,scale:"float",rotate:"vec4",translate:"vec3",recolor:"vec4"},outTypes:{gsplat:GA},inputs:{gsplat:A,scale:g,rotate:I,translate:B,recolor:Q},globals:()=>[Ig],statements:({inputs:t,outputs:C,compile:i})=>{const{gsplat:s}=C;if(!s||!t.gsplat)return[];const{scale:a,rotate:e,translate:n,recolor:o}=t,r=i.indent;return[`${s} = ${t.gsplat};`,`if (isGsplatActive(${s}.flags)) {`,a?`${r}${s}.center *= ${a};`:null,e?`${r}${s}.center = quatVec(${e}, ${s}.center);`:null,n?`${r}${s}.center += ${n};`:null,a?`${r}${s}.scales *= ${a};`:null,e?`${r}${s}.quaternion = quatQuat(${e}, ${s}.quaternion);`:null,o?`${r}${s}.rgba *= ${o};`:null,"}"].filter(Boolean)}})}dynoOut(){return new fA(this,"gsplat")}}const uE=E=>new dE({gsplat:E});class dE extends DA{constructor({gsplat:A}){super({inTypes:{gsplat:GA},inputs:{gsplat:A},globals:()=>[Ig],statements:({inputs:g,outputs:I})=>{const{output:B}=I;if(!B)return[];const{gsplat:Q}=g;return Q?gg(`\n            if (isGsplatActive(${Q}.flags)) {\n              ${B} = packSplat(${Q}.center, ${Q}.scales, ${Q}.quaternion, ${Q}.rgba);\n            } else {\n              ${B} = uvec4(0u, 0u, 0u, 0u);\n            }\n          `):[`${B} = uvec4(0u, 0u, 0u, 0u);`]}})}dynoOut(){return new fA(this,"output")}}class ME extends DA{constructor({rgba8:A}){super({inTypes:{rgba8:"vec4"},inputs:{rgba8:A},statements:({inputs:g,outputs:I})=>[`target = ${g.rgba8??"vec4(0.0, 0.0, 0.0, 0.0)"};`]})}dynoOut(){return new fA(this,"rgba8")}}class Bg extends DA{constructor({key:A,type:g,count:I,value:B,update:Q,globals:t}){A=A??"value",super({outTypes:{[A]:g},update:()=>{if(Q){const C=Q(this.value);C!==void 0&&(this.value=C)}this.uniform.value=this.value},generate:({inputs:C,outputs:i})=>{const s=(t==null?void 0:t({inputs:C,outputs:i}))??[],a={},e=i[A];return e&&(s.push(`uniform ${Bt(e,g,I)};`),a[e]=this.uniform),{globals:s,uniforms:a}}}),this.type=g,this.count=I,this.value=B,this.uniform={value:B},this.outKey=A}dynoOut(){return new fA(this,this.outKey)}}class OB extends Bg{constructor({key:A,value:g,update:I}){super({key:A,type:"int",value:g,update:I})}}class QB extends Bg{constructor({key:A,value:g,update:I}){super({key:A,type:"float",value:g,update:I})}}class GE extends Bg{constructor({key:A,value:g,update:I}){super({key:A,type:"vec3",value:g,update:I})}}class nt extends Bg{constructor({key:A,value:g,update:I}){super({key:A,type:"vec4",value:g,update:I})}}class PB extends Bg{constructor({key:A,value:g,update:I}){super({key:A,type:"usampler2DArray",value:g,update:I})}}class ot{constructor({graph:A,inputs:g,outputs:I,template:B}){this.graph=A,this.template=B,this.inputs=g??{},this.outputs=I??{};const Q=new TC({indent:this.template.indent});for(const C in this.outputs)this.outputs[C]&&Q.declares.add(this.outputs[C]);const t=A.compile({inputs:this.inputs,outputs:this.outputs,compile:Q});this.shader=B.generate({globals:Q.globals,statements:t}),this.uniforms=Q.uniforms,this.updaters=Q.updaters}prepareMaterial(){return NE(this)}update(){for(const A of this.updaters)A()}}class rt{constructor(A){const g=A.match(/^([ \\t]*)\\{\\{\\s*GLOBALS\\s*\\}\\}/m),I=A.match(/^([ \\t]*)\\{\\{\\s*STATEMENTS\\s*\\}\\}/m);if(!g||!I)throw new Error("Template must contain {{ GLOBALS }} and {{ STATEMENTS }}");this.before=A.substring(0,g.index),this.between=A.substring(g.index+g[0].length,I.index),this.after=A.substring(I.index+I[0].length),this.indent=I[1]}generate({globals:A,statements:g}){return this.before+Array.from(A).join(`\n\n`)+this.between+g.map(I=>this.indent+I).join(`\n`)+this.after}}const ht=new Map;function NE(E){let A=ht.get(E);return A||(A=new LB({glslVersion:sC,vertexShader:QE,fragmentShader:E.shader,uniforms:E.uniforms}),ht.set(E,A),A)}function ct(E,A,g="add"){const I=()=>{throw new Error(`Invalid ${g} types: ${E}, ${A}`)};if(E===A)return E;if(E==="int"){if(Kg(A))return A;I()}if(A==="int"){if(Kg(E))return E;I()}if(E==="uint"){if(qg(A))return A;I()}if(A==="uint"){if(qg(E))return E;I()}if(E==="float"){if(XI(A))return A;I()}if(A==="float"){if(XI(E))return E;I()}throw new Error(`Invalid ${g} types: ${E}, ${A}`)}function FE(E,A){return ct(E,A,"sub")}function kE(E,A){const g=()=>{throw new Error(`Invalid mul types: ${E}, ${A}`)},I=B=>B;if(E==="int"){if(Kg(A))return I(A);g()}if(A==="int"){if(Kg(E))return I(E);g()}if(E==="uint"){if(qg(A))return I(A);g()}if(A==="uint"){if(qg(E))return I(E);g()}if(E==="float"){if(XI(A))return I(A);g()}if(A==="float"){if(XI(E))return I(E);g()}if(Kg(E)||qg(E)||Kg(A)||qg(A)){if(E===A)return I(E);g()}if(E==="vec2"){if(A==="vec2"||Wg(A))return I("vec2");if(A==="mat3x2")return I("vec3");if(A==="mat4x2")return I("vec4");g()}if(E==="vec3"){if(A==="mat2x3")return I("vec2");if(A==="vec3"||Vg(A))return I("vec3");if(A==="mat4x3")return I("vec4");g()}if(E==="vec4"){if(A==="mat2x4")return I("vec2");if(A==="mat3x4")return I("vec3");if(A==="vec4"||Tg(A))return I("vec4");g()}if(A==="vec2"){if(Wg(E))return I("vec2");if(E==="mat2x3")return I("vec3");if(E==="mat2x4")return I("vec4");g()}if(A==="vec3"){if(E==="mat3x2")return I("vec2");if(Vg(E))return I("vec3");if(E==="mat3x4")return I("vec4");g()}if(A==="vec4"){if(E==="mat4x2")return I("vec2");if(E==="mat4x3")return I("vec3");if(Tg(E))return I("vec4");g()}if(Wg(E)){if(Wg(A))return I("mat2");if(A==="mat3x2")return I("mat3x2");if(A==="mat4x2")return I("mat4x2");g()}if(E==="mat2x3"){if(Wg(A))return I("mat2x3");if(A==="mat3x2")return I("mat3");if(A==="mat4x2")return I("mat4x3");g()}if(E==="mat2x4"){if(Wg(A))return I("mat2x4");if(A==="mat3x2")return I("mat3x4");if(A==="mat4x2")return I("mat4");g()}if(E==="mat3x2"){if(A==="mat2x3")return I("mat2");if(Vg(A))return I("mat3x2");if(A==="mat4x3")return I("mat4x2");g()}if(Vg(E)){if(A==="mat2x3")return I("mat2x3");if(Vg(A))return I("mat3");if(A==="mat4x3")return I("mat4x3");g()}if(E==="mat3x4"){if(A==="mat2x3")return I("mat2x4");if(Vg(A))return I("mat3x4");if(A==="mat4x3")return I("mat4");g()}if(E==="mat4x2"){if(A==="mat2x4")return I("mat2");if(A==="mat3x4")return I("mat3x2");if(Tg(A))return I("mat4x2");g()}if(E==="mat4x3"){if(A==="mat2x4")return I("mat2x3");if(A==="mat3x4")return I("mat3");if(Tg(A))return I("mat4x3");g()}if(Tg(E)){if(A==="mat2x4")return I("mat2x4");if(A==="mat3x4")return I("mat3x4");if(Tg(A))return I("mat4");g()}throw new Error(`Invalid mul types: ${E}, ${A}`)}const tB=(E,A)=>new RE({a:E,b:A}),pE=(E,A)=>new JE({a:E,b:A}),fE=(E,A)=>new mE({a:E,b:A});class RE extends PI{constructor({a:A,b:g}){super({a:A,b:g,outKey:"sum",outTypeFunc:ct}),this.statements=({inputs:I,outputs:B})=>[`${B.sum} = ${I.a} + ${I.b};`]}}class JE extends PI{constructor({a:A,b:g}){super({a:A,b:g,outKey:"difference",outTypeFunc:FE}),this.statements=({inputs:I,outputs:B})=>[`${B.difference} = ${I.a} - ${I.b};`]}}class mE extends PI{constructor({a:A,b:g}){super({a:A,b:g,outKey:"product",outTypeFunc:kE}),this.statements=({inputs:I,outputs:B})=>[`${B.product} = ${I.a} * ${I.b};`]}}const SE=E=>new xE({a:E}),YE=(E,A)=>new LE({a:E,b:A});class xE extends zC{constructor({a:A}){super({a:A,outTypeFunc:g=>g,outKey:"normalize"}),this.statements=({inputs:g,outputs:I})=>[`${I.normalize} = normalize(${g.a});`]}}function UE(E){if(E==="float")return"vec2";if(E==="vec2")return"vec3";if(E==="vec3")return"vec4";throw new Error("Invalid type")}class LE extends PI{constructor({a:A,b:g}){const I=Mg(A),B=UE(I);super({a:A,b:g,outKey:"extend",outTypeFunc:()=>B}),this.statements=({inputs:Q,outputs:t})=>[`${t.extend} = ${B}(${Q.a}, ${Q.b});`]}}const bE=(E,{scale:A,scales:g,rotate:I,translate:B})=>new ZE({position:E,scale:A,scales:g,rotate:I,translate:B}).outputs.position,HE=(E,{scale:A,scales:g,rotate:I})=>new KE({dir:E,scale:A,scales:g,rotate:I}).outputs.dir;class ZE extends DA{constructor({position:A,scale:g,scales:I,rotate:B,translate:Q}){super({inTypes:{position:"vec3",scale:"float",scales:"vec3",rotate:"vec4",translate:"vec3"},outTypes:{position:"vec3"},inputs:{position:A,scale:g,scales:I,rotate:B,translate:Q},statements:({inputs:t,outputs:C})=>{const{position:i}=C;if(!i)return[];const{scale:s,scales:a,rotate:e,translate:n}=t;return[`${i} = ${t.position??"vec3(0.0, 0.0, 0.0)"};`,s?`${i} *= ${s};`:null,a?`${i} *= ${a};`:null,e?`${i} = quatVec(${e}, ${i});`:null,n?`${i} += ${n};`:null].filter(Boolean)}})}}class KE extends DA{constructor({dir:A,scale:g,scales:I,rotate:B}){super({inTypes:{dir:"vec3",scale:"float",scales:"vec3",rotate:"vec4"},outTypes:{dir:"vec3"},inputs:{dir:A,scale:g,scales:I,rotate:B},statements:({inputs:Q,outputs:t})=>{const{dir:C}=t;if(!C)return[];const{scale:i,scales:s,rotate:a}=Q;return[`${C} = ${Q.dir??"vec3(0.0, 0.0, 0.0)"};`,i?`${C} *= ${i};`:null,s?`${C} *= ${s};`:null,a?`${C} = quatVec(${a}, ${C});`:null].filter(Boolean)}})}}var qE=`precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout uvec4 target;\n\n{{ GLOBALS }}\n\nvoid produceSplat(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        produceSplat(index);\n    } else {\n        target = uvec4(0u, 0u, 0u, 0u);\n    }\n}`;const j=class j{constructor(A={}){this.maxSplats=0,this.numSplats=0,this.packedArray=null,this.isInitialized=!1,this.target=null,this.source=null,this.needsUpdate=!0,this.extra={},this.dyno=new wt({packedSplats:this}),this.initialized=Promise.resolve(this),this.reinitialize(A)}reinitialize(A){this.isInitialized=!1,A.url||A.fileBytes||A.construct?this.initialized=this.asyncInitialize(A).then(()=>(this.isInitialized=!0,this)):(this.initialize(A),this.isInitialized=!0,this.initialized=Promise.resolve(this))}initialize(A){A.packedArray?(this.packedArray=A.packedArray,this.maxSplats=Math.floor(this.packedArray.length/4),this.maxSplats=Math.floor(this.maxSplats/v)*v,this.numSplats=Math.min(this.maxSplats,A.numSplats??Number.POSITIVE_INFINITY)):(this.maxSplats=A.maxSplats??0,this.numSplats=0),this.extra=A.extra??{}}async asyncInitialize(A){let{url:g,fileBytes:I,construct:B}=A;if(g&&(I=await fetch(g).then(async Q=>{if(!Q.ok)throw new Error(`${Q.status} "${Q.statusText}" fetching URL: ${g}`);return await Q.arrayBuffer()})),I){const Q=await ii({input:I,fileType:A.fileType,pathOrUrl:A.fileName??g});this.initialize(Q)}if(B){const Q=B(this);Q instanceof Promise&&await Q}}dispose(){this.target&&(this.target.dispose(),this.target=null),this.source&&(this.source.dispose(),this.source=null)}ensureSplats(A){const g=A<=this.maxSplats?this.maxSplats:Math.max(A,2*this.maxSplats),I=this.packedArray?this.packedArray.length/4:0;if(!this.packedArray||g>I){this.maxSplats=RA(g).maxSplats;const B=new Uint32Array(this.maxSplats*4);this.packedArray&&B.set(this.packedArray),this.packedArray=B}return this.packedArray}ensureSplatsSh(A,g){let I,B;if(A===0)return this.ensureSplats(g);if(A===1)I=2,B="sh1";else if(A===2)I=4,B="sh2";else if(A===3)I=4,B="sh3";else throw new Error(`Invalid level: ${A}`);let Q=this.extra[B]?this.extra[B].length/I:0;const t=g<=Q?Q:Math.max(g,2*Q);if(!this.extra[B]||t>Q){Q=RA(t).maxSplats;const C=new Uint32Array(Q*I);this.extra[B]&&C.set(this.extra[B]),this.extra[B]=C}return this.extra[B]}getSplat(A){if(!this.packedArray||A>=this.numSplats)throw new Error("Invalid index");return qB(this.packedArray,A)}setSplat(A,g,I,B,Q,t){const C=this.ensureSplats(A+1);eI(C,A,g.x,g.y,g.z,I.x,I.y,I.z,B.x,B.y,B.z,B.w,Q,t.r,t.g,t.b),this.numSplats=Math.max(this.numSplats,A+1)}pushSplat(A,g,I,B,Q){const t=this.ensureSplats(this.numSplats+1);eI(t,this.numSplats,A.x,A.y,A.z,g.x,g.y,g.z,I.x,I.y,I.z,I.w,B,Q.r,Q.g,Q.b),++this.numSplats}forEachSplat(A){if(!(!this.packedArray||!this.numSplats))for(let g=0;g<this.numSplats;++g){const I=qB(this.packedArray,g);A(g,I.center,I.scales,I.quaternion,I.opacity,I.color)}}ensureGenerate(A){if(this.target&&(A??1)<=this.maxSplats)return!1;this.dispose();const g=RA(A??1),{width:I,height:B,depth:Q}=g;return this.maxSplats=g.maxSplats,this.target=new xQ(I,B,Q,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:Cg,minFilter:Cg}),this.target.texture.format=Fg,this.target.texture.type=wg,this.target.texture.internalFormat="RGBA32UI",!0}generateMapping(A){let g=0;const I=A.map(B=>{const Q=g,t=Math.ceil(B/v)*v;return g+=t,{base:Q,count:B}});return{maxSplats:g,mapping:I}}getTexture(){return this.target?this.target.texture:this.source||this.packedArray?this.maybeUpdateSource():j.getEmpty()}maybeUpdateSource(){if(!this.packedArray)throw new Error("No packed splats");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:A,height:g,depth:I}=this.source.image;this.maxSplats!==A*g*I&&(this.source.dispose(),this.source=null)}if(this.source)this.packedArray.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.packedArray.buffer));else{const{width:A,height:g,depth:I}=RA(this.maxSplats);this.source=new Eg(this.packedArray,A,g,I),this.source.format=Fg,this.source.type=wg,this.source.internalFormat="RGBA32UI",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}static getEmpty(){if(!j.emptySource){const{width:A,height:g,depth:I,maxSplats:B}=RA(1),Q=new Uint32Array(B*4);j.emptySource=new Eg(Q,A,g,I),j.emptySource.format=Fg,j.emptySource.type=wg,j.emptySource.internalFormat="RGBA32UI",j.emptySource.needsUpdate=!0}return j.emptySource}prepareProgramMaterial(A){let g=j.generatorProgram.get(A);if(!g){const B=OI({index:"int"},{output:"uvec4"},({index:Q})=>{A.inputs.index=Q;const t=A.outputs.gsplat;return{output:uE(t)}});j.programTemplate||(j.programTemplate=new rt(qE)),g=new ot({graph:B,inputs:{index:"index"},outputs:{output:"target"},template:j.programTemplate}),Object.assign(g.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),j.generatorProgram.set(A,g)}const I=g.prepareMaterial();return j.mesh.material=I,{program:g,material:I}}saveRenderState(A){return{xrPresenting:A.xr.isPresenting,autoClear:A.autoClear,scissorTest:A.getScissorTest(),pixelRatio:A.getPixelRatio()}}resetRenderState(A,g){A.setRenderTarget(null),A.setPixelRatio(g.pixelRatio),A.xr.isPresenting=g.xrPresenting,A.autoClear=g.autoClear,A.setScissorTest(g.scissorTest)}generate({generator:A,base:g,count:I,renderer:B}){if(!this.target)throw new Error("Target must be initialized with ensureSplats");if(g+I>this.maxSplats)throw new Error("Base + count exceeds maxSplats");const{program:Q,material:t}=this.prepareProgramMaterial(A);Q.update();const C=this.saveRenderState(B),i=Math.ceil((g+I)/v)*v,s=v*zA;for(t.uniforms.targetBase.value=g,t.uniforms.targetCount.value=I;g<i;){const a=Math.floor(g/s);t.uniforms.targetLayer.value=a;const e=a*s,n=Math.floor((g-e)/v),o=Math.min(zA,Math.ceil((i-e)/v));B.setPixelRatio(1),B.setRenderTarget(this.target,a),B.xr.isPresenting=!1,B.autoClear=!1,B.setScissorTest(!0),B.setScissor(0,n,v,o-n),B.render(j.scene,j.camera),g+=v*(o-n)}return this.resetRenderState(B,C),{nextBase:i}}};j.emptySource=null,j.programTemplate=null,j.generatorProgram=new Map,j.geometry=new zI(2,2),j.mesh=new PQ(j.geometry,new LB({visible:!1})),j.scene=new $Q().add(j.mesh),j.camera=new _Q;let nI=j;class wt extends Bg{constructor({packedSplats:A}={}){super({key:"packedSplats",type:zB,globals:()=>[jB],value:{texture:nI.getEmpty(),numSplats:0},update:g=>{var I,B;return g.texture=((I=this.packedSplats)==null?void 0:I.getTexture())??nI.getEmpty(),g.numSplats=((B=this.packedSplats)==null?void 0:B.numSplats)??0,g}}),this.packedSplats=A}}var WE=`precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout vec4 target;\n\n{{ GLOBALS }}\n\nvoid computeReadback(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        computeReadback(index);\n    } else {\n        target = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}`;const aA=class aA{constructor({renderer:A}={}){this.renderer=A,this.capacity=0,this.count=0}dispose(){this.target&&(this.target.dispose(),this.target=void 0)}ensureBuffer(A,g){const B=Math.ceil(Math.max(1,A)/v)*v*4;if(g.byteLength>=B)return g;const Q=new ArrayBuffer(B);if(g instanceof ArrayBuffer)return Q;const t=g.constructor;return new t(Q)}ensureCapacity(A){const{width:g,height:I,depth:B,maxSplats:Q}=RA(A);(!this.target||Q>this.capacity)&&(this.dispose(),this.capacity=Q,this.target=new xQ(g,I,B,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:Cg,minFilter:Cg}),this.target.texture.format=pI,this.target.texture.type=kI,this.target.texture.internalFormat="RGBA8")}prepareProgramMaterial(A){let g=aA.readbackProgram.get(A);if(!g){const B=OI({index:"int"},{rgba8:"vec4"},({index:Q})=>(A.inputs.index=Q,{rgba8:new ME({rgba8:A.outputs.rgba8})}));aA.programTemplate||(aA.programTemplate=new rt(WE)),g=new ot({graph:B,inputs:{index:"index"},outputs:{rgba8:"target"},template:aA.programTemplate}),Object.assign(g.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),aA.readbackProgram.set(A,g)}const I=g.prepareMaterial();return aA.mesh.material=I,{program:g,material:I}}saveRenderState(A){return{xrPresenting:A.xr.isPresenting,autoClear:A.autoClear,scissorTest:A.getScissorTest(),pixelRatio:A.getPixelRatio()}}resetRenderState(A,g){A.setRenderTarget(null),A.setPixelRatio(g.pixelRatio),A.xr.isPresenting=g.xrPresenting,A.autoClear=g.autoClear,A.setScissorTest(g.scissorTest)}process({count:A,material:g}){const I=this.renderer;if(!I)throw new Error("No renderer");if(!this.target)throw new Error("No target");const B=v*zA;g.uniforms.targetBase.value=0,g.uniforms.targetCount.value=A;let Q=0;for(;Q<A;){const t=Math.floor(Q/B),C=t*B,i=Math.min(zA,Math.ceil((A-C)/v));g.uniforms.targetLayer.value=t,I.setPixelRatio(1),I.setRenderTarget(this.target,t),I.xr.isPresenting=!1,I.autoClear=!1,I.setScissorTest(!0),I.setScissor(0,0,v,i),I.render(aA.scene,aA.camera),Q+=v*i}this.count=A}async read({readback:A}){const g=this.renderer;if(!g)throw new Error("No renderer");if(!this.target)throw new Error("No target");const I=Math.ceil(this.count/v)*v;if(A.byteLength<I*4)throw new Error(`Readback buffer too small: ${A.byteLength} < ${I*4}`);const B=new Uint8Array(A instanceof ArrayBuffer?A:A.buffer),Q=v*zA;let t=0;const C=[];for(;t<this.count;){const i=Math.floor(t/Q),s=i*Q,a=Math.min(zA,Math.ceil((this.count-s)/v));g.setPixelRatio(1),g.setRenderTarget(this.target,i);const e=v*a*4,n=B.subarray(s*4,s*4+e),o=g==null?void 0:g.readRenderTargetPixelsAsync(this.target,0,0,v,a,n);C.push(o),t+=v*a}return Promise.all(C).then(()=>A)}render({reader:A,count:g,renderer:I}){if(this.renderer=I||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(g);const{program:B,material:Q}=this.prepareProgramMaterial(A);B.update();const t=this.saveRenderState(this.renderer);this.process({count:g,material:Q}),this.resetRenderState(this.renderer,t)}async readback({readback:A}){if(!this.renderer)throw new Error("No renderer");const g=this.saveRenderState(this.renderer),I=this.read({readback:A});return this.resetRenderState(this.renderer,g),I}async renderReadback({reader:A,count:g,renderer:I,readback:B}){if(this.renderer=I||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(g);const{program:Q,material:t}=this.prepareProgramMaterial(A);Q.update();const C=this.saveRenderState(this.renderer);this.process({count:g,material:t});const i=this.read({readback:B});return this.resetRenderState(this.renderer,C),i}getTexture(){var A;return(A=this.target)==null?void 0:A.texture}};aA.programTemplate=null,aA.readbackProgram=new Map,aA.geometry=new zI(2,2),aA.mesh=new PQ(aA.geometry,new LB({visible:!1})),aA.scene=new $Q().add(aA.mesh),aA.camera=new _Q;let _B=aA;const nA=class nA{constructor(A={}){this.capacity=0,this.count=0,this.array=null,this.readback=null,this.source=null,this.needsUpdate=!0,this.dyno=new Bg({key:"rgbaArray",type:lt,globals:()=>[yt],value:{texture:nA.getEmpty(),count:0},update:g=>{var I;return g.texture=((I=this.readback)==null?void 0:I.getTexture())??this.source??nA.getEmpty(),g.count=this.count,g}}),A.array?(this.array=A.array,this.capacity=Math.floor(this.array.length/4),this.capacity=Math.floor(this.capacity/v)*v,this.count=Math.min(this.capacity,A.count??Number.POSITIVE_INFINITY)):(this.capacity=A.capacity??0,this.count=0)}dispose(){this.readback&&(this.readback.dispose(),this.readback=null),this.source&&(this.source.dispose(),this.source=null)}ensureCapacity(A){var g;if(!this.array||A>(((g=this.array)==null?void 0:g.length)??0)/4){this.capacity=RA(A).maxSplats;const I=new Uint8Array(this.capacity*4);this.array&&I.set(this.array),this.array=I}return this.array}getTexture(){var g;let A=(g=this.readback)==null?void 0:g.getTexture();return(this.source||this.array)&&(A=this.maybeUpdateSource()),A??nA.getEmpty()}maybeUpdateSource(){if(!this.array)throw new Error("No array");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:A,height:g,depth:I}=this.source.image;this.capacity!==A*g*I&&(this.source.dispose(),this.source=null)}if(this.source)this.array.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.array.buffer));else{const{width:A,height:g,depth:I}=RA(this.capacity);this.source=new Eg(this.array,A,g,I),this.source.format=pI,this.source.type=kI,this.source.internalFormat="RGBA8",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}render({reader:A,count:g,renderer:I}){this.readback||(this.readback=new _B({renderer:I})),this.readback.render({reader:A,count:g,renderer:I}),this.capacity=this.readback.capacity,this.count=this.readback.count}fromPackedSplats({packedSplats:A,base:g,count:I,renderer:B}){const{dynoSplats:Q,dynoBase:t,dynoCount:C,reader:i}=nA.makeDynos();return Q.packedSplats=A,t.value=g,C.value=I,this.render({reader:i,count:I,renderer:B}),this}async read(){if(!this.readback)throw new Error("No readback");return(!this.array||this.array.length<this.count*4)&&(this.array=new Uint8Array(this.capacity*4)),(await this.readback.readback({readback:this.array})).subarray(0,this.count*4)}static getEmpty(){if(!nA.emptySource){const A=new Uint8Array(4);nA.emptySource=new Eg(A,1,1,1),nA.emptySource.format=pI,nA.emptySource.type=kI,nA.emptySource.internalFormat="RGBA8",nA.emptySource.needsUpdate=!0}return nA.emptySource}static makeDynos(){if(!nA.dynos){const A=new wt,g=new OB({value:0}),I=new OB({value:0}),B=OI({index:"int"},{rgba8:"vec4"},({index:Q})=>{if(!Q)throw new Error("index is undefined");Q=tB(Q,g);const t=rE(A,Q,g,I);return{rgba8:BB(t).outputs.rgba}});nA.dynos={dynoSplats:A,dynoBase:g,dynoCount:I,reader:B}}return nA.dynos}};nA.emptySource=null,nA.dynos=null;let Dt=nA;const lt={type:"RgbaArray"},yt=VA(`\n  struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  };\n`);function VE(E,A){return new DA({inTypes:{rgba:lt,index:"int"},outTypes:{rgba:"vec4"},inputs:{rgba:E,index:A},globals:()=>[yt],statements:({inputs:I,outputs:B})=>gg(`\n        if ((index >= 0) && (index < ${I.rgba}.count)) {\n          ${B.rgba} = texelFetch(${I.rgba}.texture, splatTexCoord(index), 0);\n        } else {\n          ${B.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `)}).outputs.rgba}function TE(E){switch(E){case"all":return 0;case"plane":return 1;case"sphere":return 2;case"box":return 3;case"ellipsoid":return 4;case"cylinder":return 5;case"capsule":return 6;case"infinite_cone":return 7;default:throw new Error(`Unknown SDF type: ${E}`)}}function vE(E){switch(E){case"multiply":return 0;case"set_rgb":return 1;case"add_rgba":return 2;default:throw new Error(`Unknown blend mode: ${E}`)}}class zE extends MA{constructor(A={}){super();const{type:g,invert:I,opacity:B,color:Q,displace:t,radius:C}=A;this.type=g??"sphere",this.invert=I??!1,this.opacity=B??1,this.color=Q??new ug(1,1,1),this.displace=t??new D(0,0,0),this.radius=C??0}}const iB=class iB extends MA{constructor(A={}){const{name:g,rgbaBlendMode:I="multiply",sdfSmooth:B=0,softEdge:Q=0,invert:t=!1,sdfs:C=null}=A;super(),this.rgbaBlendMode=I,this.sdfSmooth=B,this.softEdge=Q,this.invert=t,this.sdfs=C,this.ordering=iB.nextOrdering++,this.name=g??`Edit ${this.ordering}`}addSdf(A){this.sdfs==null&&(this.sdfs=[]),this.sdfs.push(A)}removeSdf(A){this.sdfs!=null&&(this.sdfs=this.sdfs.filter(g=>g!==A))}};iB.nextOrdering=1;let $B=iB;class XE{constructor({maxSdfs:A,maxEdits:g}){this.maxSdfs=Math.max(16,A??0),this.numSdfs=0,this.sdfData=new Uint32Array(this.maxSdfs*8*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs),this.dynoSdfArray=new Bg({key:"sdfArray",type:ut,globals:()=>[dt],value:{numSdfs:0,sdfTexture:this.sdfTexture},update:I=>(I.numSdfs=this.numSdfs,I.sdfTexture=this.sdfTexture,I)}),this.maxEdits=Math.max(16,g??0),this.numEdits=0,this.editData=new Uint32Array(this.maxEdits*4),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoNumEdits=new OB({value:0}),this.dynoEdits=this.newEdits(this.editData,this.maxEdits)}newSdfTexture(A,g){const I=new bC(A,8,g,Fg,wg);return I.internalFormat="RGBA32UI",I.needsUpdate=!0,I}newEdits(A,g){return new Bg({key:"edits",type:"uvec4",count:g,globals:()=>[Mt],value:A})}ensureCapacity({maxSdfs:A,maxEdits:g}){let I=!1;return A>this.sdfTexture.image.height&&(this.sdfTexture.dispose(),this.maxSdfs=Math.max(this.maxSdfs*2,A),this.sdfData=new Uint32Array(this.maxSdfs*8*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs)),g>(this.dynoEdits.count??0)&&(this.maxEdits=Math.max(this.maxEdits*2,g),this.editData=new Uint32Array(this.maxEdits*4),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoEdits=this.newEdits(this.editData,this.maxEdits),I=!0),I}updateEditData(A,g){const I=this.editData[A]!==g;return this.editData[A]=g,I}updateEditFloatData(A,g){Xg[0]=g;const I=this.editFloatData[A]!==Xg[0];return I&&(this.editFloatData[A]=Xg[0]),I}encodeEdit(A,{sdfFirst:g,sdfCount:I,invert:B,rgbaBlendMode:Q,softEdge:t,sdfSmooth:C}){const i=A*4;let s=!1;return s=this.updateEditData(i+0,Q|(B?256:0))||s,s=this.updateEditData(i+1,g|I<<16)||s,s=this.updateEditFloatData(i+2,t)||s,s=this.updateEditFloatData(i+3,C)||s,s}updateSdfData(A,g){const I=this.sdfData[A]!==g;return this.sdfData[A]=g,I}updateSdfFloatData(A,g){Xg[0]=g;const I=this.sdfFloatData[A]!==Xg[0];return I&&(this.sdfFloatData[A]=Xg[0]),I}encodeSdf(A,{sdfType:g,invert:I,center:B,quaternion:Q,scale:t,sizes:C},i){const s=A*32,a=g|(I?256:0);let e=!1;e=this.updateSdfFloatData(s+0,(B==null?void 0:B.x)??0)||e,e=this.updateSdfFloatData(s+1,(B==null?void 0:B.y)??0)||e,e=this.updateSdfFloatData(s+2,(B==null?void 0:B.z)??0)||e,e=this.updateSdfData(s+3,a)||e,e=this.updateSdfFloatData(s+4,(Q==null?void 0:Q.x)??0)||e,e=this.updateSdfFloatData(s+5,(Q==null?void 0:Q.y)??0)||e,e=this.updateSdfFloatData(s+6,(Q==null?void 0:Q.z)??0)||e,e=this.updateSdfFloatData(s+7,(Q==null?void 0:Q.w)??0)||e,e=this.updateSdfFloatData(s+8,(t==null?void 0:t.x)??0)||e,e=this.updateSdfFloatData(s+9,(t==null?void 0:t.y)??0)||e,e=this.updateSdfFloatData(s+10,(t==null?void 0:t.z)??0)||e,e=this.updateSdfData(s+11,0)||e,e=this.updateSdfFloatData(s+12,(C==null?void 0:C.x)??0)||e,e=this.updateSdfFloatData(s+13,(C==null?void 0:C.y)??0)||e,e=this.updateSdfFloatData(s+14,(C==null?void 0:C.z)??0)||e,e=this.updateSdfFloatData(s+15,(C==null?void 0:C.w)??0)||e;const n=Math.min(4,i.length);for(let o=0;o<n;++o){const r=s+16+o*4;e=this.updateSdfFloatData(r+0,i[o].x)||e,e=this.updateSdfFloatData(r+1,i[o].y)||e,e=this.updateSdfFloatData(r+2,i[o].z)||e,e=this.updateSdfFloatData(r+3,i[o].w)||e}return e}update(A){const g=A.reduce((e,{sdfs:n})=>e+n.length,0),I=this.ensureCapacity({maxEdits:A.length,maxSdfs:g}),B=[new lA,new lA],Q=new D,t=new sA,C=new D,i=new lA;let s=0,a=I;A.length!==this.dynoNumEdits.value&&(this.dynoNumEdits.value=A.length,this.numEdits=A.length,a=!0);for(const[e,{edit:n,sdfs:o}]of A.entries()){a=this.encodeEdit(e,{sdfFirst:s,sdfCount:o.length,invert:n.invert,rgbaBlendMode:vE(n.rgbaBlendMode),softEdge:n.softEdge,sdfSmooth:n.sdfSmooth})||a;let r=!1;for(const h of o)i.set(h.scale.x,h.scale.y,h.scale.z,h.radius),h.scale.setScalar(1),h.updateMatrixWorld(),h.matrixWorld.clone().invert().decompose(Q,t,C),h.scale.set(i.x,i.y,i.z),h.updateMatrixWorld(),B[0].set(h.color.r,h.color.g,h.color.b,h.opacity),B[1].set(h.displace.x,h.displace.y,h.displace.z,1),r=this.encodeSdf(s,{sdfType:TE(h.type),invert:h.invert,center:Q,quaternion:t,scale:C,sizes:i},B)||r,s+=1;this.numSdfs=s,r&&(this.sdfTexture.needsUpdate=!0),a||(a=r)}return{updated:a,dynoUpdated:I}}modify(A){return jE(A,this.dynoSdfArray,this.dynoNumEdits,this.dynoEdits)}}const ut={type:"SdfArray"},dt=VA(`\n  struct SdfArray {\n    int numSdfs;\n    usampler2D sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n    }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    }\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n    vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n    for (int index = sdfFirst; index < sdfLast; ++index) {\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n          distance = sdfPos.z;\n          break;\n        }\n        case SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n          float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n        case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n          float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        }\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance = -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < distanceAccum) {\n          distanceAccum = distance;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          }\n        }\n      } else {\n        float scaledDistance = -distance / smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n          }\n          maxExp = scaledDistance;\n        }\n\n        float weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n        for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      return distanceAccum;\n    } else {\n      // Very distant SDFs may result in 0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / 0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n      distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  }\n`),Mt=VA(`\n  const uint EDIT_FLAG_BLEND = 0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = uintBitsToFloat(packedEdit.z);\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\n    // On Android, moving values[0] is necessary to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) {\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n        target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    }\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\n  }\n`);function jE(E,A,g,I){return new DA({inTypes:{gsplat:GA,sdfArray:ut,numEdits:"int",rgbaDisplaceEdits:"uvec4"},outTypes:{gsplat:GA},globals:()=>[dt,Mt],inputs:{gsplat:E,sdfArray:A,numEdits:g,rgbaDisplaceEdits:I},statements:({inputs:Q,outputs:t})=>{const{sdfArray:C,numEdits:i,rgbaDisplaceEdits:s}=Q,{gsplat:a}=t;return gg(`\n        ${a} = ${Q.gsplat};\n        if (isGsplatActive(${a}.flags)) {\n          for (int editIndex = 0; editIndex < ${i}; ++editIndex) {\n            applyPackedRgbaDisplaceEdit(\n              ${s}[editIndex], ${C}.sdfTexture, ${C}.numSdfs,\n              ${a}.center, ${a}.rgba\n            );\n          }\n        }\n      `)}}).outputs.gsplat}const Xg=new Float32Array(1);class CB{constructor(){this.scale=new QB({value:Number.NEGATIVE_INFINITY}),this.rotate=new nt({value:new sA(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}),this.translate=new GE({value:new D(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)})}apply(A){return bE(A,{scale:this.scale,rotate:this.rotate,translate:this.translate})}applyDir(A){return HE(A,{rotate:this.rotate})}applyGsplat(A){return hE(A,{scale:this.scale,rotate:this.rotate,translate:this.translate})}updateFromMatrix(A){const g=new D,I=new sA,B=new D;A.decompose(B,I,g);const Q=(g.x+g.y+g.z)/3;let t=!1;return Q!==this.scale.value&&(this.scale.value=Q,t=!0),B.equals(this.translate.value)||(this.translate.value.copy(B),t=!0),I.equals(this.rotate.value)||(this.rotate.value.copy(I),t=!0),t}update(A){return A.updateMatrixWorld(),this.updateFromMatrix(A.matrixWorld)}}class OE extends MA{constructor({numSplats:A,generator:g,construct:I,update:B}){if(super(),this.numSplats=A??0,this.generator=g,this.frameUpdate=B,this.version=0,I){const Q=I(this);Object.assign(this,Q)}}updateVersion(){this.version+=1}set needsUpdate(A){A&&this.updateVersion()}}const hg=class hg extends OE{constructor(A={}){const g=new CB,I=new CB,B=new CB,Q=new CB,t=new nt({value:new lA(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY)}),C=new QB({value:0}),i=new QB({value:0}),s={transform:g,viewToWorld:I,worldToView:B,viewToObject:Q,recolor:t,time:C,deltaTime:i};if(super({update:({time:a,deltaTime:e,viewToWorld:n,globalEdits:o})=>this.update({time:a,deltaTime:e,viewToWorld:n,globalEdits:o})}),this.isInitialized=!1,this.recolor=new ug(1,1,1),this.opacity=1,this.enableViewToObject=!1,this.enableViewToWorld=!1,this.enableWorldToView=!1,this.skinning=null,this.edits=null,this.rgbaDisplaceEdits=null,this.splatRgba=null,this.maxSh=3,this.packedSplats=A.packedSplats??new nI,this.numSplats=this.packedSplats.numSplats,this.editable=A.editable??!0,this.onFrame=A.onFrame,this.context=s,this.objectModifier=A.objectModifier,this.worldModifier=A.worldModifier,this.updateGenerator(),A.url||A.fileBytes||A.constructSplats||A.packedSplats&&!A.packedSplats.isInitialized)this.initialized=this.asyncInitialize(A).then(async()=>{if(this.updateGenerator(),this.isInitialized=!0,A.onLoad){const a=A.onLoad(this);a instanceof Promise&&await a}return this});else if(this.isInitialized=!0,this.initialized=Promise.resolve(this),A.onLoad){const a=A.onLoad(this);a instanceof Promise&&(this.initialized=a.then(()=>this))}}async asyncInitialize(A){const{url:g,fileBytes:I,fileType:B,fileName:Q,maxSplats:t,constructSplats:C}=A;if(g||I||C){const i={url:g,fileBytes:I,fileType:B,fileName:Q,maxSplats:t,construct:C};this.packedSplats.reinitialize(i)}this.packedSplats&&(await this.packedSplats.initialized,this.numSplats=this.packedSplats.numSplats,this.updateGenerator())}static async staticInitialize(){await NI(),hg.isStaticInitialized=!0}pushSplat(A,g,I,B,Q){this.packedSplats.pushSplat(A,g,I,B,Q)}forEachSplat(A){this.packedSplats.forEachSplat(A)}dispose(){this.packedSplats.dispose()}constructGenerator(A){const{transform:g,viewToObject:I,recolor:B}=A,Q=OI({index:"int"},{gsplat:GA},({index:t})=>{if(!t)throw new Error("index is undefined");let C=oE(this.packedSplats.dyno,t);if(this.maxSh>=1){const{sh1Texture:s,sh2Texture:a,sh3Texture:e}=this.ensureShTextures();if(s){const n=I.translate,{center:o}=BB(C).outputs,r=SE(pE(o,n));let h=Ai(C,s,r);this.maxSh>=2&&a&&(h=tB(h,gi(C,a,r))),this.maxSh>=3&&e&&(h=tB(h,Ii(C,e,r)));let{rgba:c}=BB(C).outputs;c=tB(c,YE(h,VC("float",0))),C=XB({gsplat:C,rgba:c})}}if(this.splatRgba){const s=VE(this.splatRgba.dyno,t);C=XB({gsplat:C,rgba:s})}this.skinning&&(C=this.skinning.modify(C)),this.objectModifier&&(C=this.objectModifier.apply({gsplat:C}).gsplat),C=g.applyGsplat(C);const i=fE(B,BB(C).outputs.rgba);return C=XB({gsplat:C,rgba:i}),this.rgbaDisplaceEdits&&(C=this.rgbaDisplaceEdits.modify(C)),this.worldModifier&&(C=this.worldModifier.apply({gsplat:C}).gsplat),{gsplat:C}});this.generator=Q}updateGenerator(){this.constructGenerator(this.context)}update({time:A,viewToWorld:g,deltaTime:I,globalEdits:B}){var c;this.numSplats=this.packedSplats.numSplats,this.context.time.value=A,this.context.deltaTime.value=I,hg.dynoTime.value=A;const{transform:Q,viewToObject:t,recolor:C}=this.context;let i=Q.update(this);this.context.viewToWorld.updateFromMatrix(g)&&this.enableViewToWorld&&(i=!0);const s=g.clone().invert();this.context.worldToView.updateFromMatrix(s)&&this.enableWorldToView&&(i=!0);const n=new cA().compose(Q.translate.value,Q.rotate.value,new D().setScalar(Q.scale.value)).invert().multiply(g);t.updateFromMatrix(n)&&(this.enableViewToObject||this.packedSplats.extra.sh1)&&(i=!0);const o=new lA(this.recolor.r,this.recolor.g,this.recolor.b,this.opacity);o.equals(C.value)||(C.value.copy(o),i=!0);const r=this.editable?(this.edits??[]).concat(B):[];this.editable&&!this.edits&&this.traverseVisible(w=>{w instanceof $B&&r.push(w)}),r.sort((w,y)=>w.ordering-y.ordering);const h=r.map(w=>{if(w.sdfs!=null)return{edit:w,sdfs:w.sdfs};const y=[];return w.traverseVisible(l=>{l instanceof zE&&y.push(l)}),{edit:w,sdfs:y}});if(h.length>0&&!this.rgbaDisplaceEdits){const w=h.length,y=h.reduce((l,u)=>l+u.sdfs.length,0);this.rgbaDisplaceEdits=new XE({maxEdits:w,maxSdfs:y}),this.updateGenerator()}if(this.rgbaDisplaceEdits){const w=this.rgbaDisplaceEdits.update(h);i||(i=w.updated),w.dynoUpdated&&this.updateGenerator()}i&&this.updateVersion(),(c=this.onFrame)==null||c.call(this,{mesh:this,time:A,deltaTime:I})}raycast(A,g){if(!this.packedSplats.packedArray||!this.packedSplats.numSplats)return;const{near:I,far:B,ray:Q}=A,t=this.matrixWorld.clone().invert(),C=new TA().setFromMatrix4(t),i=Q.origin.clone().applyMatrix4(t),s=Q.direction.clone().applyMatrix3(C),a=new D;t.decompose(new D,new sA,a),(a.x*a.y*a.z)**(1/3);const n=Kt(i.x,i.y,i.z,s.x,s.y,s.z,I,B,this.packedSplats.numSplats,this.packedSplats.packedArray,!0);for(const o of n){const r=Q.direction.clone().multiplyScalar(o).add(Q.origin);g.push({distance:o,point:r,object:this})}}ensureShTextures(){if(!this.packedSplats.extra.sh1)return{};let A=this.packedSplats.extra.sh1Texture;if(!A){let B=this.packedSplats.extra.sh1;const{width:Q,height:t,depth:C,maxSplats:i}=RA(B.length/2);if(B.length<i*2){const a=new Uint32Array(i*2);a.set(B),this.packedSplats.extra.sh1=a,B=a}const s=new Eg(B,Q,t,C);s.format=iC,s.type=wg,s.internalFormat="RG32UI",s.needsUpdate=!0,A=new PB({value:s,key:"sh1"}),this.packedSplats.extra.sh1Texture=A}if(!this.packedSplats.extra.sh2)return{sh1Texture:A};let g=this.packedSplats.extra.sh2Texture;if(!g){let B=this.packedSplats.extra.sh2;const{width:Q,height:t,depth:C,maxSplats:i}=RA(B.length/4);if(B.length<i*4){const a=new Uint32Array(i*4);a.set(B),this.packedSplats.extra.sh2=a,B=a}const s=new Eg(B,Q,t,C);s.format=Fg,s.type=wg,s.internalFormat="RGBA32UI",s.needsUpdate=!0,g=new PB({value:s,key:"sh2"}),this.packedSplats.extra.sh2Texture=g}if(!this.packedSplats.extra.sh3)return{sh1Texture:A,sh2Texture:g};let I=this.packedSplats.extra.sh3Texture;if(!I){let B=this.packedSplats.extra.sh3;const{width:Q,height:t,depth:C,maxSplats:i}=RA(B.length/4);if(B.length<i*4){const a=new Uint32Array(i*4);a.set(B),this.packedSplats.extra.sh3=a,B=a}const s=new Eg(B,Q,t,C);s.format=Fg,s.type=wg,s.internalFormat="RGBA32UI",s.needsUpdate=!0,I=new PB({value:s,key:"sh3"}),this.packedSplats.extra.sh3Texture=I}return{sh1Texture:A,sh2Texture:g,sh3Texture:I}}};hg.staticInitialized=hg.staticInitialize(),hg.isStaticInitialized=!1,hg.dynoTime=new QB({value:0});let Gt=hg;const PE=VA(`\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n      int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> 25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * (-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + sh1_2 * (-0.4886025 * viewDir.x);\n  }\n`),_E=VA(`\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> 24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n      int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n      int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> 24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> 24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (1.0925484 * viewDir.y * viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (1.0925484 * viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\n  }\n`),$E=VA(`\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // Extract sint6 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> 26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> 26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n    vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / 31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) >> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << 18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> 26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> 26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    )) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n      int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / 31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n`);function Ai(E,A,g){return ZB({inTypes:{gsplat:GA,sh1:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:E,sh1:A,viewDir:g},globals:()=>[Ig,PE],statements:({inputs:I,outputs:B})=>gg(`\n        if (isGsplatActive(${I.gsplat}.flags)) {\n          ${B.rgb} = evaluateSH1(${I.gsplat}, ${I.sh1}, ${I.viewDir});\n        } else {\n          ${B.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}function gi(E,A,g){return ZB({inTypes:{gsplat:GA,sh2:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:E,sh2:A,viewDir:g},globals:()=>[Ig,_E],statements:({inputs:I,outputs:B})=>gg(`\n        if (isGsplatActive(${I.gsplat}.flags)) {\n          ${B.rgb} = evaluateSH2(${I.gsplat}, ${I.sh2}, ${I.viewDir});\n        } else {\n          ${B.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}function Ii(E,A,g){return ZB({inTypes:{gsplat:GA,sh3:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:E,sh3:A,viewDir:g},globals:()=>[Ig,$E],statements:({inputs:I,outputs:B})=>gg(`\n        if (isGsplatActive(${I.gsplat}.flags)) {\n          ${B.rgb} = evaluateSH3(${I.gsplat}, ${I.sh3}, ${I.viewDir});\n        } else {\n          ${B.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}function Bi(E){return new Worker(self.location.href,{name:E==null?void 0:E.name})}class Qi{constructor(){this.messages={},this.messageIdNext=0,this.worker=new Bi,this.worker.onmessage=A=>this.onMessage(A)}makeMessageId(){return++this.messageIdNext}makeMessagePromiseId(){const A=this.makeMessageId(),g=new Promise((I,B)=>{this.messages[A]={resolve:I,reject:B}});return{id:A,promise:g}}onMessage(A){const{id:g,result:I,error:B}=A.data,Q=this.messages[g];Q&&(delete this.messages[g],B?Q.reject(B):Q.resolve(I))}async call(A,g){const{id:I,promise:B}=this.makeMessagePromiseId();return this.worker.postMessage({name:A,args:g,id:I},{transfer:tt(g)}),B}}let Nt=4,EB=0;const Ft=[],kt=[];async function ti(){const E=Ft.shift();if(E)return E;if(EB<Nt){const A=new Qi;return EB+=1,A}return new Promise(A=>{kt.push(A)})}function Ci(E){if(EB>Nt){EB-=1;return}const A=kt.shift();if(A){A(E);return}Ft.push(E)}async function oI(E){const A=await ti();try{return await E(A)}finally{Ci(A)}}var jg=(E=>(E.PLY="ply",E.WLG0="wlg0",E.SPZ="spz",E.SPLAT="splat",E.KSPLAT="ksplat",E))(jg||{});function pt(E){const A=new DataView(E.buffer);if((A.getUint32(0,!0)&16777215)===7957616)return"ply";if(A.getUint32(0,!0)===809978967)return"wlg0";if((A.getUint32(0,!0)&16777215)===559903){const g=CE(E,4);return new DataView(g.buffer).getUint32(0,!0)===1347635022?"spz":void 0}}function Ei(E){const A=E.split(/[?#]/,1)[0],g=Math.max(A.lastIndexOf("/"),A.lastIndexOf("\\\\")),I=A.slice(g+1),B=I.lastIndexOf(".");return B<=0||B===I.length-1?"":I.slice(B+1).toLowerCase()}function ft(E){const A=Ei(E);if(A==="ply")return"ply";if(A==="wlg")return"wlg0";if(A==="spz")return"spz";if(A==="splat")return"splat";if(A==="ksplat")return"ksplat"}async function ii({input:E,fileType:A,pathOrUrl:g}){const I=E instanceof ArrayBuffer?new Uint8Array(E):E;let B=A;switch(A||(B=pt(I),!B&&g&&(B=ft(g))),B){case"wlg0":return await oI(async Q=>{const{packedArray:t,numSplats:C}=await Q.call("decodeWlg",{fileBytes:I});return{packedArray:t,numSplats:C}});case"ply":{const Q=new aI({fileBytes:I});await Q.parseHeader();const t=Q.numSplats,C=RA(t).maxSplats,i={fileBytes:I,packedArray:new Uint32Array(C*4)};return await oI(async s=>{const{packedArray:a,numSplats:e,extra:n}=await s.call("unpackPly",i);return{packedArray:a,numSplats:e,extra:n}})}case"spz":return await oI(async Q=>{const{packedArray:t,numSplats:C,extra:i}=await Q.call("decodeSpz",{fileBytes:I});return{packedArray:t,numSplats:C,extra:i}});case"splat":return await oI(async Q=>{const{packedArray:t,numSplats:C}=await Q.call("decodeAntiSplat",{fileBytes:I});return{packedArray:t,numSplats:C}});case"ksplat":return await oI(async Q=>{const{packedArray:t,numSplats:C,extra:i}=await Q.call("decodeKsplat",{fileBytes:I});return{packedArray:t,numSplats:C,extra:i}});default:throw new Error(`Unknown splat file type: ${B}`)}}class si{constructor({maxSplats:A=1}={}){this.numSplats=0,this.maxSplats=RA(A).maxSplats,this.centers=new Float32Array(this.maxSplats*3),this.scales=new Float32Array(this.maxSplats*3),this.quaternions=new Float32Array(this.maxSplats*4),this.opacities=new Float32Array(this.maxSplats),this.colors=new Float32Array(this.maxSplats*3)}pushSplat(){const A=this.numSplats;return this.ensureIndex(A),this.numSplats+=1,A}unpushSplat(A){if(A===this.numSplats-1)this.numSplats-=1;else throw new Error("Cannot unpush splat from non-last position")}ensureCapacity(A){if(A>this.maxSplats){const g=Math.max(A,this.maxSplats*2),I=new Float32Array(g*3),B=new Float32Array(g*3),Q=new Float32Array(g*4),t=new Float32Array(g),C=new Float32Array(g*3);if(I.set(this.centers),B.set(this.scales),Q.set(this.quaternions),t.set(this.opacities),C.set(this.colors),this.centers=I,this.scales=B,this.quaternions=Q,this.opacities=t,this.colors=C,this.sh1){const i=new Float32Array(g*9);i.set(this.sh1),this.sh1=i}if(this.sh2){const i=new Float32Array(g*15);i.set(this.sh2),this.sh2=i}if(this.sh3){const i=new Float32Array(g*21);i.set(this.sh3),this.sh3=i}this.maxSplats=g}}ensureIndex(A){this.ensureCapacity(A+1)}setCenter(A,g,I,B){this.centers[A*3]=g,this.centers[A*3+1]=I,this.centers[A*3+2]=B}setScale(A,g,I,B){this.scales[A*3]=g,this.scales[A*3+1]=I,this.scales[A*3+2]=B}setQuaternion(A,g,I,B,Q){this.quaternions[A*4]=g,this.quaternions[A*4+1]=I,this.quaternions[A*4+2]=B,this.quaternions[A*4+3]=Q}setOpacity(A,g){this.opacities[A]=g}setColor(A,g,I,B){this.colors[A*3]=g,this.colors[A*3+1]=I,this.colors[A*3+2]=B}setSh1(A,g){this.sh1||(this.sh1=new Float32Array(this.maxSplats*9));for(let I=0;I<9;++I)this.sh1[A*9+I]=g[I]}setSh2(A,g){this.sh2||(this.sh2=new Float32Array(this.maxSplats*15));for(let I=0;I<15;++I)this.sh2[A*15+I]=g[I]}setSh3(A,g){this.sh3||(this.sh3=new Float32Array(this.maxSplats*21));for(let I=0;I<21;++I)this.sh3[A*21+I]=g[I]}}class Rt{constructor({fileBytes:A}){this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A,this.reader=new EE({fileBytes:this.fileBytes});const g=new DataView(this.reader.read(16).buffer);if(g.getUint32(0,!0)!==1347635022)throw new Error("Invalid SPZ file");if(this.version=g.getUint32(4,!0),this.version<1||this.version>2)throw new Error(`Unsupported SPZ version: ${this.version}`);this.numSplats=g.getUint32(8,!0),this.shDegree=g.getUint8(12),this.fractionalBits=g.getUint8(13),this.flags=g.getUint8(14),this.flagAntiAlias=(this.flags&1)!==0,this.reserved=g.getUint8(15),this.parsed=!1}parseSplats(A,g,I,B,Q,t){if(this.parsed)throw new Error("SPZ file already parsed");if(this.parsed=!0,this.version===1){const C=this.reader.read(this.numSplats*3*2),i=new Uint16Array(C.buffer);for(let s=0;s<this.numSplats;s++){const a=s*3,e=gA(i[a]),n=gA(i[a+1]),o=gA(i[a+2]);A==null||A(s,e,n,o)}}else if(this.version===2){const C=1<<this.fractionalBits,i=this.reader.read(this.numSplats*3*3);for(let s=0;s<this.numSplats;s++){const a=s*9,e=((i[a+2]<<24|i[a+1]<<16|i[a]<<8)>>8)/C,n=((i[a+5]<<24|i[a+4]<<16|i[a+3]<<8)>>8)/C,o=((i[a+8]<<24|i[a+7]<<16|i[a+6]<<8)>>8)/C;A==null||A(s,e,n,o)}}else throw new Error("Unreachable");{const C=this.reader.read(this.numSplats);for(let i=0;i<this.numSplats;i++)g==null||g(i,C[i]/255)}{const C=this.reader.read(this.numSplats*3),i=mt/.15;for(let s=0;s<this.numSplats;s++){const a=s*3,e=(C[a]/255-.5)*i+.5,n=(C[a+1]/255-.5)*i+.5,o=(C[a+2]/255-.5)*i+.5;I==null||I(s,e,n,o)}}{const C=this.reader.read(this.numSplats*3);for(let i=0;i<this.numSplats;i++){const s=i*3,a=Math.exp(C[s]/16-10),e=Math.exp(C[s+1]/16-10),n=Math.exp(C[s+2]/16-10);B==null||B(i,a,e,n)}}{const C=this.reader.read(this.numSplats*3);for(let i=0;i<this.numSplats;i++){const s=i*3,a=C[s]/127.5-1,e=C[s+1]/127.5-1,n=C[s+2]/127.5-1,o=Math.sqrt(Math.max(0,1-a*a-e*e-n*n));Q==null||Q(i,a,e,n,o)}}if(t&&this.shDegree>=1){const C=new Float32Array(9),i=this.shDegree>=2?new Float32Array(5*3):void 0,s=this.shDegree>=3?new Float32Array(7*3):void 0,a=this.reader.read(this.numSplats*Jt[this.shDegree]*3);let e=0;for(let n=0;n<this.numSplats;n++){for(let o=0;o<9;++o)C[o]=(a[e+o]-128)/128;if(e+=9,i){for(let o=0;o<15;++o)i[o]=(a[e+o]-128)/128;e+=15}if(s){for(let o=0;o<21;++o)s[o]=(a[e+o]-128)/128;e+=21}t==null||t(n,C,i,s)}}}}const Jt={1:3,2:8,3:15},mt=.28209479177387814,ei=1347635022,ai=2,ni=1;class rg{constructor({numSplats:A,shDegree:g,fractionalBits:I=12,flagAntiAlias:B=!0}){this.clippedCount=0;const Q=19+(g>=1?9:0)+(g>=2?15:0)+(g>=3?21:0),t=16+A*Q;this.buffer=new ArrayBuffer(t),this.view=new DataView(this.buffer),this.view.setUint32(0,ei,!0),this.view.setUint32(4,ai,!0),this.view.setUint32(8,A,!0),this.view.setUint8(12,g),this.view.setUint8(13,I),this.view.setUint8(14,B?ni:0),this.view.setUint8(15,0),this.numSplats=A,this.shDegree=g,this.fractionalBits=I,this.fraction=1<<I,this.flagAntiAlias=B}setCenter(A,g,I,B){const Q=Math.round(g*this.fraction),t=Math.max(-8388607,Math.min(8388607,Q)),C=Math.round(I*this.fraction),i=Math.max(-8388607,Math.min(8388607,C)),s=Math.round(B*this.fraction),a=Math.max(-8388607,Math.min(8388607,s));(Q!==t||C!==i||s!==a)&&(this.clippedCount+=1);const o=16+A*9;this.view.setUint8(o,t&255),this.view.setUint8(o+1,t>>8&255),this.view.setUint8(o+2,t>>16&255),this.view.setUint8(o+3,i&255),this.view.setUint8(o+4,i>>8&255),this.view.setUint8(o+5,i>>16&255),this.view.setUint8(o+6,a&255),this.view.setUint8(o+7,a>>8&255),this.view.setUint8(o+8,a>>16&255)}setAlpha(A,g){const I=16+this.numSplats*9+A;this.view.setUint8(I,Math.max(0,Math.min(255,Math.round(g*255))))}static scaleRgb(A){const g=((A-.5)/(mt/.15)+.5)*255;return Math.max(0,Math.min(255,Math.round(g)))}setRgb(A,g,I,B){const Q=16+this.numSplats*10+A*3;this.view.setUint8(Q,rg.scaleRgb(g)),this.view.setUint8(Q+1,rg.scaleRgb(I)),this.view.setUint8(Q+2,rg.scaleRgb(B))}setScale(A,g,I,B){const Q=16+this.numSplats*13+A*3;this.view.setUint8(Q,Math.max(0,Math.min(255,Math.round((Math.log(g)+10)*16)))),this.view.setUint8(Q+1,Math.max(0,Math.min(255,Math.round((Math.log(I)+10)*16)))),this.view.setUint8(Q+2,Math.max(0,Math.min(255,Math.round((Math.log(B)+10)*16))))}setQuat(A,g,I,B,Q){const t=16+this.numSplats*16+A*3,C=Q<0;this.view.setUint8(t,Math.max(0,Math.min(255,Math.round(((C?-g:g)+1)*127.5)))),this.view.setUint8(t+1,Math.max(0,Math.min(255,Math.round(((C?-I:I)+1)*127.5)))),this.view.setUint8(t+2,Math.max(0,Math.min(255,Math.round(((C?-B:B)+1)*127.5))))}static quantizeSh(A,g){const I=Math.round(A*128)+128,B=1<<8-g,Q=Math.floor((I+B/2)/B)*B;return Math.max(0,Math.min(255,Q))}setSh(A,g,I,B){const Q=Jt[this.shDegree]||0,t=16+this.numSplats*19+A*Q*3;for(let C=0;C<9;++C)this.view.setUint8(t+C,rg.quantizeSh(g[C],5));if(I){const C=t+9;for(let i=0;i<15;++i)this.view.setUint8(C+i,rg.quantizeSh(I[i],4));if(B){const i=C+15;for(let s=0;s<21;++s)this.view.setUint8(i+s,rg.quantizeSh(B[s],4))}}}async finalize(){const A=new Uint8Array(this.buffer),I=new ReadableStream({async start(t){t.enqueue(A),t.close()}}).pipeThrough(new CompressionStream("gzip")),Q=await new Response(I).arrayBuffer();return console.log("Compressed",A.length,"bytes to",Q.byteLength,"bytes"),new Uint8Array(Q)}}async function oi(E){var a,e,n;const A=new si,{inputs:g,clipXyz:I,maxSh:B,fractionalBits:Q=12,opacityThreshold:t}=E;for(const o of g){let r=function(d){return d.multiplyScalar(l),d.applyQuaternion(u),d.add(M),d},h=function(d){return d.multiplyScalar(l),d},c=function(d){return d.premultiply(u),d},w=function(d){return!F||F.containsPoint(d)},y=function(d){return t!==void 0?d>=t:!0};const l=((a=o.transform)==null?void 0:a.scale)??1,u=new sA().fromArray(((e=o.transform)==null?void 0:e.quaternion)??[0,0,0,1]),M=new D().fromArray(((n=o.transform)==null?void 0:n.translate)??[0,0,0]),F=I?new Rg(new D().fromArray(I.min),new D().fromArray(I.max)):void 0;let p=o.fileType;switch(p||(p=pt(o.fileBytes),!p&&o.pathOrUrl&&(p=ft(o.pathOrUrl))),p){case jg.WLG0:{await NI();const d=CQ(o.fileBytes,v,zA);for(let G=0;G<d.numSplats;++G){let{center:f,scales:N,quaternion:k,opacity:R,color:J}=qB(d.packedSplats,G);if(f=r(f),w(f)&&y(R)){const m=A.pushSplat();A.setCenter(m,f.x,f.y,f.z),N=h(N),A.setScale(m,N.x,N.y,N.z),k=c(k),A.setQuaternion(m,k.x,k.y,k.z,k.w),A.setOpacity(m,R),A.setColor(m,J.r,J.g,J.b)}}break}case jg.PLY:{const d=new aI({fileBytes:o.fileBytes});await d.parseHeader();let G=null;d.parseSplats((f,N,k,R,J,m,S,Y,q,Z,$,O,P,W,z)=>{const X=r(new D(N,k,R));if(w(X)&&y(O)){G=A.pushSplat(),A.setCenter(G,X.x,X.y,X.z);const T=h(new D(J,m,S));A.setScale(G,T.x,T.y,T.z);const x=c(new sA(Y,q,Z,$));A.setQuaternion(G,x.x,x.y,x.z,x.w),A.setOpacity(G,O),A.setColor(G,P,W,z)}else G=null},(f,N,k,R)=>{N&&G!==null&&A.setSh1(G,N),k&&G!==null&&A.setSh2(G,k),R&&G!==null&&A.setSh3(G,R)});break}case jg.SPZ:{const d=new Rt({fileBytes:o.fileBytes}),G=new Int32Array(d.numSplats);G.fill(-1);const f=new Float32Array(d.numSplats*3),N=new D;d.parseSplats((k,R,J,m)=>{const S=r(new D(R,J,m));f[k*3]=S.x,f[k*3+1]=S.y,f[k*3+2]=S.z},(k,R)=>{N.fromArray(f,k*3),w(N)&&y(R)&&(G[k]=A.pushSplat(),A.setCenter(G[k],N.x,N.y,N.z),A.setOpacity(G[k],R))},(k,R,J,m)=>{G[k]>=0&&A.setColor(G[k],R,J,m)},(k,R,J,m)=>{if(G[k]>=0){const S=h(new D(R,J,m));A.setScale(G[k],S.x,S.y,S.z)}},(k,R,J,m,S)=>{if(G[k]>=0){const Y=c(new sA(R,J,m,S));A.setQuaternion(G[k],Y.x,Y.y,Y.z,Y.w)}},(k,R,J,m)=>{G[k]>=0&&(A.setSh1(G[k],R),J&&A.setSh2(G[k],J),m&&A.setSh3(G[k],m))});break}case jg.SPLAT:Et(o.fileBytes,d=>{},(d,G,f,N,k,R,J,m,S,Y,q,Z,$,O,P)=>{const W=r(new D(G,f,N));if(w(W)&&y(Z)){const z=A.pushSplat();A.setCenter(z,W.x,W.y,W.z);const X=h(new D(k,R,J));A.setScale(z,X.x,X.y,X.z);const T=c(new sA(m,S,Y,q));A.setQuaternion(z,T.x,T.y,T.z,T.w),A.setOpacity(z,Z),A.setColor(z,$,O,P)}});break;case jg.KSPLAT:{let d=null;sE(o.fileBytes,G=>{},(G,f,N,k,R,J,m,S,Y,q,Z,$,O,P,W)=>{const z=r(new D(f,N,k));if(w(z)&&y($)){d=A.pushSplat(),A.setCenter(d,z.x,z.y,z.z);const X=h(new D(R,J,m));A.setScale(d,X.x,X.y,X.z);const T=c(new sA(S,Y,q,Z));A.setQuaternion(d,T.x,T.y,T.z,T.w),A.setOpacity(d,$),A.setColor(d,O,P,W)}else d=null},(G,f,N,k)=>{d!==null&&(A.setSh1(d,f),N&&A.setSh2(d,N),k&&A.setSh3(d,k))});break}default:throw new Error(`transcodeSpz not implemented for ${p}`)}}const C=Math.min(B??3,A.sh3?3:A.sh2?2:A.sh1?1:0),i=new rg({numSplats:A.numSplats,shDegree:C,fractionalBits:Q,flagAntiAlias:!0});for(let o=0;o<A.numSplats;++o){const r=o*3,h=o*4;i.setCenter(o,A.centers[r],A.centers[r+1],A.centers[r+2]),i.setScale(o,A.scales[r],A.scales[r+1],A.scales[r+2]),i.setQuat(o,A.quaternions[h],A.quaternions[h+1],A.quaternions[h+2],A.quaternions[h+3]),i.setAlpha(o,A.opacities[o]),i.setRgb(o,A.colors[r],A.colors[r+1],A.colors[r+2]),A.sh1&&C>=1&&i.setSh(o,A.sh1.slice(o*9,(o+1)*9),C>=2&&A.sh2?A.sh2.slice(o*15,(o+1)*15):void 0,C>=3&&A.sh3?A.sh3.slice(o*21,(o+1)*21):void 0)}return{fileBytes:await i.finalize(),clippedCount:i.clippedCount}}async function St(E){const{name:A,args:g,id:I}=E.data;let B,Q;try{switch(A){case"unpackPly":{const{packedArray:t,fileBytes:C}=g,i=await ri({packedArray:t,fileBytes:C});B={id:I,numSplats:i.numSplats,packedArray:i.packedArray,extra:i.extra};break}case"decodeWlg":{const{fileBytes:t}=g,C=CQ(t,v,zA);B={id:I,numSplats:C.numSplats,packedArray:C.packedSplats};break}case"decodeSpz":{const{fileBytes:t}=g,C=hi(t);B={id:I,numSplats:C.numSplats,packedArray:C.packedArray,extra:C.extra};break}case"decodeAntiSplat":{const{fileBytes:t}=g,C=iE(t);B={id:I,numSplats:C.numSplats,packedArray:C.packedArray};break}case"decodeKsplat":{const{fileBytes:t}=g,C=eE(t);B={id:I,numSplats:C.numSplats,packedArray:C.packedArray,extra:C.extra};break}case"sortSplats":{const{maxSplats:t,totalSplats:C,readback:i,ordering:s}=g;gt&&(B={id:I,readback:i,ordering:s,activeSplats:Ht(t,C,i,s)});break}case"sortDoubleSplats":{const{numSplats:t,readback:C,ordering:i}=g;B={id:I,readback:C,ordering:i},gt&&(B={id:I,readback:C,ordering:i,activeSplats:Zt(t,C,i)});break}case"transcodeSpz":{const t=g,C=await oi(t);B={id:I,fileBytes:C,input:t};break}default:throw new Error(`Unknown name: ${A}`)}}catch(t){Q=t}self.postMessage({id:I,result:B,error:Q},{transfer:tt(B)})}async function ri({packedArray:E,fileBytes:A}){const g=new aI({fileBytes:A});await g.parseHeader();const I=g.numSplats,B={},Q=Math.exp(-20);return g.parseSplats((t,C,i,s,a,e,n,o,r,h,c,w,y,l,u)=>{eI(E,t,C,i,s,a<Q?0:Math.max(HB,a),e<Q?0:Math.max(HB,e),n<Q?0:Math.max(HB,n),o,r,h,c,w,y,l,u)},(t,C,i,s)=>{C&&(B.sh1||(B.sh1=new Uint32Array(I*2)),VB(B.sh1,t,C)),i&&(B.sh2||(B.sh2=new Uint32Array(I*4)),TB(B.sh2,t,i)),s&&(B.sh3||(B.sh3=new Uint32Array(I*4)),vB(B.sh3,t,s))}),{packedArray:E,numSplats:I,extra:B}}function hi(E){const A=new Rt({fileBytes:E}),g=A.numSplats,I=WB(g),B=new Uint32Array(I*4),Q={};return A.parseSplats((t,C,i,s)=>{XC(B,t,C,i,s)},(t,C)=>{_C(B,t,C)},(t,C,i,s)=>{PC(B,t,C,i,s)},(t,C,i,s)=>{jC(B,t,C,i,s)},(t,C,i,s,a)=>{OC(B,t,C,i,s,a)},(t,C,i,s)=>{C&&(Q.sh1||(Q.sh1=new Uint32Array(g*2)),VB(Q.sh1,t,C)),i&&(Q.sh2||(Q.sh2=new Uint32Array(g*4)),TB(Q.sh2,t,i)),s&&(Q.sh3||(Q.sh3=new Uint32Array(g*4)),vB(Q.sh3,t,s))}),{packedArray:B,numSplats:g,extra:Q}}const Og=31744,rI=Og+1;let BA=null;function Gi({totalSplats:E,readback:A,ordering:g}){BA||(BA=new Uint32Array(rI)),BA.fill(0);const I=A.map(i=>new Uint32Array(i.buffer)),B=I[0].length,Q=Math.ceil(E/B);let t=0;for(let i=0;i<Q;++i){const s=I[i],a=Math.min(s.length,E-t);for(let e=0;e<a;++e){const n=s[e]&32767;n<Og&&(BA[n]+=1)}t+=a}let C=0;for(let i=0;i<rI;++i){const s=C+BA[i];BA[i]=C,C=s}t=0;for(let i=0;i<Q;++i){const s=I[i],a=Math.min(s.length,E-t);for(let e=0;e<a;++e){const n=s[e]&32767;n<Og&&(g[BA[n]]=t+e,BA[n]+=1)}t+=a}if(BA[rI-1]!==C)throw new Error(`Expected ${C} active splats but got ${BA[rI-1]}`);return{activeSplats:C,ordering:g}}function Ni({numSplats:E,readback:A,ordering:g}){BA||(BA=new Uint32Array(rI)),BA.fill(0);for(let B=0;B<E;++B){const Q=A[B];Q<Og&&(BA[Q]+=1)}let I=0;for(let B=Og-1;B>=0;--B){const Q=I+BA[B];BA[B]=I,I=Q}for(let B=0;B<E;++B){const Q=A[B];Q<Og&&(g[BA[Q]]=B,BA[Q]+=1)}if(BA[0]!==I)throw new Error(`Expected ${I} active splats but got ${BA[0]}`);return{activeSplats:I,ordering:g}}const AQ=[];function Yt(E){AQ.push(E)}async function ci(){self.addEventListener("message",Yt),await NI(),self.removeEventListener("message",Yt),self.addEventListener("message",St);for(const E of AQ)St(E);AQ.length=0}ci().catch(console.error)})();\n', QB = typeof self < "u" && self.Blob && new Blob([ut], { type: "text/javascript;charset=utf-8" });
function Hn(g) {
  let A;
  try {
    if (A = QB && (self.URL || self.webkitURL).createObjectURL(QB), !A) throw "";
    const I = new Worker(A, {
      name: g == null ? void 0 : g.name
    });
    return I.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(A);
    }), I;
  } catch {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(ut),
      {
        name: g == null ? void 0 : g.name
      }
    );
  } finally {
    A && (self.URL || self.webkitURL).revokeObjectURL(A);
  }
}
class Kn {
  constructor() {
    this.messages = {}, this.messageIdNext = 0, this.worker = new Hn(), this.worker.onmessage = (A) => this.onMessage(A);
  }
  makeMessageId() {
    return ++this.messageIdNext;
  }
  makeMessagePromiseId() {
    const A = this.makeMessageId(), I = new Promise((B, Q) => {
      this.messages[A] = { resolve: B, reject: Q };
    });
    return { id: A, promise: I };
  }
  onMessage(A) {
    const { id: I, result: B, error: Q } = A.data, C = this.messages[I];
    C && (delete this.messages[I], Q ? C.reject(Q) : C.resolve(B));
  }
  // Invoke an RPC on the worker with the given name and arguments.
  // The normal usage of a worker is to run one activity at a time,
  // but this function allows for concurrent calls, tagging each request
  // with a unique message Id and awaiting a response to that same Id.
  // The method will automatically transfer any ArrayBuffers in the
  // arguments to the worker. If you'd like to transfer a copy of a
  // buffer then you must clone it before passing to this function.
  async call(A, I) {
    const { id: B, promise: Q } = this.makeMessagePromiseId();
    return this.worker.postMessage(
      { name: A, args: I, id: B },
      { transfer: uQ(I) }
    ), Q;
  }
}
let dt = 4, CI = 0;
const Gt = [], Mt = [];
async function Zn() {
  const g = Gt.shift();
  if (g)
    return g;
  if (CI < dt) {
    const A = new Kn();
    return CI += 1, A;
  }
  return new Promise((A) => {
    Mt.push(A);
  });
}
function qn(g) {
  if (CI > dt) {
    CI -= 1;
    return;
  }
  const A = Mt.shift();
  if (A) {
    A(g);
    return;
  }
  Gt.push(g);
}
async function og(g) {
  const A = await Zn();
  try {
    return await g(A);
  } finally {
    qn(A);
  }
}
class Zo extends bt {
  constructor(A) {
    super(A), this.fileLoader = new Ht(A);
  }
  load(A, I, B, Q) {
    this.fileLoader.setResponseType("arraybuffer"), this.fileLoader.setCrossOrigin(this.crossOrigin), this.fileLoader.setWithCredentials(this.withCredentials), this.fileLoader.setPath(this.path), this.fileLoader.setResourcePath(this.resourcePath), this.fileLoader.setRequestHeader(this.requestHeader), this.fileLoader.load(
      A,
      async (C) => {
        if (I) {
          const t = await kt({
            input: C,
            fileType: this.fileType,
            pathOrUrl: A
          });
          I(new ZA(t));
        }
      },
      B,
      Q
    );
  }
  async loadAsync(A, I) {
    return new Promise((B, Q) => {
      this.load(
        A,
        (C) => {
          B(C);
        },
        I,
        Q
      );
    });
  }
  parse(A) {
    return new Ag({ packedSplats: A });
  }
}
var rg = /* @__PURE__ */ ((g) => (g.PLY = "ply", g.WLG0 = "wlg0", g.SPZ = "spz", g.SPLAT = "splat", g.KSPLAT = "ksplat", g))(rg || {});
function Nt(g) {
  const A = new DataView(g.buffer);
  if ((A.getUint32(0, !0) & 16777215) === 7957616)
    return "ply";
  if (A.getUint32(0, !0) === 809978967)
    return "wlg0";
  if ((A.getUint32(0, !0) & 16777215) === 559903) {
    const I = JQ(g, 4);
    return new DataView(I.buffer).getUint32(0, !0) === 1347635022 ? "spz" : void 0;
  }
}
function vn(g) {
  const A = g.split(/[?#]/, 1)[0], I = Math.max(
    A.lastIndexOf("/"),
    A.lastIndexOf("\\")
  ), B = A.slice(I + 1), Q = B.lastIndexOf(".");
  return Q <= 0 || Q === B.length - 1 ? "" : B.slice(Q + 1).toLowerCase();
}
function pt(g) {
  const A = vn(g);
  if (A === "ply")
    return "ply";
  if (A === "wlg")
    return "wlg0";
  if (A === "spz")
    return "spz";
  if (A === "splat")
    return "splat";
  if (A === "ksplat")
    return "ksplat";
}
async function kt({
  input: g,
  fileType: A,
  pathOrUrl: I
}) {
  const B = g instanceof ArrayBuffer ? new Uint8Array(g) : g;
  let Q = A;
  switch (A || (Q = Nt(B), !Q && I && (Q = pt(I))), Q) {
    case "wlg0":
      return await og(async (C) => {
        const { packedArray: E, numSplats: t } = await C.call("decodeWlg", {
          fileBytes: B
        });
        return { packedArray: E, numSplats: t };
      });
    case "ply": {
      const C = new QI({ fileBytes: B });
      await C.parseHeader();
      const E = C.numSplats, t = dA(E).maxSplats, i = { fileBytes: B, packedArray: new Uint32Array(t * 4) };
      return await og(async (e) => {
        const { packedArray: n, numSplats: s, extra: o } = await e.call(
          "unpackPly",
          i
        );
        return { packedArray: n, numSplats: s, extra: o };
      });
    }
    case "spz":
      return await og(async (C) => {
        const { packedArray: E, numSplats: t, extra: i } = await C.call(
          "decodeSpz",
          {
            fileBytes: B
          }
        );
        return { packedArray: E, numSplats: t, extra: i };
      });
    case "splat":
      return await og(async (C) => {
        const { packedArray: E, numSplats: t } = await C.call(
          "decodeAntiSplat",
          {
            fileBytes: B
          }
        );
        return { packedArray: E, numSplats: t };
      });
    case "ksplat":
      return await og(async (C) => {
        const { packedArray: E, numSplats: t, extra: i } = await C.call(
          "decodeKsplat",
          { fileBytes: B }
        );
        return { packedArray: E, numSplats: t, extra: i };
      });
    default:
      throw new Error(`Unknown splat file type: ${Q}`);
  }
}
class Wn {
  constructor({ maxSplats: A = 1 } = {}) {
    this.numSplats = 0, this.maxSplats = dA(A).maxSplats, this.centers = new Float32Array(this.maxSplats * 3), this.scales = new Float32Array(this.maxSplats * 3), this.quaternions = new Float32Array(this.maxSplats * 4), this.opacities = new Float32Array(this.maxSplats), this.colors = new Float32Array(this.maxSplats * 3);
  }
  pushSplat() {
    const A = this.numSplats;
    return this.ensureIndex(A), this.numSplats += 1, A;
  }
  unpushSplat(A) {
    if (A === this.numSplats - 1)
      this.numSplats -= 1;
    else
      throw new Error("Cannot unpush splat from non-last position");
  }
  ensureCapacity(A) {
    if (A > this.maxSplats) {
      const I = Math.max(A, this.maxSplats * 2), B = new Float32Array(I * 3), Q = new Float32Array(I * 3), C = new Float32Array(I * 4), E = new Float32Array(I), t = new Float32Array(I * 3);
      if (B.set(this.centers), Q.set(this.scales), C.set(this.quaternions), E.set(this.opacities), t.set(this.colors), this.centers = B, this.scales = Q, this.quaternions = C, this.opacities = E, this.colors = t, this.sh1) {
        const i = new Float32Array(I * 9);
        i.set(this.sh1), this.sh1 = i;
      }
      if (this.sh2) {
        const i = new Float32Array(I * 15);
        i.set(this.sh2), this.sh2 = i;
      }
      if (this.sh3) {
        const i = new Float32Array(I * 21);
        i.set(this.sh3), this.sh3 = i;
      }
      this.maxSplats = I;
    }
  }
  ensureIndex(A) {
    this.ensureCapacity(A + 1);
  }
  setCenter(A, I, B, Q) {
    this.centers[A * 3] = I, this.centers[A * 3 + 1] = B, this.centers[A * 3 + 2] = Q;
  }
  setScale(A, I, B, Q) {
    this.scales[A * 3] = I, this.scales[A * 3 + 1] = B, this.scales[A * 3 + 2] = Q;
  }
  setQuaternion(A, I, B, Q, C) {
    this.quaternions[A * 4] = I, this.quaternions[A * 4 + 1] = B, this.quaternions[A * 4 + 2] = Q, this.quaternions[A * 4 + 3] = C;
  }
  setOpacity(A, I) {
    this.opacities[A] = I;
  }
  setColor(A, I, B, Q) {
    this.colors[A * 3] = I, this.colors[A * 3 + 1] = B, this.colors[A * 3 + 2] = Q;
  }
  setSh1(A, I) {
    this.sh1 || (this.sh1 = new Float32Array(this.maxSplats * 9));
    for (let B = 0; B < 9; ++B)
      this.sh1[A * 9 + B] = I[B];
  }
  setSh2(A, I) {
    this.sh2 || (this.sh2 = new Float32Array(this.maxSplats * 15));
    for (let B = 0; B < 15; ++B)
      this.sh2[A * 15 + B] = I[B];
  }
  setSh3(A, I) {
    this.sh3 || (this.sh3 = new Float32Array(this.maxSplats * 21));
    for (let B = 0; B < 21; ++B)
      this.sh3[A * 21 + B] = I[B];
  }
}
var Vn = `precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out uvec4 target;

{{ GLOBALS }}

void produceSplat(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        produceSplat(index);
    } else {
        target = uvec4(0u, 0u, 0u, 0u);
    }
}`;
const _ = class _ {
  constructor(A = {}) {
    this.maxSplats = 0, this.numSplats = 0, this.packedArray = null, this.isInitialized = !1, this.target = null, this.source = null, this.needsUpdate = !0, this.extra = {}, this.dyno = new zI({ packedSplats: this }), this.initialized = Promise.resolve(this), this.reinitialize(A);
  }
  reinitialize(A) {
    this.isInitialized = !1, A.url || A.fileBytes || A.construct ? this.initialized = this.asyncInitialize(A).then(() => (this.isInitialized = !0, this)) : (this.initialize(A), this.isInitialized = !0, this.initialized = Promise.resolve(this));
  }
  initialize(A) {
    A.packedArray ? (this.packedArray = A.packedArray, this.maxSplats = Math.floor(this.packedArray.length / 4), this.maxSplats = Math.floor(this.maxSplats / X) * X, this.numSplats = Math.min(
      this.maxSplats,
      A.numSplats ?? Number.POSITIVE_INFINITY
    )) : (this.maxSplats = A.maxSplats ?? 0, this.numSplats = 0), this.extra = A.extra ?? {};
  }
  async asyncInitialize(A) {
    let { url: I, fileBytes: B, construct: Q } = A;
    if (I && (B = await fetch(I).then(async (C) => {
      if (!C.ok)
        throw new Error(
          `${C.status} "${C.statusText}" fetching URL: ${I}`
        );
      return await C.arrayBuffer();
    })), B) {
      const C = await kt({
        input: B,
        fileType: A.fileType,
        pathOrUrl: A.fileName ?? I
      });
      this.initialize(C);
    }
    if (Q) {
      const C = Q(this);
      C instanceof Promise && await C;
    }
  }
  // Call this when you are finished with the PackedSplats and want to free
  // any buffers it holds.
  dispose() {
    this.target && (this.target.dispose(), this.target = null), this.source && (this.source.dispose(), this.source = null);
  }
  // Ensures that this.packedArray can fit numSplats Gsplats. If it's too small,
  // resize exponentially and copy over the original data.
  //
  // Typically you don't need to call this, because calling this.setSplat(index, ...)
  // and this.pushSplat(...) will automatically call ensureSplats() so we have
  // enough splats.
  ensureSplats(A) {
    const I = A <= this.maxSplats ? this.maxSplats : (
      // Grow exponentially to avoid frequent reallocations
      Math.max(A, 2 * this.maxSplats)
    ), B = this.packedArray ? this.packedArray.length / 4 : 0;
    if (!this.packedArray || I > B) {
      this.maxSplats = dA(I).maxSplats;
      const Q = new Uint32Array(this.maxSplats * 4);
      this.packedArray && Q.set(this.packedArray), this.packedArray = Q;
    }
    return this.packedArray;
  }
  // Ensure the extra array for the given level is large enough to hold numSplats
  ensureSplatsSh(A, I) {
    let B, Q;
    if (A === 0)
      return this.ensureSplats(I);
    if (A === 1)
      B = 2, Q = "sh1";
    else if (A === 2)
      B = 4, Q = "sh2";
    else if (A === 3)
      B = 4, Q = "sh3";
    else
      throw new Error(`Invalid level: ${A}`);
    let C = this.extra[Q] ? this.extra[Q].length / B : 0;
    const E = I <= C ? C : Math.max(I, 2 * C);
    if (!this.extra[Q] || E > C) {
      C = dA(E).maxSplats;
      const t = new Uint32Array(C * B);
      this.extra[Q] && t.set(this.extra[Q]), this.extra[Q] = t;
    }
    return this.extra[Q];
  }
  // Unpack the 16-byte Gsplat data at index into the Three.js components
  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
  // opacity: number 0..1, color: THREE.Color 0..1.
  getSplat(A) {
    if (!this.packedArray || A >= this.numSplats)
      throw new Error("Invalid index");
    return AI(this.packedArray, A);
  }
  // Set all PackedSplat components at index with the provided Gsplat attributes
  // (can be the same objects returned by getSplat). Ensures there is capacity
  // for at least index+1 Gsplats.
  setSplat(A, I, B, Q, C, E) {
    const t = this.ensureSplats(A + 1);
    JI(
      t,
      A,
      I.x,
      I.y,
      I.z,
      B.x,
      B.y,
      B.z,
      Q.x,
      Q.y,
      Q.z,
      Q.w,
      C,
      E.r,
      E.g,
      E.b
    ), this.numSplats = Math.max(this.numSplats, A + 1);
  }
  // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on
  // construction where you just want to iterate and create a collection of Gsplats.
  pushSplat(A, I, B, Q, C) {
    const E = this.ensureSplats(this.numSplats + 1);
    JI(
      E,
      this.numSplats,
      A.x,
      A.y,
      A.z,
      I.x,
      I.y,
      I.z,
      B.x,
      B.y,
      B.z,
      B.w,
      Q,
      C.r,
      C.g,
      C.b
    ), ++this.numSplats;
  }
  // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat
  // and invoke the callback function with the Gsplat attributes.
  forEachSplat(A) {
    if (!(!this.packedArray || !this.numSplats))
      for (let I = 0; I < this.numSplats; ++I) {
        const B = AI(this.packedArray, I);
        A(
          I,
          B.center,
          B.scales,
          B.quaternion,
          B.opacity,
          B.color
        );
      }
  }
  // Ensures our PackedSplats.target render target has enough space to generate
  // maxSplats total Gsplats, and reallocate if not large enough.
  ensureGenerate(A) {
    if (this.target && (A ?? 1) <= this.maxSplats)
      return !1;
    this.dispose();
    const I = dA(A ?? 1), { width: B, height: Q, depth: C } = I;
    return this.maxSplats = I.maxSplats, this.target = new a.WebGLArrayRenderTarget(B, Q, C, {
      depthBuffer: !1,
      stencilBuffer: !1,
      generateMipmaps: !1,
      magFilter: a.NearestFilter,
      minFilter: a.NearestFilter
    }), this.target.texture.format = a.RGBAIntegerFormat, this.target.texture.type = a.UnsignedIntType, this.target.texture.internalFormat = "RGBA32UI", !0;
  }
  // Given an array of splatCounts (.numSplats for each
  // SplatGenerator/SplatMesh in the scene), compute a
  // "mapping layout" in the composite array of generated outputs.
  generateMapping(A) {
    let I = 0;
    const B = A.map((Q) => {
      const C = I, E = Math.ceil(Q / X) * X;
      return I += E, { base: C, count: Q };
    });
    return { maxSplats: I, mapping: B };
  }
  // Returns a THREE.DataArrayTexture representing the PackedSplats content as
  // a Uint32x4 data array texture (2048 x 2048 x depth in size)
  getTexture() {
    return this.target ? this.target.texture : this.source || this.packedArray ? this.maybeUpdateSource() : _.getEmpty();
  }
  // Check if source texture needs to be created/updated
  maybeUpdateSource() {
    if (!this.packedArray)
      throw new Error("No packed splats");
    if (this.needsUpdate || !this.source) {
      if (this.needsUpdate = !1, this.source) {
        const { width: A, height: I, depth: B } = this.source.image;
        this.maxSplats !== A * I * B && (this.source.dispose(), this.source = null);
      }
      if (this.source)
        this.packedArray.buffer !== this.source.image.data.buffer && (this.source.image.data = new Uint8Array(this.packedArray.buffer));
      else {
        const { width: A, height: I, depth: B } = dA(this.maxSplats);
        this.source = new a.DataArrayTexture(
          this.packedArray,
          A,
          I,
          B
        ), this.source.format = a.RGBAIntegerFormat, this.source.type = a.UnsignedIntType, this.source.internalFormat = "RGBA32UI", this.source.needsUpdate = !0;
      }
      this.source.needsUpdate = !0;
    }
    return this.source;
  }
  // Can be used where you need an uninitialized THREE.DataArrayTexture like
  // a uniform you will update with the result of this.getTexture() later.
  static getEmpty() {
    if (!_.emptySource) {
      const { width: A, height: I, depth: B, maxSplats: Q } = dA(1), C = new Uint32Array(Q * 4);
      _.emptySource = new a.DataArrayTexture(
        C,
        A,
        I,
        B
      ), _.emptySource.format = a.RGBAIntegerFormat, _.emptySource.type = a.UnsignedIntType, _.emptySource.internalFormat = "RGBA32UI", _.emptySource.needsUpdate = !0;
    }
    return _.emptySource;
  }
  // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(A) {
    let I = _.generatorProgram.get(A);
    if (!I) {
      const Q = YA(
        { index: "int" },
        { output: "uvec4" },
        ({ index: C }) => {
          A.inputs.index = C;
          const E = A.outputs.gsplat;
          return { output: FB(E) };
        }
      );
      _.programTemplate || (_.programTemplate = new TI(
        Vn
      )), I = new VI({
        graph: Q,
        inputs: { index: "index" },
        outputs: { output: "target" },
        template: _.programTemplate
      }), Object.assign(I.uniforms, {
        targetLayer: { value: 0 },
        targetBase: { value: 0 },
        targetCount: { value: 0 }
      }), _.generatorProgram.set(A, I);
    }
    const B = I.prepareMaterial();
    return _.mesh.material = B, { program: I, material: B };
  }
  saveRenderState(A) {
    return {
      xrPresenting: A.xr.isPresenting,
      autoClear: A.autoClear,
      scissorTest: A.getScissorTest(),
      pixelRatio: A.getPixelRatio()
    };
  }
  resetRenderState(A, I) {
    A.setRenderTarget(null), A.setPixelRatio(I.pixelRatio), A.xr.isPresenting = I.xrPresenting, A.autoClear = I.autoClear, A.setScissorTest(I.scissorTest);
  }
  // Executes a dyno program specified by generator which is any DynoBlock that
  // maps { index: "int" } to { gsplat: Gsplat }. This is called in
  // ForgeRenderer.updateInternal() to re-generate Gsplats in the scene for
  // SplatGenerator instances whose version is newer than what was generated
  // for it last time.
  generate({
    generator: A,
    base: I,
    count: B,
    renderer: Q
  }) {
    if (!this.target)
      throw new Error("Target must be initialized with ensureSplats");
    if (I + B > this.maxSplats)
      throw new Error("Base + count exceeds maxSplats");
    const { program: C, material: E } = this.prepareProgramMaterial(A);
    C.update();
    const t = this.saveRenderState(Q), i = Math.ceil((I + B) / X) * X, e = X * WA;
    for (E.uniforms.targetBase.value = I, E.uniforms.targetCount.value = B; I < i; ) {
      const n = Math.floor(I / e);
      E.uniforms.targetLayer.value = n;
      const s = n * e, o = Math.floor((I - s) / X), r = Math.min(
        WA,
        Math.ceil((i - s) / X)
      );
      Q.setPixelRatio(1), Q.setRenderTarget(this.target, n), Q.xr.isPresenting = !1, Q.autoClear = !1, Q.setScissorTest(!0), Q.setScissor(
        0,
        o,
        X,
        r - o
      ), Q.render(_.scene, _.camera), I += X * (r - o);
    }
    return this.resetRenderState(Q, t), { nextBase: i };
  }
};
_.emptySource = null, _.programTemplate = null, _.generatorProgram = /* @__PURE__ */ new Map(), _.geometry = new a.PlaneGeometry(2, 2), _.mesh = new a.Mesh(
  _.geometry,
  new a.RawShaderMaterial({ visible: !1 })
), _.scene = new a.Scene().add(_.mesh), _.camera = new a.Camera();
let ZA = _;
class zI extends S {
  constructor({ packedSplats: A } = {}) {
    super({
      key: "packedSplats",
      type: Lg,
      globals: () => [sI],
      value: {
        texture: ZA.getEmpty(),
        numSplats: 0
      },
      update: (I) => {
        var B, Q;
        return I.texture = ((B = this.packedSplats) == null ? void 0 : B.getTexture()) ?? ZA.getEmpty(), I.numSplats = ((Q = this.packedSplats) == null ? void 0 : Q.numSplats) ?? 0, I;
      }
    }), this.packedSplats = A;
  }
}
class UI extends a.InstancedBufferGeometry {
  constructor(A, I) {
    super(), this.ordering = A, this.setAttribute("position", new a.BufferAttribute(Tn, 3)), this.setIndex(new a.BufferAttribute(Xn, 1)), this._maxInstanceCount = A.length, this.instanceCount = I, this.attribute = new a.InstancedBufferAttribute(A, 1, !1, 1), this.attribute.setUsage(a.DynamicDrawUsage), this.setAttribute("splatIndex", this.attribute);
  }
  update(A, I) {
    this.ordering = A, this.attribute.array = A, this.instanceCount = I, this.attribute.addUpdateRange(0, I), this.attribute.needsUpdate = !0;
  }
}
const Tn = new Float32Array([
  -1,
  -1,
  0,
  1,
  -1,
  0,
  1,
  1,
  0,
  -1,
  1,
  0
]), Xn = new Uint16Array([0, 1, 2, 0, 2, 3]), PA = class PA {
  constructor(A) {
    if (this.lastTime = null, this.encodeLinear = !1, this.superXY = 1, this.display = null, this.sorting = null, this.pending = null, this.sortingCheck = !1, this.readback = new Uint16Array(0), this.forge = A.forge, this.camera = A.camera, this.viewToWorld = A.viewToWorld ?? new a.Matrix4(), A.target) {
      const { width: I, height: B, doubleBuffer: Q } = A.target, C = Math.max(1, Math.min(4, A.target.superXY ?? 1));
      if (this.superXY = C, I * C > 8192 || B * C > 8192)
        throw new Error("Target size too large");
      this.target = new a.WebGLRenderTarget(
        I * C,
        B * C,
        {
          format: a.RGBAFormat,
          type: a.UnsignedByteType,
          colorSpace: a.SRGBColorSpace
        }
      ), Q && (this.back = new a.WebGLRenderTarget(
        I * C,
        B * C,
        {
          format: a.RGBAFormat,
          type: a.UnsignedByteType,
          colorSpace: a.SRGBColorSpace
        }
      )), this.encodeLinear = !0;
    }
    this.onTextureUpdated = A.onTextureUpdated, this.sortRadial = A.sortRadial ?? !0, this.sortDistance = A.sortDistance, this.sortCoorient = A.sortCoorient, this.depthBias = A.depthBias, this.sort360 = A.sort360, this.orderingFreelist = new dQ({
      allocate: (I) => new Uint32Array(I),
      valid: (I, B) => I.length === B
    }), this.autoUpdate = !1, this.setAutoUpdate(A.autoUpdate ?? !1);
  }
  // Call this when you are done with the ForgeViewpoint and want to
  // free up its resources (GPU targets, pixel buffers, etc.)
  dispose() {
    var A;
    this.setAutoUpdate(!1), this.target && (this.target.dispose(), this.target = void 0), this.back && (this.back.dispose(), this.back = void 0), this.display && (this.forge.releaseAccumulator(this.display.accumulator), this.display.geometry.dispose(), this.display = null), (A = this.pending) != null && A.accumulator && (this.forge.releaseAccumulator(this.pending.accumulator), this.pending = null);
  }
  // Use this function to change whether this viewpoint will auto-update
  // its sort order whenever the attached ForgeRenderer updates the Gsplats.
  // Turn this on or off depending on whether you expect to do renders from
  // this viewpoint most frames.
  setAutoUpdate(A) {
    !this.autoUpdate && A ? this.forge.autoViewpoints.push(this) : this.autoUpdate && !A && (this.forge.autoViewpoints = this.forge.autoViewpoints.filter(
      (I) => I !== this
    )), this.autoUpdate = A;
  }
  // See below async prepareRenderPixels() for explanation of parameters.
  // Awaiting this method updates the Gsplats in the scene and performs a sort of the
  // Gsplats from this viewpoint, preparing it for a subsequent this.renderTarget()
  // call in the same tick.
  async prepare({
    scene: A,
    camera: I,
    viewToWorld: B,
    update: Q,
    forceOrigin: C
  }) {
    var t;
    for (B ? this.viewToWorld = B : (this.camera = I ?? this.camera, this.camera && (this.camera.updateMatrixWorld(), this.viewToWorld = this.camera.matrixWorld.clone())); Q ?? !0; ) {
      const i = C ? this.viewToWorld : void 0;
      if (this.forge.updateInternal({ scene: A, originToWorld: i }))
        break;
      await new Promise((n) => setTimeout(n, 10));
    }
    const E = this.forge.active;
    E !== ((t = this.display) == null ? void 0 : t.accumulator) && (this.forge.active.refCount += 1), await this.sortUpdate({ accumulator: E, viewToWorld: this.viewToWorld });
  }
  // Render out the viewpoint to the view target RGBA buffer.
  // Swaps buffers if doubleBuffer: true was set.
  // Calls onTextureUpdated(texture) with the resulting texture.
  renderTarget({
    scene: A,
    camera: I
  }) {
    var Q;
    const B = this.back ?? this.target;
    if (!B)
      throw new Error("Must initialize ForgeViewpoint with target");
    if (I = I ?? this.camera, !I)
      throw new Error("Must provide camera");
    if (I instanceof a.PerspectiveCamera) {
      const C = new a.PerspectiveCamera().copy(I, !1);
      C.aspect = B.width / B.height, C.updateProjectionMatrix(), I = C;
    }
    this.viewToWorld = I.matrixWorld.clone();
    try {
      this.forge.renderer.setRenderTarget(B), this.forge.prepareViewpoint(this), this.forge.renderer.render(A, I);
    } finally {
      this.forge.prepareViewpoint(this.forge.defaultView), this.forge.renderer.setRenderTarget(null);
    }
    B !== this.target && ([this.target, this.back] = [this.back, this.target]), (Q = this.onTextureUpdated) == null || Q.call(this, B.texture);
  }
  // Read back the previously rendered target image as a Uint8Array of packed
  // RGBA values (in that order). If superXY was set greater than 1 then
  // downsampling is performed in the target pixel array with simple averaging
  // to derive the returned pixel values. Subsequent calls to this.readTarget()
  // will reuse the same buffers to minimize memory allocations.
  async readTarget() {
    if (!this.target)
      throw new Error("Must initialize ForgeViewpoint with target");
    const { width: A, height: I } = this.target, B = A * I * 4;
    (!this.superPixels || this.superPixels.length < B) && (this.superPixels = new Uint8Array(B)), await this.forge.renderer.readRenderTargetPixelsAsync(
      this.target,
      0,
      0,
      A,
      I,
      this.superPixels
    );
    const { superXY: Q } = this;
    if (Q === 1)
      return this.superPixels;
    const C = A / Q, E = I / Q, t = C * E * 4;
    (!this.pixels || this.pixels.length < t) && (this.pixels = new Uint8Array(t));
    const { superPixels: i, pixels: e } = this, n = Q * Q;
    for (let s = 0; s < E; s++) {
      const o = s * C;
      for (let r = 0; r < C; r++) {
        const c = r * Q;
        let h = 0, w = 0, D = 0, y = 0;
        for (let d = 0; d < Q; d++) {
          const u = (s * Q + d) * this.target.width;
          for (let p = 0; p < Q; p++) {
            const m = (u + c + p) * 4;
            h += i[m], w += i[m + 1], D += i[m + 2], y += i[m + 3];
          }
        }
        const l = (o + r) * 4;
        e[l] = h / n, e[l + 1] = w / n, e[l + 2] = D / n, e[l + 3] = y / n;
      }
    }
    return e;
  }
  // Render out a viewpoint as a Uint8Array of RGBA values for the provided scene
  // and any camera/viewToWorld viewpoint overrides. By default update is true,
  // which triggers its ForgeRenderer to check and potentially update the Gsplats.
  // Setting update to false disables this and sorts the Gsplats as they are.
  // Setting forceOrigin (default: false) to true forces the view update to
  // recalculate the splats with this view origin, potentially altering any
  // view-dependent effects. If you expect view-dependent effects to play a role
  // in the rendering quality, enable this.
  //
  // Underneath, prepareRenderPixels() simply calls await this.prepare(...),
  // this.renderTarget(...), and finally returns the result this.readTarget(),
  // a Promise to a Uint8Array with RGBA values for all the pixels (potentially
  // downsampled if the superXY parameter was used). These steps can also be called
  // manually, for example if you need to alter the scene before and after
  // this.renderTarget(...) to hide UI elements from being rendered.
  async prepareRenderPixels({
    scene: A,
    camera: I,
    viewToWorld: B,
    update: Q,
    forceOrigin: C
  }) {
    return await this.prepare({ scene: A, camera: I, viewToWorld: B, update: Q, forceOrigin: C }), this.renderTarget({ scene: A, camera: I }), this.readTarget();
  }
  // This is called automatically by ForgeRenderer, there is no need to call it!
  // The method cannot be private because then ForgeRenderer would
  // not be able to call it.
  autoPoll({ accumulator: A }) {
    var C, E, t, i;
    this.camera && (this.camera.updateMatrixWorld(), this.viewToWorld = this.camera.matrixWorld.clone());
    let I = !1, B = !1;
    if (!this.display)
      I = !0;
    else if (A) {
      I = !0;
      const { mappingVersion: e } = this.display.accumulator;
      A.mappingVersion === e && (this.forge.releaseAccumulator(this.display.accumulator), this.display.accumulator = A, B = !0);
    }
    const Q = ((C = this.sorting) == null ? void 0 : C.viewToWorld) ?? ((E = this.display) == null ? void 0 : E.viewToWorld);
    Q && !gI({
      matrix1: this.viewToWorld,
      matrix2: Q,
      // By default update sort each 1 cm
      maxDistance: this.sortDistance ?? 0.01,
      // By default for radial sort, update for intermittent movement so that
      // we bring back splats culled by being behind the camera.
      // For depth sort, small rotations can change sort order a lot, so
      // update sort for even small rotations.
      minCoorient: this.sortCoorient ?? this.sortRadial ? 0.99 : 0.999
    }) && (I = !0), I && (A && (A.refCount += 1), A && ((t = this.pending) != null && t.accumulator) && this.pending.accumulator !== ((i = this.display) == null ? void 0 : i.accumulator) && this.forge.releaseAccumulator(this.pending.accumulator), this.pending = { accumulator: A, viewToWorld: this.viewToWorld, displayed: B }, this.driveSort());
  }
  async driveSort() {
    var A;
    for (; ; ) {
      if (this.sorting || !this.pending)
        return;
      const { viewToWorld: I, displayed: B } = this.pending;
      let Q = this.pending.accumulator ?? ((A = this.display) == null ? void 0 : A.accumulator);
      if (Q || (Q = this.forge.active, Q.refCount += 1), this.pending = null, !Q)
        throw new Error("No accumulator to sort");
      this.sorting = { viewToWorld: I }, await this.sortUpdate({ accumulator: Q, viewToWorld: I, displayed: B }), this.sorting = null;
    }
  }
  async sortUpdate({
    accumulator: A,
    viewToWorld: I,
    displayed: B = !1
  }) {
    if (this.sortingCheck)
      throw new Error("Only one sort at a time");
    this.sortingCheck = !0, A = A ?? this.forge.active;
    const { numSplats: Q, maxSplats: C } = A.splats;
    let E = 0, t = this.orderingFreelist.alloc(C);
    if (Q > 0) {
      const {
        reader: i,
        doubleSortReader: e,
        dynoSortRadial: n,
        dynoOrigin: s,
        dynoDirection: o,
        dynoDepthBias: r,
        dynoSort360: c,
        dynoSplats: h
      } = PA.makeSorter(), w = Math.ceil(C / 2);
      this.readback = i.ensureBuffer(w, this.readback);
      const D = A.toWorld.clone().invert(), y = I.clone().premultiply(D);
      n.value = this.sort360 ? !0 : this.sortRadial, s.value.set(0, 0, 0).applyMatrix4(y), o.value.set(0, 0, -1).applyMatrix4(y).sub(s.value).normalize(), r.value = this.depthBias ?? 1, c.value = this.sort360 ?? !1, h.packedSplats = A.splats, await i.renderReadback({
        renderer: this.forge.renderer,
        reader: e,
        count: Math.ceil(Q / 2),
        readback: this.readback
      });
      const l = await og(async (d) => d.call("sortDoubleSplats", {
        numSplats: Q,
        readback: this.readback,
        ordering: t
      }));
      this.readback = l.readback, t = l.ordering, E = l.activeSplats;
    }
    this.updateDisplay({
      accumulator: A,
      viewToWorld: I,
      ordering: t,
      activeSplats: E,
      displayed: B
    }), this.sortingCheck = !1;
  }
  updateDisplay({
    accumulator: A,
    viewToWorld: I,
    ordering: B,
    activeSplats: Q,
    displayed: C = !1
  }) {
    if (!this.display)
      this.display = {
        accumulator: A,
        viewToWorld: I,
        geometry: new UI(B, Q)
      };
    else {
      !C && A !== this.display.accumulator && (this.forge.releaseAccumulator(this.display.accumulator), this.display.accumulator = A), this.display.viewToWorld = I;
      const E = this.display.geometry.ordering;
      E.length === B.length ? this.display.geometry.update(B, Q) : (this.display.geometry.dispose(), this.display.geometry = new UI(B, Q)), this.orderingFreelist.free(E);
    }
    this.forge.viewpoint === this && this.forge.prepareViewpoint(this);
  }
  static makeSorter() {
    if (!PA.dynos) {
      const A = new $g({ value: !0 }), I = new yg({ value: new a.Vector3() }), B = new yg({ value: new a.Vector3() }), Q = new Cg({ value: 1 }), C = new $g({ value: !1 }), E = new zI(), t = new II(), i = YA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: e }) => {
          if (!e)
            throw new Error("No index");
          const n = {
            sortRadial: A,
            sortOrigin: I,
            sortDirection: B,
            sortDepthBias: Q,
            sort360: C
          }, s = rA(e, gA("int", 2)), o = mg(E, s), r = CB({ gsplat: o, ...n }), c = mg(
            E,
            NA(s, gA("int", 1))
          ), h = CB({ gsplat: c, ...n }), w = KA({
            vectorType: "vec2",
            x: r,
            y: h
          });
          return { rgba8: YC(SC(w)) };
        }
      );
      PA.dynos = {
        dynoSortRadial: A,
        dynoOrigin: I,
        dynoDirection: B,
        dynoDepthBias: Q,
        dynoSort360: C,
        dynoSplats: E,
        reader: t,
        doubleSortReader: i
      };
    }
    return PA.dynos;
  }
};
PA.EMPTY_TEXTURE = new a.Texture(), PA.dynos = null;
let EI = PA;
const zn = aA(`
  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {
    if (!isGsplatActive(gsplat.flags)) {
      return INFINITY;
    }

    vec3 center = gsplat.center - sortOrigin;
    float biasedDepth = dot(center, sortDirection) + sortDepthBias;
    if (!sort360 && (biasedDepth <= 0.0)) {
      return INFINITY;
    }

    return sortRadial ? length(center) : biasedDepth;
  }
`);
function CB({
  gsplat: g,
  sortRadial: A,
  sortOrigin: I,
  sortDirection: B,
  sortDepthBias: Q,
  sort360: C
}) {
  return xg({
    inTypes: {
      gsplat: BA,
      sortRadial: "bool",
      sortOrigin: "vec3",
      sortDirection: "vec3",
      sortDepthBias: "float",
      sort360: "bool"
    },
    outTypes: { metric: "float" },
    globals: () => [pA, zn],
    inputs: {
      gsplat: g,
      sortRadial: A,
      sortOrigin: I,
      sortDirection: B,
      sortDepthBias: Q,
      sort360: C
    },
    statements: ({ inputs: E, outputs: t }) => {
      const {
        gsplat: i,
        sortRadial: e,
        sortOrigin: n,
        sortDirection: s,
        sortDepthBias: o,
        sort360: r
      } = E;
      return mA(`
        ${t.metric} = computeSort(${i}, ${e}, ${n}, ${s}, ${o}, ${r});
      `);
    }
  }).outputs.metric;
}
class NI {
  constructor() {
    this.splats = new ZA(), this.toWorld = new a.Matrix4(), this.mapping = [], this.refCount = 0, this.splatsVersion = -1, this.mappingVersion = -1;
  }
  ensureGenerate(A) {
    this.splats.ensureGenerate(A) && (this.mapping = []);
  }
  // Generate all Gsplats from an array of generators
  generateSplats({
    renderer: A,
    modifier: I,
    generators: B,
    forceUpdate: Q,
    originToWorld: C
  }) {
    const E = this.mapping.reduce((e, n) => (e.set(n.node, n), e), /* @__PURE__ */ new Map());
    let t = 0, i = 0;
    for (const { node: e, generator: n, version: s, base: o, count: r } of B) {
      const c = E.get(e);
      if ((Q || n !== (c == null ? void 0 : c.generator) || s !== (c == null ? void 0 : c.version) || o !== (c == null ? void 0 : c.base) || r !== (c == null ? void 0 : c.count)) && n && r > 0) {
        const h = I.apply(n);
        try {
          this.splats.generate({
            generator: h,
            base: o,
            count: r,
            renderer: A
          });
        } catch (w) {
          e.generator = void 0, e.generatorError = w;
        }
        t += 1;
      }
      i = Math.max(i, o + r);
    }
    return this.splats.numSplats = i, this.toWorld = C, this.mapping = B, t !== 0;
  }
  // Check if this accumulator has exactly the same generator mapping as
  // the previous one. If so, we can reuse the Gsplat sort order.
  hasCorrespondence(A) {
    return this.mapping.length !== A.mapping.length ? !1 : this.mapping.every(({ node: I, base: B, count: Q }, C) => {
      const {
        node: E,
        base: t,
        count: i
      } = A.mapping[C];
      return I === E && B === t && Q === i;
    });
  }
}
var jn = `const float LN_SCALE_MIN = -9.0;
const float LN_SCALE_MAX = 9.0;
const float LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254.0; 

const uint SPLAT_TEX_WIDTH_BITS = 11u;
const uint SPLAT_TEX_HEIGHT_BITS = 11u;
const uint SPLAT_TEX_DEPTH_BITS = 11u;
const uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;

const uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;
const uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;
const uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;

const uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;
const uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;
const uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;

const uint F16_INF = 0x7c00u;
const float PI = 3.1415926535897932384626433832795;

const float INFINITY = 1.0 / 0.0;
const float NEG_INFINITY = -INFINITY;

const float MAX_PIXEL_RADIUS = 512.0;
const float MIN_ALPHA = 0.01;
const float MAX_STDDEV = sqrt(8.0);

float sqr(float x) {
    return x * x;
}

float pow4(float x) {
    float x2 = x * x;
    return x2 * x2;
}

float pow8(float x) {
    float x4 = pow4(x);
    return x4 * x4;
}

vec3 srgbToLinear(vec3 rgb) {
    return pow(rgb, vec3(2.2));
}

vec3 linearToSrgb(vec3 rgb) {
    return pow(rgb, vec3(1.0 / 2.2));
}

uint encodeQuatOctXy88R8(vec4 q) {
    
    if (q.w < 0.0) {
        q = -q;
    }
    
    float theta = 2.0 * acos(q.w);
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    
    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;
    
    
    
    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);
    vec2 p = vec2(axis.x, axis.y) / sum;
    
    if (axis.z < 0.0) {
        float oldPx = p.x;
        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);
        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);
    }
    
    float u_f = p.x * 0.5 + 0.5;
    float v_f = p.y * 0.5 + 0.5;
    
    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));
    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));
    
    
    
    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));
    
    
    return (angleInt << 16u) | (quantV << 8u) | quantU;
}

vec4 decodeQuatOctXy88R8(uint encoded) {
    
    uint quantU = encoded & uint(0xFFu);               
    uint quantV = (encoded >> 8u) & uint(0xFFu);         
    uint angleInt = encoded >> 16u;                      

    
    float u_f = float(quantU) / 255.0;
    float v_f = float(quantV) / 255.0;
    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);

    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));
    float t = max(-axis.z, 0.0);
    axis.x += (axis.x >= 0.0) ? -t : t;
    axis.y += (axis.y >= 0.0) ? -t : t;
    axis = normalize(axis);
    
    
    float theta = (float(angleInt) / 255.0) * 3.14159265359;
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    float w = cos(halfTheta);
    
    return vec4(axis * s, w);
}

    

    

    

    

    

    

    

    

    

    

uvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {
    uvec4 uRgba = uvec4(round(clamp(rgba * 255.0, 0.0, 255.0)));

    uint uQuat = encodeQuatOctXy88R8(quaternion);
    
    
    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);

    
    uvec3 uScales = uvec3(
        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,
        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,
        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u
    );

    
    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);
    uint word1 = packHalf2x16(center.xy);
    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);
    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);
    return uvec4(word0, word1, word2, word3);
}

void unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {
    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;

    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);
    rgba = vec4(uRgba) / 255.0;

    center = vec4(
        unpackHalf2x16(word1),
        unpackHalf2x16(word2 & 0xffffu)
    ).xyz;

    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);
    scales = vec3(
        (uScales.x == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.x - 1u) * LN_RESCALE),
        (uScales.y == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.y - 1u) * LN_RESCALE),
        (uScales.z == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.z - 1u) * LN_RESCALE)
    );

    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);
    quaternion = decodeQuatOctXy88R8(uQuat);
    
    
}

vec3 quatVec(vec4 q, vec3 v) {
    
    vec3 t = 2.0 * cross(q.xyz, v);
    return v + q.w * t + cross(q.xyz, t);
}

vec4 quatQuat(vec4 q1, vec4 q2) {
    return vec4(
        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,
        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z
    );
}

mat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {
    
    return mat3(
        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),
        s.x * (2.0 * (q.x * q.y + q.w * q.z)),
        s.x * (2.0 * (q.x * q.z - q.w * q.y)),
        s.y * (2.0 * (q.x * q.y - q.w * q.z)),
        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),
        s.y * (2.0 * (q.y * q.z + q.w * q.x)),
        s.z * (2.0 * (q.x * q.z + q.w * q.y)),
        s.z * (2.0 * (q.y * q.z - q.w * q.x)),
        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))
    );
}

vec4 slerp(vec4 q1, vec4 q2, float t) {
    
    float cosHalfTheta = dot(q1, q2);

    
    if (abs(cosHalfTheta) >= 0.999) {
        return q1;
    }
    
    
    
    if (cosHalfTheta < 0.0) {
        q2 = -q2;
        cosHalfTheta = -cosHalfTheta;
    }

    
    float halfTheta = acos(cosHalfTheta);
    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);

    
    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;
    float ratioB = sin(t * halfTheta) / sinHalfTheta;

    
    return q1 * ratioA + q2 * ratioB;
}

ivec3 splatTexCoord(int index) {
    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;
    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;
    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;
    return ivec3(x, y, z);
}`, On = `precision highp float;
precision highp int;

#include <splatDefines>

uniform bool encodeLinear;
uniform float maxStdDev;
uniform bool disableFalloff;
uniform float falloff;

out vec4 fragColor;

in vec4 vRgba;
in vec2 vSplatUv;
in vec3 vNdc;

void main() {
    float z = dot(vSplatUv, vSplatUv);
    if (z > (maxStdDev * maxStdDev)) {
        discard;
    }

    float alpha = vRgba.a;
    alpha *= mix(1.0, exp(-0.5 * z), falloff);
    if (alpha < MIN_ALPHA) {
        discard;
    }

    vec3 rgb = vRgba.rgb;
    if (encodeLinear) {
        rgb = srgbToLinear(rgb);
    }
    fragColor = vec4(rgb, alpha);
}`, Pn = `precision highp float;
precision highp int;
precision highp usampler2DArray;

#include <splatDefines>

attribute uint splatIndex;

out vec4 vRgba;
out vec2 vSplatUv;
out vec3 vNdc;

uniform vec2 renderSize;
uniform uint numSplats;
uniform vec4 renderToViewQuat;
uniform vec3 renderToViewPos;
uniform float maxStdDev;
uniform float time;
uniform float deltaTime;
uniform bool debugFlag;
uniform bool enable2DGS;
uniform float blurAmount;
uniform float preBlurAmount;
uniform float clipXY;

uniform usampler2DArray packedSplats;

void main() {
    
    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);

    if (uint(gl_InstanceID) >= numSplats) {
        return;
    }
    if (splatIndex == 0xffffffffu) {
        
        return;
    }

    ivec3 texCoord = ivec3(
        splatIndex & SPLAT_TEX_WIDTH_MASK,
        (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,
        splatIndex >> SPLAT_TEX_LAYER_BITS
    );
    uvec4 packed = texelFetch(packedSplats, texCoord, 0);

    vec3 center, scales;
    vec4 quaternion, rgba;
    unpackSplat(packed, center, scales, quaternion, rgba);

    if (rgba.a < MIN_ALPHA) {
        return;
    }
    bvec3 zeroScales = equal(scales, vec3(0.0));
    if (all(zeroScales)) {
        return;
    }

    
    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;

    
    if (viewCenter.z >= 0.0) {
        return;
    }

    
    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);

    
    if (abs(clipCenter.z) >= clipCenter.w) {
        return;
    }

    
    float clip = clipXY * clipCenter.w;
    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {
        return;
    }

    
    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);

    if (enable2DGS && any(zeroScales)) {
        vRgba = rgba;
        vSplatUv = position.xy * maxStdDev;

        vec3 offset;
        if (zeroScales.z) {
            offset = vec3(vSplatUv.xy * scales.xy, 0.0);
        } else if (zeroScales.y) {
            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);
        } else {
            offset = vec3(0.0, vSplatUv.xy * scales.yz);
        }

        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);
        gl_Position = projectionMatrix * vec4(viewPos, 1.0);
        vNdc = gl_Position.xyz / gl_Position.w;
        return;
    }

    
    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;

    
    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);
    mat3 cov3D = RS * transpose(RS);

    
    vec2 focal = 0.5 * renderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);
    float invZ = 1.0 / viewCenter.z;
    vec2 J1 = focal * invZ;
    vec2 J2 = -(J1 * viewCenter.xy) * invZ;
    mat3 J = mat3(
        J1.x, 0.0, J2.x,
        0.0, J1.y, J2.y,
        0.0, 0.0, 0.0
    );

    
    
    
    
    
    
    
    mat3 cov2D = transpose(J) * cov3D * J;
    float a = cov2D[0][0];
    float d = cov2D[1][1];
    float b = cov2D[0][1];

    
    a += preBlurAmount;
    d += preBlurAmount;

    
    float detOrig = a * d - b * b;
    a += blurAmount;
    d += blurAmount;
    float det = a * d - b * b;

    
    float blurAdjust = sqrt(max(0.0, detOrig / det));
    rgba.a *= blurAdjust;
    if (rgba.a < MIN_ALPHA) {
        return;
    }

    
    float eigenAvg = 0.5 * (a + d);
    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));
    float eigen1 = eigenAvg + eigenDelta;
    float eigen2 = eigenAvg - eigenDelta;

    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));
    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);

    float scale1 = position.x * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen1));
    float scale2 = position.y * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen2));

    
    vec2 pixelOffset = eigenVec1 * scale1 + eigenVec2 * scale2;
    vec2 ndcOffset = (2.0 / renderSize) * pixelOffset;
    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);

    vRgba = rgba;
    vSplatUv = position.xy * maxStdDev;
    vNdc = ndc;
    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);
}`;
let pI = null;
function _n() {
  return pI || (a.ShaderChunk.splatDefines = jn, pI = {
    splatVertex: Pn,
    splatFragment: On
  }), pI;
}
const EB = 5;
let xI = !1, LI = !1, Ft;
const Rt = a.Scene.prototype.add;
a.Scene.prototype.add = function(g) {
  return xI = xI || g instanceof Ag, LI = LI || g instanceof tI, Rt.call(this, g), this;
};
const $n = a.Scene.prototype.onBeforeRender;
a.Scene.prototype.onBeforeRender = function(g) {
  if (xI) {
    if (!LI) {
      const A = Ft || new tI({ renderer: g });
      this.add(A);
    }
    a.Scene.prototype.onBeforeRender = $n, a.Scene.prototype.add = Rt;
  }
};
const yA = class yA extends a.Mesh {
  constructor(A) {
    const I = yA.makeUniforms(), B = _n(), Q = new a.ShaderMaterial({
      glslVersion: a.GLSL3,
      vertexShader: B.splatVertex,
      fragmentShader: B.splatFragment,
      uniforms: I,
      transparent: !0,
      blending: a.NormalBlending,
      depthTest: !0,
      depthWrite: !1,
      side: a.DoubleSide
    });
    super(tB, Q), this.autoViewpoints = [], this.rotateToAccumulator = new bg({ value: new a.Quaternion() }), this.translateToAccumulator = new yg({ value: new a.Vector3() }), this.lastFrame = -1, this.lastUpdateTime = null, this.defaultCameras = [], this.pendingUpdate = null, this.envViewpoint = null, this.frustumCulled = !1, this.renderer = A.renderer, this.material = Q, this.uniforms = I;
    const C = YA(
      { gsplat: BA },
      { gsplat: BA },
      ({ gsplat: E }) => {
        if (!E)
          throw new Error("gsplat not defined");
        return E = qI(E, {
          rotate: this.rotateToAccumulator,
          translate: this.translateToAccumulator
        }), { gsplat: E };
      }
    );
    this.modifier = new Jn(C), this.autoUpdate = A.autoUpdate ?? !0, this.preUpdate = A.preUpdate ?? !1, this.originDistance = A.originDistance ?? 1, this.maxStdDev = A.maxStdDev ?? Math.sqrt(8), this.enable2DGS = A.enable2DGS ?? !0, this.preBlurAmount = A.preBlurAmount ?? 0, this.blurAmount = A.blurAmount ?? 0.3, this.falloff = A.falloff ?? 1, this.clipXY = A.clipXY ?? 1.4, this.active = new NI(), this.accumulatorCount = 1, this.freeAccumulators = [];
    for (let E = 0; E < 1; ++E)
      this.freeAccumulators.push(new NI()), this.accumulatorCount += 1;
    this.defaultView = new EI({
      ...A.view,
      autoUpdate: !0,
      forge: this
    }), this.viewpoint = this.defaultView, this.prepareViewpoint(this.viewpoint), this.clock = A.clock ? GQ(A.clock) : new a.Clock(), Ft = this;
  }
  static makeUniforms() {
    return {
      // Size of render viewport in pixels
      renderSize: { value: new a.Vector2() },
      // Total number of Gsplats in packedSplats to render
      numSplats: { value: 0 },
      // SplatAccumulator to view transformation quaternion
      renderToViewQuat: { value: new a.Quaternion() },
      // SplatAccumulator to view transformation translation
      renderToViewPos: { value: new a.Vector3() },
      // Maximum distance (in stddevs) from Gsplat center to render
      maxStdDev: { value: 1 },
      // Enable interpreting 0-thickness Gsplats as 2DGS
      enable2DGS: { value: !1 },
      // Add to projected 2D splat covariance diagonal (thickens and brightens)
      preBlurAmount: { value: 0 },
      // Add to 2D splat covariance diagonal and adjust opacity (anti-aliasing)
      blurAmount: { value: 0.3 },
      // Modulate Gaussian kernal falloff. 0 means "no falloff, flat shading",
      // 1 is normal e^-x^2 falloff.
      falloff: { value: 1 },
      // Clip Gsplats that are clipXY times beyond the +-1 frustum bounds
      clipXY: { value: 1.4 },
      // Gsplat collection to render
      packedSplats: { type: "t", value: ZA.getEmpty() },
      // Time in seconds for time-based effects
      time: { value: 0 },
      // Delta time in seconds since last frame
      deltaTime: { value: 0 },
      // Whether to encode Gsplat with linear RGB (for environment mapping)
      encodeLinear: { value: !1 },
      // Debug flag that alternates each frame
      debugFlag: { value: !1 }
    };
  }
  canAllocAccumulator() {
    return this.freeAccumulators.length > 0 || this.accumulatorCount < EB;
  }
  maybeAllocAccumulator() {
    let A = this.freeAccumulators.pop();
    if (A === void 0) {
      if (this.accumulatorCount >= EB)
        return null;
      A = new NI(), this.accumulatorCount += 1;
    }
    return A.refCount = 1, A;
  }
  releaseAccumulator(A) {
    A.refCount -= 1, A.refCount === 0 && this.freeAccumulators.push(A);
  }
  newViewpoint(A) {
    return new EI({ ...A, forge: this });
  }
  onBeforeRender(A, I, B) {
    var o, r;
    const Q = this.time ?? this.clock.getElapsedTime(), C = Q - (this.viewpoint.lastTime ?? Q);
    this.viewpoint.lastTime = Q;
    const E = A.info.render.frame, t = E !== this.lastFrame;
    this.lastFrame = E;
    const i = this.viewpoint;
    if (i === this.defaultView) {
      if (t)
        if (!A.xr.isPresenting)
          this.defaultView.viewToWorld = B.matrixWorld.clone(), this.defaultCameras = [this.defaultView.viewToWorld];
        else {
          const c = A.xr.getCamera().cameras;
          this.defaultCameras = [
            c[0].matrixWorld,
            c[1].matrixWorld
          ], this.defaultView.viewToWorld = Ao(this.defaultCameras) ?? new a.Matrix4();
        }
      this.autoUpdate && this.update({ scene: I, viewToWorld: this.defaultView.viewToWorld });
    }
    if (t && (this.uniforms.time.value = Q, this.uniforms.deltaTime.value = C, this.uniforms.debugFlag.value = performance.now() / 1e3 % 2 < 1), i.target)
      this.uniforms.renderSize.value.set(
        i.target.width,
        i.target.height
      );
    else {
      const c = A.getSize(this.uniforms.renderSize.value);
      if (c.x === 1 && c.y === 1) {
        const h = (o = A.xr.getSession()) == null ? void 0 : o.renderState.baseLayer;
        h && (c.x = h.framebufferWidth, c.y = h.framebufferHeight);
      }
    }
    this.uniforms.encodeLinear.value = i.encodeLinear, this.uniforms.maxStdDev.value = this.maxStdDev, this.uniforms.enable2DGS.value = this.enable2DGS, this.uniforms.preBlurAmount.value = this.preBlurAmount, this.uniforms.blurAmount.value = this.blurAmount, this.uniforms.falloff.value = this.falloff, this.uniforms.clipXY.value = this.clipXY;
    const e = ((r = i.display) == null ? void 0 : r.accumulator.toWorld) ?? new a.Matrix4(), n = B.matrixWorld.clone().invert();
    e.clone().premultiply(n).decompose(
      this.uniforms.renderToViewPos.value,
      this.uniforms.renderToViewQuat.value,
      new a.Vector3()
    );
  }
  // Update the uniforms for the given viewpoint.
  // Note that the client expects to be able to call render() at any point
  // to update the canvas, so we must switch the viewpoint back to
  // defaultView when we're finished.
  prepareViewpoint(A) {
    if (this.viewpoint = A ?? this.viewpoint, this.viewpoint.display) {
      const { accumulator: I, geometry: B } = this.viewpoint.display;
      this.uniforms.numSplats.value = I.splats.numSplats, this.uniforms.packedSplats.value = I.splats.getTexture(), this.geometry = B;
    } else
      this.uniforms.numSplats.value = 0, this.uniforms.packedSplats.value = ZA.getEmpty(), this.geometry = tB;
  }
  // If forge.autoUpdate is false then you must manually call
  // forge.update({ scene }) to have the scene Gsplats be re-generated.
  update({
    scene: A,
    viewToWorld: I
  }) {
    const B = this.matrixWorld.clone();
    this.preUpdate ? this.updateInternal({ scene: A, originToWorld: B, viewToWorld: I }) : (this.pendingUpdate = {
      scene: A,
      originToWorld: B
    }, setTimeout(() => {
      if (this.pendingUpdate) {
        const { scene: Q, originToWorld: C } = this.pendingUpdate;
        this.pendingUpdate = null, this.updateInternal({ scene: Q, originToWorld: C, viewToWorld: I });
      }
    }, 1));
  }
  updateInternal({
    scene: A,
    originToWorld: I,
    viewToWorld: B
  }) {
    var o;
    if (!this.canAllocAccumulator())
      return !1;
    I || (I = this.active.toWorld), B = B ?? I.clone();
    const Q = this.time ?? this.clock.getElapsedTime(), C = Q - (this.lastUpdateTime ?? Q);
    this.lastUpdateTime = Q;
    const E = this.active.mapping.reduce((r, c) => (r.set(c.node, c), r), /* @__PURE__ */ new Map()), { generators: t, globalEdits: i } = this.compileScene(A);
    for (const r of t)
      (o = r.frameUpdate) == null || o.call(r, {
        object: r,
        time: Q,
        deltaTime: C,
        viewToWorld: B,
        globalEdits: i
      });
    for (const r of t) {
      const c = E.get(r), h = r.generator ? r.numSplats : 0;
      (r.generator !== (c == null ? void 0 : c.generator) || h !== (c == null ? void 0 : c.count)) && r.updateVersion();
    }
    const n = !gI({
      matrix1: I,
      matrix2: this.active.toWorld,
      maxDistance: this.originDistance
    }) || t.length !== E.size || t.some((r) => {
      var c;
      return r.version !== ((c = E.get(r)) == null ? void 0 : c.version);
    });
    let s = null;
    if (n) {
      if (s = this.maybeAllocAccumulator(), !s)
        throw new Error("Unreachable");
      const r = !gI({
        matrix1: I,
        matrix2: this.active.toWorld,
        maxDistance: 1e-5,
        minCoorient: 0.99999
      }), h = t.map((u, p) => {
        const m = E.get(u);
        return m ? (
          // Sort by version deltas then by previous ordering in the mapping,
          // attempting to keep unchanging generators near the front
          // to improve our chances of avoiding a re-generation.
          [u.version - m.version, m.base, u]
        ) : [Number.POSITIVE_INFINITY, u.version, u];
      }).sort((u, p) => u[0] !== p[0] ? u[0] - p[0] : u[1] - p[1]).map(([u, p, m]) => m), w = h.map((u) => u.numSplats), { maxSplats: D, mapping: y } = s.splats.generateMapping(w), l = h.map((u, p) => {
        const { base: m, count: M } = y[p];
        return {
          node: u,
          generator: u.generator,
          version: u.version,
          base: m,
          count: M
        };
      });
      I.clone().invert().decompose(
        this.translateToAccumulator.value,
        this.rotateToAccumulator.value,
        new a.Vector3()
      ), s.ensureGenerate(D), s.generateSplats({
        renderer: this.renderer,
        modifier: this.modifier,
        generators: l,
        forceUpdate: r,
        originToWorld: I
      }), s.splatsVersion = this.active.splatsVersion + 1;
      const d = s.hasCorrespondence(this.active);
      s.mappingVersion = this.active.mappingVersion + (d ? 0 : 1), this.releaseAccumulator(this.active), this.active = s, this.prepareViewpoint();
    }
    return setTimeout(() => {
      for (const r of this.autoViewpoints)
        r.autoPoll({ accumulator: s ?? void 0 });
    }, 1), !0;
  }
  compileScene(A) {
    const I = [];
    A.traverse((Q) => {
      Q instanceof nI && I.push(Q);
    });
    const B = /* @__PURE__ */ new Set();
    return A.traverseVisible((Q) => {
      if (Q instanceof BI) {
        let C = Q.parent;
        for (; C != null && !(C instanceof Ag); )
          C = C.parent;
        C == null && B.add(Q);
      }
    }), { generators: I, globalEdits: Array.from(B) };
  }
  // Renders out the scene to an environment map that can be used for
  // Image-based lighting or similar applications. First optionally updates Gsplats,
  // sorts them with respect to the provided worldCenter, renders 6 cube faces,
  // then pre-filters them using THREE.PMREMGenerator and returns a THREE.Texture
  // that can assigned directly to a THREE.MeshStandardMaterial.envMap property.
  async renderEnvMap({
    renderer: A,
    scene: I,
    worldCenter: B,
    size: Q = 256,
    near: C = 0.1,
    far: E = 1e3,
    hideObjects: t = [],
    update: i = !1
  }) {
    var r, c;
    if (this.envViewpoint || (this.envViewpoint = this.newViewpoint({ sort360: !0 })), !yA.cubeRender || yA.cubeRender.target.width !== Q || yA.cubeRender.near !== C || yA.cubeRender.far !== E) {
      yA.cubeRender && yA.cubeRender.target.dispose();
      const h = new a.WebGLCubeRenderTarget(Q, {
        format: a.RGBAFormat,
        generateMipmaps: !0,
        minFilter: a.LinearMipMapLinearFilter
      }), w = new a.CubeCamera(C, E, h);
      yA.cubeRender = { target: h, camera: w, near: C, far: E };
    }
    yA.pmrem || (yA.pmrem = new a.PMREMGenerator(A ?? this.renderer));
    const e = new a.Matrix4().setPosition(B);
    await ((r = this.envViewpoint) == null ? void 0 : r.prepare({ scene: I, viewToWorld: e, update: i }));
    const { target: n, camera: s } = yA.cubeRender;
    s.position.copy(B);
    const o = /* @__PURE__ */ new Map();
    for (const h of t)
      o.set(h, h.visible), h.visible = !1;
    this.prepareViewpoint(this.envViewpoint), s.update(A ?? this.renderer, I), this.prepareViewpoint(this.defaultView);
    for (const [h, w] of o.entries())
      h.visible = w;
    return (c = yA.pmrem) == null ? void 0 : c.fromCubemap(n.texture).texture;
  }
  // Utility function to recursively set the envMap property for any
  // THREE.MeshStandardMaterial within the subtree of root.
  recurseSetEnvMap(A, I) {
    A.traverse((B) => {
      if (B instanceof a.Mesh)
        if (Array.isArray(B.material))
          for (const Q of B.material)
            Q instanceof a.MeshStandardMaterial && (Q.envMap = I);
        else
          B.material instanceof a.MeshStandardMaterial && (B.material.envMap = I);
    });
  }
  // Utility function that helps extract the Gsplat RGBA values from a
  // SplatGenerator, including the result of any real-time RGBA SDF edits applied
  // to a SplatMesh. This effectively "bakes" any computed RGBA values, which can
  // now be used as a pipeline input via SplatMesh.splatRgba to inject these
  // baked values into the Gsplat data.
  getRgba({
    generator: A,
    rgba: I
  }) {
    const B = this.active.mapping.find(({ node: Q }) => Q === A);
    if (!B)
      throw new Error("Generator not found");
    return I = I ?? new YI(), I.fromPackedSplats({
      packedSplats: this.active.splats,
      base: B.base,
      count: B.count,
      renderer: this.renderer
    }), I;
  }
  // Utility function that builds on getRgba({ generator }) and additionally
  // reads back the RGBA values to the CPU in a Uint8Array with packed RGBA
  // in that byte order.
  async readRgba({
    generator: A,
    rgba: I
  }) {
    return I = this.getRgba({ generator: A, rgba: I }), I.read();
  }
};
yA.cubeRender = null, yA.pmrem = null;
let tI = yA;
const tB = new UI(new Uint32Array(1), 0);
YA(
  { packedSplats: Lg, index: "int" },
  { gsplat: BA },
  ({ packedSplats: g, index: A }) => {
    if (!g || !A)
      throw new Error("Invalid input");
    return { gsplat: mg(g, A) };
  }
);
function Ao(g) {
  if (g.length === 0)
    return null;
  const A = new a.Vector3(), I = new a.Quaternion(), B = new a.Vector3(), Q = [], C = [];
  for (const E of g)
    E.decompose(A, I, B), Q.push(A), C.push(I);
  return new a.Matrix4().compose(
    NQ(Q),
    pQ(C),
    new a.Vector3(1, 1, 1)
  );
}
function go(g, A, I) {
  const B = Math.floor(g.length / 32);
  if (B * 32 !== g.length)
    throw new Error("Invalid .splat file size");
  const Q = new Float32Array(g.buffer);
  for (let C = 0; C < B; ++C) {
    const E = C * 32, t = C * 8, i = Q[t + 0], e = Q[t + 1], n = Q[t + 2], s = Q[t + 3], o = Q[t + 4], r = Q[t + 5], c = g[E + 24] / 255, h = g[E + 25] / 255, w = g[E + 26] / 255, D = g[E + 27] / 255, y = (g[E + 28] - 128) / 128, l = (g[E + 29] - 128) / 128, d = (g[E + 30] - 128) / 128, u = (g[E + 31] - 128) / 128;
    I(
      C,
      i,
      e,
      n,
      s,
      o,
      r,
      l,
      d,
      u,
      y,
      D,
      c,
      h,
      w
    );
  }
}
const iB = {
  0: {
    bytesPerCenter: 12,
    bytesPerScale: 12,
    bytesPerRotation: 16,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 4,
    scaleOffsetBytes: 12,
    rotationOffsetBytes: 24,
    colorOffsetBytes: 40,
    sphericalHarmonicsOffsetBytes: 44,
    scaleRange: 1
  },
  1: {
    bytesPerCenter: 6,
    bytesPerScale: 6,
    bytesPerRotation: 8,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 2,
    scaleOffsetBytes: 6,
    rotationOffsetBytes: 12,
    colorOffsetBytes: 20,
    sphericalHarmonicsOffsetBytes: 24,
    scaleRange: 32767
  },
  2: {
    bytesPerCenter: 6,
    bytesPerScale: 6,
    bytesPerRotation: 8,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 1,
    scaleOffsetBytes: 6,
    rotationOffsetBytes: 12,
    colorOffsetBytes: 20,
    sphericalHarmonicsOffsetBytes: 24,
    scaleRange: 32767
  }
}, Io = {
  0: 0,
  1: 9,
  2: 24,
  3: 45
};
function Bo(g, A, I, B) {
  var r;
  let E = 0;
  const t = new DataView(g.buffer, E, 4096);
  E += 4096;
  const i = t.getUint8(0), e = t.getUint8(1);
  if (i !== 0 || e < 1)
    throw new Error(
      `Unsupported .ksplat version: ${i}.${e}`
    );
  const n = t.getUint32(4, !0);
  t.getUint32(16, !0);
  const s = t.getUint16(20, !0);
  if (s < 0 || s > 2)
    throw new Error(`Invalid .ksplat compression level: ${s}`);
  t.getFloat32(36, !0), t.getFloat32(40, !0);
  let o = 4096 + n * 1024;
  for (let c = 0; c < n; ++c) {
    const h = new DataView(g.buffer, E, 1024);
    E += 1024;
    const w = h.getUint32(0, !0), D = h.getUint32(4, !0), y = h.getUint32(8, !0), l = h.getUint32(12, !0), d = h.getFloat32(16, !0), u = h.getUint16(20, !0), p = (h.getUint32(24, !0) || ((r = iB[s]) == null ? void 0 : r.scaleRange)) ?? 1, M = h.getUint32(36, !0) * 4, G = u * l + M, J = h.getUint16(40, !0), k = Io[J], {
      bytesPerCenter: N,
      bytesPerScale: Y,
      bytesPerRotation: F,
      bytesPerColor: f,
      bytesPerSphericalHarmonicsComponent: U,
      scaleOffsetBytes: L,
      rotationOffsetBytes: K,
      colorOffsetBytes: Z,
      sphericalHarmonicsOffsetBytes: QA
    } = iB[s], z = N + Y + F + f + k * U, AA = z * D, $ = AA + G, P = J >= 1 ? new Float32Array(3 * 3) : void 0, j = J >= 2 ? new Float32Array(5 * 3) : void 0, V = J >= 3 ? new Float32Array(7 * 3) : void 0, x = d / 2 / p, uA = o + M, iA = o + G, b = new DataView(
      g.buffer,
      iA,
      AA
    ), nA = new Float32Array(
      g.buffer,
      uA,
      l * 3
    );
    for (let oA = 0; oA < w; ++oA) {
      const H = oA * z, kA = Math.floor(oA / y), GA = s === 0 ? b.getFloat32(H + 0, !0) : (b.getUint16(H + 0, !0) - p) * x + nA[3 * kA + 0], UA = s === 0 ? b.getFloat32(H + 4, !0) : (b.getUint16(H + 2, !0) - p) * x + nA[3 * kA + 1], xA = s === 0 ? b.getFloat32(H + 8, !0) : (b.getUint16(H + 4, !0) - p) * x + nA[3 * kA + 2], LA = s === 0 ? b.getFloat32(H + L + 0, !0) : MA(b.getUint16(H + L + 0, !0)), lA = s === 0 ? b.getFloat32(H + L + 4, !0) : MA(b.getUint16(H + L + 2, !0)), vA = s === 0 ? b.getFloat32(H + L + 8, !0) : MA(b.getUint16(H + L + 4, !0)), oI = s === 0 ? b.getFloat32(H + K + 0, !0) : MA(
        b.getUint16(H + K + 0, !0)
      ), rI = s === 0 ? b.getFloat32(H + K + 4, !0) : MA(
        b.getUint16(H + K + 2, !0)
      ), cI = s === 0 ? b.getFloat32(H + K + 8, !0) : MA(
        b.getUint16(H + K + 4, !0)
      ), hI = s === 0 ? b.getFloat32(H + K + 12, !0) : MA(
        b.getUint16(H + K + 6, !0)
      ), wI = b.getUint8(H + Z + 0) / 255, DI = b.getUint8(H + Z + 1) / 255, lI = b.getUint8(H + Z + 2) / 255, yI = b.getUint8(H + Z + 3) / 255;
      I(
        oA,
        GA,
        UA,
        xA,
        LA,
        lA,
        vA,
        rI,
        cI,
        hI,
        oI,
        yI,
        wI,
        DI,
        lI
      ), J >= 1 && P && (B == null || B(oA, P, j, V));
    }
    o += $;
  }
}
class Qo {
  constructor({ fileBytes: A }) {
    this.fileBytes = A instanceof ArrayBuffer ? new Uint8Array(A) : A, this.reader = new mQ({ fileBytes: this.fileBytes });
    const I = new DataView(this.reader.read(16).buffer);
    if (I.getUint32(0, !0) !== 1347635022)
      throw new Error("Invalid SPZ file");
    if (this.version = I.getUint32(4, !0), this.version < 1 || this.version > 2)
      throw new Error(`Unsupported SPZ version: ${this.version}`);
    this.numSplats = I.getUint32(8, !0), this.shDegree = I.getUint8(12), this.fractionalBits = I.getUint8(13), this.flags = I.getUint8(14), this.flagAntiAlias = (this.flags & 1) !== 0, this.reserved = I.getUint8(15), this.parsed = !1;
  }
  parseSplats(A, I, B, Q, C, E) {
    if (this.parsed)
      throw new Error("SPZ file already parsed");
    if (this.parsed = !0, this.version === 1) {
      const t = this.reader.read(this.numSplats * 3 * 2), i = new Uint16Array(t.buffer);
      for (let e = 0; e < this.numSplats; e++) {
        const n = e * 3, s = MA(i[n]), o = MA(i[n + 1]), r = MA(i[n + 2]);
        A == null || A(e, s, o, r);
      }
    } else if (this.version === 2) {
      const t = 1 << this.fractionalBits, i = this.reader.read(this.numSplats * 3 * 3);
      for (let e = 0; e < this.numSplats; e++) {
        const n = e * 9, s = ((i[n + 2] << 24 | i[n + 1] << 16 | i[n] << 8) >> 8) / t, o = ((i[n + 5] << 24 | i[n + 4] << 16 | i[n + 3] << 8) >> 8) / t, r = ((i[n + 8] << 24 | i[n + 7] << 16 | i[n + 6] << 8) >> 8) / t;
        A == null || A(e, s, o, r);
      }
    } else
      throw new Error("Unreachable");
    {
      const t = this.reader.read(this.numSplats);
      for (let i = 0; i < this.numSplats; i++)
        I == null || I(i, t[i] / 255);
    }
    {
      const t = this.reader.read(this.numSplats * 3), i = mt / 0.15;
      for (let e = 0; e < this.numSplats; e++) {
        const n = e * 3, s = (t[n] / 255 - 0.5) * i + 0.5, o = (t[n + 1] / 255 - 0.5) * i + 0.5, r = (t[n + 2] / 255 - 0.5) * i + 0.5;
        B == null || B(e, s, o, r);
      }
    }
    {
      const t = this.reader.read(this.numSplats * 3);
      for (let i = 0; i < this.numSplats; i++) {
        const e = i * 3, n = Math.exp(t[e] / 16 - 10), s = Math.exp(t[e + 1] / 16 - 10), o = Math.exp(t[e + 2] / 16 - 10);
        Q == null || Q(i, n, s, o);
      }
    }
    {
      const t = this.reader.read(this.numSplats * 3);
      for (let i = 0; i < this.numSplats; i++) {
        const e = i * 3, n = t[e] / 127.5 - 1, s = t[e + 1] / 127.5 - 1, o = t[e + 2] / 127.5 - 1, r = Math.sqrt(
          Math.max(0, 1 - n * n - s * s - o * o)
        );
        C == null || C(i, n, s, o, r);
      }
    }
    if (E && this.shDegree >= 1) {
      const t = new Float32Array(9), i = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0, e = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0, n = this.reader.read(
        this.numSplats * Jt[this.shDegree] * 3
      );
      let s = 0;
      for (let o = 0; o < this.numSplats; o++) {
        for (let r = 0; r < 9; ++r)
          t[r] = (n[s + r] - 128) / 128;
        if (s += 9, i) {
          for (let r = 0; r < 15; ++r)
            i[r] = (n[s + r] - 128) / 128;
          s += 15;
        }
        if (e) {
          for (let r = 0; r < 21; ++r)
            e[r] = (n[s + r] - 128) / 128;
          s += 21;
        }
        E == null || E(o, t, i, e);
      }
    }
  }
}
const Jt = { 1: 3, 2: 8, 3: 15 }, mt = 0.28209479177387814, Co = 1347635022, Eo = 2, to = 1;
class jA {
  constructor({
    numSplats: A,
    shDegree: I,
    fractionalBits: B = 12,
    flagAntiAlias: Q = !0
  }) {
    this.clippedCount = 0;
    const C = 19 + (I >= 1 ? 9 : 0) + (I >= 2 ? 15 : 0) + (I >= 3 ? 21 : 0), E = 16 + A * C;
    this.buffer = new ArrayBuffer(E), this.view = new DataView(this.buffer), this.view.setUint32(0, Co, !0), this.view.setUint32(4, Eo, !0), this.view.setUint32(8, A, !0), this.view.setUint8(12, I), this.view.setUint8(13, B), this.view.setUint8(14, Q ? to : 0), this.view.setUint8(15, 0), this.numSplats = A, this.shDegree = I, this.fractionalBits = B, this.fraction = 1 << B, this.flagAntiAlias = Q;
  }
  setCenter(A, I, B, Q) {
    const C = Math.round(I * this.fraction), E = Math.max(-8388607, Math.min(8388607, C)), t = Math.round(B * this.fraction), i = Math.max(-8388607, Math.min(8388607, t)), e = Math.round(Q * this.fraction), n = Math.max(-8388607, Math.min(8388607, e));
    (C !== E || t !== i || e !== n) && (this.clippedCount += 1);
    const r = 16 + A * 9;
    this.view.setUint8(r, E & 255), this.view.setUint8(r + 1, E >> 8 & 255), this.view.setUint8(r + 2, E >> 16 & 255), this.view.setUint8(r + 3, i & 255), this.view.setUint8(r + 4, i >> 8 & 255), this.view.setUint8(r + 5, i >> 16 & 255), this.view.setUint8(r + 6, n & 255), this.view.setUint8(r + 7, n >> 8 & 255), this.view.setUint8(r + 8, n >> 16 & 255);
  }
  setAlpha(A, I) {
    const B = 16 + this.numSplats * 9 + A;
    this.view.setUint8(
      B,
      Math.max(0, Math.min(255, Math.round(I * 255)))
    );
  }
  static scaleRgb(A) {
    const I = ((A - 0.5) / (mt / 0.15) + 0.5) * 255;
    return Math.max(0, Math.min(255, Math.round(I)));
  }
  setRgb(A, I, B, Q) {
    const C = 16 + this.numSplats * 10 + A * 3;
    this.view.setUint8(C, jA.scaleRgb(I)), this.view.setUint8(C + 1, jA.scaleRgb(B)), this.view.setUint8(C + 2, jA.scaleRgb(Q));
  }
  setScale(A, I, B, Q) {
    const C = 16 + this.numSplats * 13 + A * 3;
    this.view.setUint8(
      C,
      Math.max(0, Math.min(255, Math.round((Math.log(I) + 10) * 16)))
    ), this.view.setUint8(
      C + 1,
      Math.max(0, Math.min(255, Math.round((Math.log(B) + 10) * 16)))
    ), this.view.setUint8(
      C + 2,
      Math.max(0, Math.min(255, Math.round((Math.log(Q) + 10) * 16)))
    );
  }
  setQuat(A, I, B, Q, C) {
    const E = 16 + this.numSplats * 16 + A * 3, t = C < 0;
    this.view.setUint8(
      E,
      Math.max(
        0,
        Math.min(255, Math.round(((t ? -I : I) + 1) * 127.5))
      )
    ), this.view.setUint8(
      E + 1,
      Math.max(
        0,
        Math.min(255, Math.round(((t ? -B : B) + 1) * 127.5))
      )
    ), this.view.setUint8(
      E + 2,
      Math.max(
        0,
        Math.min(255, Math.round(((t ? -Q : Q) + 1) * 127.5))
      )
    );
  }
  static quantizeSh(A, I) {
    const B = Math.round(A * 128) + 128, Q = 1 << 8 - I, C = Math.floor((B + Q / 2) / Q) * Q;
    return Math.max(0, Math.min(255, C));
  }
  setSh(A, I, B, Q) {
    const C = Jt[this.shDegree] || 0, E = 16 + this.numSplats * 19 + A * C * 3;
    for (let t = 0; t < 9; ++t)
      this.view.setUint8(E + t, jA.quantizeSh(I[t], 5));
    if (B) {
      const t = E + 9;
      for (let i = 0; i < 15; ++i)
        this.view.setUint8(t + i, jA.quantizeSh(B[i], 4));
      if (Q) {
        const i = t + 15;
        for (let e = 0; e < 21; ++e)
          this.view.setUint8(i + e, jA.quantizeSh(Q[e], 4));
      }
    }
  }
  async finalize() {
    const A = new Uint8Array(this.buffer), B = new ReadableStream({
      async start(E) {
        E.enqueue(A), E.close();
      }
    }).pipeThrough(new CompressionStream("gzip")), C = await new Response(B).arrayBuffer();
    return console.log(
      "Compressed",
      A.length,
      "bytes to",
      C.byteLength,
      "bytes"
    ), new Uint8Array(C);
  }
}
async function qo(g) {
  var n, s, o;
  const A = new Wn(), {
    inputs: I,
    clipXyz: B,
    maxSh: Q,
    fractionalBits: C = 12,
    opacityThreshold: E
  } = g;
  for (const r of I) {
    let c = function(M) {
      return M.multiplyScalar(l), M.applyQuaternion(d), M.add(u), M;
    }, h = function(M) {
      return M.multiplyScalar(l), M;
    }, w = function(M) {
      return M.premultiply(d), M;
    }, D = function(M) {
      return !p || p.containsPoint(M);
    }, y = function(M) {
      return E !== void 0 ? M >= E : !0;
    };
    const l = ((n = r.transform) == null ? void 0 : n.scale) ?? 1, d = new a.Quaternion().fromArray(
      ((s = r.transform) == null ? void 0 : s.quaternion) ?? [0, 0, 0, 1]
    ), u = new a.Vector3().fromArray(
      ((o = r.transform) == null ? void 0 : o.translate) ?? [0, 0, 0]
    ), p = B ? new a.Box3(
      new a.Vector3().fromArray(B.min),
      new a.Vector3().fromArray(B.max)
    ) : void 0;
    let m = r.fileType;
    switch (m || (m = Nt(r.fileBytes), !m && r.pathOrUrl && (m = pt(r.pathOrUrl))), m) {
      case rg.WLG0: {
        await KI();
        const M = Wt(
          r.fileBytes,
          X,
          WA
        );
        for (let G = 0; G < M.numSplats; ++G) {
          let { center: J, scales: k, quaternion: N, opacity: Y, color: F } = AI(
            M.packedSplats,
            G
          );
          if (J = c(J), D(J) && y(Y)) {
            const f = A.pushSplat();
            A.setCenter(f, J.x, J.y, J.z), k = h(k), A.setScale(f, k.x, k.y, k.z), N = w(N), A.setQuaternion(
              f,
              N.x,
              N.y,
              N.z,
              N.w
            ), A.setOpacity(f, Y), A.setColor(f, F.r, F.g, F.b);
          }
        }
        break;
      }
      case rg.PLY: {
        const M = new QI({ fileBytes: r.fileBytes });
        await M.parseHeader();
        let G = null;
        M.parseSplats(
          (J, k, N, Y, F, f, U, L, K, Z, QA, z, AA, $, P) => {
            const j = c(new a.Vector3(k, N, Y));
            if (D(j) && y(z)) {
              G = A.pushSplat(), A.setCenter(G, j.x, j.y, j.z);
              const V = h(
                new a.Vector3(F, f, U)
              );
              A.setScale(G, V.x, V.y, V.z);
              const x = w(
                new a.Quaternion(L, K, Z, QA)
              );
              A.setQuaternion(
                G,
                x.x,
                x.y,
                x.z,
                x.w
              ), A.setOpacity(G, z), A.setColor(G, AA, $, P);
            } else
              G = null;
          },
          (J, k, N, Y) => {
            k && G !== null && A.setSh1(G, k), N && G !== null && A.setSh2(G, N), Y && G !== null && A.setSh3(G, Y);
          }
        );
        break;
      }
      case rg.SPZ: {
        const M = new Qo({ fileBytes: r.fileBytes }), G = new Int32Array(M.numSplats);
        G.fill(-1);
        const J = new Float32Array(M.numSplats * 3), k = new a.Vector3();
        M.parseSplats(
          (N, Y, F, f) => {
            const U = c(new a.Vector3(Y, F, f));
            J[N * 3] = U.x, J[N * 3 + 1] = U.y, J[N * 3 + 2] = U.z;
          },
          (N, Y) => {
            k.fromArray(J, N * 3), D(k) && y(Y) && (G[N] = A.pushSplat(), A.setCenter(G[N], k.x, k.y, k.z), A.setOpacity(G[N], Y));
          },
          (N, Y, F, f) => {
            G[N] >= 0 && A.setColor(G[N], Y, F, f);
          },
          (N, Y, F, f) => {
            if (G[N] >= 0) {
              const U = h(
                new a.Vector3(Y, F, f)
              );
              A.setScale(G[N], U.x, U.y, U.z);
            }
          },
          (N, Y, F, f, U) => {
            if (G[N] >= 0) {
              const L = w(
                new a.Quaternion(Y, F, f, U)
              );
              A.setQuaternion(
                G[N],
                L.x,
                L.y,
                L.z,
                L.w
              );
            }
          },
          (N, Y, F, f) => {
            G[N] >= 0 && (A.setSh1(G[N], Y), F && A.setSh2(G[N], F), f && A.setSh3(G[N], f));
          }
        );
        break;
      }
      case rg.SPLAT:
        go(
          r.fileBytes,
          (M) => {
          },
          (M, G, J, k, N, Y, F, f, U, L, K, Z, QA, z, AA) => {
            const $ = c(new a.Vector3(G, J, k));
            if (D($) && y(Z)) {
              const P = A.pushSplat();
              A.setCenter(P, $.x, $.y, $.z);
              const j = h(
                new a.Vector3(N, Y, F)
              );
              A.setScale(P, j.x, j.y, j.z);
              const V = w(
                new a.Quaternion(f, U, L, K)
              );
              A.setQuaternion(
                P,
                V.x,
                V.y,
                V.z,
                V.w
              ), A.setOpacity(P, Z), A.setColor(P, QA, z, AA);
            }
          }
        );
        break;
      case rg.KSPLAT: {
        let M = null;
        Bo(
          r.fileBytes,
          (G) => {
          },
          (G, J, k, N, Y, F, f, U, L, K, Z, QA, z, AA, $) => {
            const P = c(new a.Vector3(J, k, N));
            if (D(P) && y(QA)) {
              M = A.pushSplat(), A.setCenter(M, P.x, P.y, P.z);
              const j = h(
                new a.Vector3(Y, F, f)
              );
              A.setScale(M, j.x, j.y, j.z);
              const V = w(
                new a.Quaternion(U, L, K, Z)
              );
              A.setQuaternion(
                M,
                V.x,
                V.y,
                V.z,
                V.w
              ), A.setOpacity(M, QA), A.setColor(M, z, AA, $);
            } else
              M = null;
          },
          (G, J, k, N) => {
            M !== null && (A.setSh1(M, J), k && A.setSh2(M, k), N && A.setSh3(M, N));
          }
        );
        break;
      }
      default:
        throw new Error(`transcodeSpz not implemented for ${m}`);
    }
  }
  const t = Math.min(
    Q ?? 3,
    A.sh3 ? 3 : A.sh2 ? 2 : A.sh1 ? 1 : 0
  ), i = new jA({
    numSplats: A.numSplats,
    shDegree: t,
    fractionalBits: C,
    flagAntiAlias: !0
  });
  for (let r = 0; r < A.numSplats; ++r) {
    const c = r * 3, h = r * 4;
    i.setCenter(
      r,
      A.centers[c],
      A.centers[c + 1],
      A.centers[c + 2]
    ), i.setScale(
      r,
      A.scales[c],
      A.scales[c + 1],
      A.scales[c + 2]
    ), i.setQuat(
      r,
      A.quaternions[h],
      A.quaternions[h + 1],
      A.quaternions[h + 2],
      A.quaternions[h + 3]
    ), i.setAlpha(r, A.opacities[r]), i.setRgb(
      r,
      A.colors[c],
      A.colors[c + 1],
      A.colors[c + 2]
    ), A.sh1 && t >= 1 && i.setSh(
      r,
      A.sh1.slice(r * 9, (r + 1) * 9),
      t >= 2 && A.sh2 ? A.sh2.slice(r * 15, (r + 1) * 15) : void 0,
      t >= 3 && A.sh3 ? A.sh3.slice(r * 21, (r + 1) * 21) : void 0
    );
  }
  return { fileBytes: await i.finalize(), clippedCount: i.clippedCount };
}
class vo {
  constructor(A) {
    this.mesh = A.mesh, this.numSplats = A.numSplats ?? this.mesh.numSplats;
    const { width: I, height: B, depth: Q, maxSplats: C } = dA(this.numSplats);
    this.skinData = new Uint16Array(C * 4), this.skinTexture = new a.DataArrayTexture(
      this.skinData,
      I,
      B,
      Q
    ), this.skinTexture.format = a.RGBAIntegerFormat, this.skinTexture.type = a.UnsignedShortType, this.skinTexture.internalFormat = "RGBA16UI", this.skinTexture.needsUpdate = !0, this.numBones = A.numBones ?? 256, this.boneData = new Float32Array(this.numBones * 16), this.boneTexture = new a.DataTexture(
      this.boneData,
      4,
      this.numBones,
      a.RGBAFormat,
      a.FloatType
    ), this.boneTexture.internalFormat = "RGBA32F", this.boneTexture.needsUpdate = !0, this.uniform = new S({
      key: "skinning",
      type: ft,
      globals: () => [St],
      value: {
        numSplats: this.numSplats,
        numBones: this.numBones,
        skinTexture: this.skinTexture,
        boneTexture: this.boneTexture
      }
    });
  }
  // Apply the skeletal animation to a Gsplat in a dyno program.
  modify(A) {
    return so(A, this.uniform);
  }
  // Set the "rest" pose for a bone with position and quaternion orientation.
  setRestQuatPos(A, I, B) {
    const Q = A * 16;
    this.boneData[Q + 0] = I.x, this.boneData[Q + 1] = I.y, this.boneData[Q + 2] = I.z, this.boneData[Q + 3] = I.w, this.boneData[Q + 4] = B.x, this.boneData[Q + 5] = B.y, this.boneData[Q + 6] = B.z, this.boneData[Q + 7] = 0, this.boneData[Q + 8] = 0, this.boneData[Q + 9] = 0, this.boneData[Q + 10] = 0, this.boneData[Q + 11] = 1, this.boneData[Q + 12] = 0, this.boneData[Q + 13] = 0, this.boneData[Q + 14] = 0, this.boneData[Q + 15] = 0;
  }
  // Set the "current" position and orientation of a bone.
  setBoneQuatPos(A, I, B) {
    const Q = A * 16, C = new a.Quaternion(
      this.boneData[Q + 0],
      this.boneData[Q + 1],
      this.boneData[Q + 2],
      this.boneData[Q + 3]
    ), E = new a.Vector3(
      this.boneData[Q + 4],
      this.boneData[Q + 5],
      this.boneData[Q + 6]
    ), t = C.clone().invert(), i = B.clone().sub(E);
    i.applyQuaternion(t), t.multiply(I);
    const e = new a.Quaternion(
      i.x,
      i.y,
      i.z,
      0
    ).multiply(C);
    this.boneData[Q + 8] = t.x, this.boneData[Q + 9] = t.y, this.boneData[Q + 10] = t.z, this.boneData[Q + 11] = t.w, this.boneData[Q + 12] = 0.5 * e.x, this.boneData[Q + 13] = 0.5 * e.y, this.boneData[Q + 14] = 0.5 * e.z, this.boneData[Q + 15] = 0.5 * e.w;
  }
  // Set up to 4 bone indices and weights for a Gsplat. For fewer than 4 bones,
  // you can set the remaining weights to 0 (and index=0).
  setSplatBones(A, I, B) {
    const Q = A * 4;
    this.skinData[Q + 0] = Math.min(255, Math.max(0, Math.round(B.x * 255))) + (I.x << 8), this.skinData[Q + 1] = Math.min(255, Math.max(0, Math.round(B.y * 255))) + (I.y << 8), this.skinData[Q + 2] = Math.min(255, Math.max(0, Math.round(B.z * 255))) + (I.z << 8), this.skinData[Q + 3] = Math.min(255, Math.max(0, Math.round(B.w * 255))) + (I.w << 8);
  }
  // Call this to indicate that the bones have changed and the Gsplats need to be
  // re-generated with updated skinning.
  updateBones() {
    this.boneTexture.needsUpdate = !0, this.mesh.needsUpdate = !0;
  }
}
const ft = { type: "GsplatSkinning" }, St = aA(`
  struct GsplatSkinning {
    int numSplats;
    int numBones;
    usampler2DArray skinTexture;
    sampler2D boneTexture;
  };
`), io = aA(`
  void applyGsplatSkinning(
    int numSplats, int numBones,
    usampler2DArray skinTexture, sampler2D boneTexture,
    int splatIndex, inout vec3 center, inout vec4 quaternion
  ) {
    if ((splatIndex < 0) || (splatIndex >= numSplats)) {
      return;
    }

    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);

    float weights[4];
    weights[0] = float(skinData.x & 0xffu) / 255.0;
    weights[1] = float(skinData.y & 0xffu) / 255.0;
    weights[2] = float(skinData.z & 0xffu) / 255.0;
    weights[3] = float(skinData.w & 0xffu) / 255.0;

    uint boneIndices[4];
    boneIndices[0] = (skinData.x >> 8u) & 0xffu;
    boneIndices[1] = (skinData.y >> 8u) & 0xffu;
    boneIndices[2] = (skinData.z >> 8u) & 0xffu;
    boneIndices[3] = (skinData.w >> 8u) & 0xffu;

    vec4 quat = vec4(0.0);
    vec4 dual = vec4(0.0);
    for (int i = 0; i < 4; i++) {
      if (weights[i] > 0.0) {
        int boneIndex = int(boneIndices[i]);
        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);
        vec4 boneDual = vec4(0.0);
        if (boneIndex < numBones) {
          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);
          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);
        }

        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {
          // Flip sign if next blend is pointing in the opposite direction
          boneQuat = -boneQuat;
          boneDual = -boneDual;
        }
        quat += weights[i] * boneQuat;
        dual += weights[i] * boneDual;
      }
    }

    // Normalize dual quaternion
    float norm = length(quat);
    quat /= norm;
    dual /= norm;
    vec3 translate = vec3(
      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),
      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),
      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)
    );

    center = quatVec(quat, center) + translate;
    quaternion = quatQuat(quat, quaternion);
  }
`);
function so(g, A) {
  return new T({
    inTypes: { gsplat: BA, skinning: ft },
    outTypes: { gsplat: BA },
    globals: () => [St, io],
    inputs: { gsplat: g, skinning: A },
    statements: ({ inputs: B, outputs: Q }) => {
      const { skinning: C } = B, { gsplat: E } = Q;
      return mA(`
        ${E} = ${B.gsplat};
        if (isGsplatActive(${E}.flags)) {
          applyGsplatSkinning(
            ${C}.numSplats, ${C}.numBones,
            ${C}.skinTexture, ${C}.boneTexture,
            ${E}.index, ${E}.center, ${E}.quaternion
          );
        }
      `);
    }
  }).outputs.gsplat;
}
function Wo({
  // PackedSplats object to add splats to
  splats: g,
  // min and max box extents of the grid
  extents: A,
  // step size along each grid axis
  stepSize: I = 1,
  // spherical radius of each Gsplat
  pointRadius: B = 0.01,
  // relative size of the "shadow copy" of each Gsplat placed behind it
  pointShadowScale: Q = 2,
  // Gsplat opacity
  opacity: C = 1,
  // Gsplat color (THREE.Color) or function to set color for position:
  // ((THREE.Color, THREE.Vector3) => void) (default: RGB-modulated grid)
  color: E
}) {
  const i = new a.Vector3(), e = new a.Vector3(), n = new a.Quaternion(0, 0, 0, 1);
  E == null && (E = (o, r) => o.set(
    0.55 + 0.45 * Math.cos(r.x * 1),
    0.55 + 0.45 * Math.cos(r.y * 1),
    0.55 + 0.45 * Math.cos(r.z * 1)
  ));
  const s = new a.Color();
  for (let o = A.min.z; o < A.max.z + 1e-6; o += I)
    for (let r = A.min.y; r < A.max.y + 1e-6; r += I)
      for (let c = A.min.x; c < A.max.x + 1e-6; c += I) {
        i.set(c, r, o);
        for (let h = 0; h < 2; ++h)
          e.setScalar(B * (h ? 1 : Q)), h ? typeof E == "function" ? E(s, i) : s.copy(E) : s.setScalar(0), g.pushSplat(i, e, n, C, s);
      }
}
function Vo({
  // PackedSplats object to add splats to
  splats: g,
  // scale (Gsplat scale along axis)
  scale: A = 0.25,
  // radius of the axes (Gsplat scale orthogonal to axis)
  axisRadius: I = 75e-4,
  // relative size of the "shadow copy" of each Gsplat placed behind it
  axisShadowScale: B = 2,
  // origins of the axes (default single axis at origin)
  origins: Q = [new a.Vector3()]
}) {
  const C = new a.Vector3(), E = new a.Vector3(), t = new a.Quaternion(0, 0, 0, 1), i = new a.Color(), e = 1;
  for (const n of Q)
    for (let s = 0; s < 3; ++s) {
      C.set(
        n.x + (s === 0 ? A : 0),
        n.y + (s === 1 ? A : 0),
        n.z + (s === 2 ? A : 0)
      );
      for (let o = 0; o < 2; ++o)
        E.set(
          (s === 0 ? A : I) * (o ? 1 : B),
          (s === 1 ? A : I) * (o ? 1 : B),
          (s === 2 ? A : I) * (o ? 1 : B)
        ), i.setRGB(
          o === 0 ? 0 : s === 0 ? 1 : 0,
          o === 0 ? 0 : s === 1 ? 1 : 0,
          o === 0 ? 0 : s === 2 ? 1 : 0
        ), g.pushSplat(C, E, t, e, i);
    }
}
function To({
  // PackedSplats object to add splats to
  splats: g,
  // center of the sphere (default: origin)
  origin: A = new a.Vector3(),
  // radius of the sphere
  radius: I = 1,
  // maximum depth of recursion for subdividing the sphere
  // Warning: Gsplat count grows exponentially with depth
  maxDepth: B = 3,
  // filter function to apply to each point, for example to select
  // points in a certain direction or other function ((THREE.Vector3) => boolean)
  // (default: null)
  filter: Q = null,
  // radius of each oriented Gsplat
  pointRadius: C = 0.02,
  // flatness of each oriented Gsplat
  pointThickness: E = 1e-3,
  // color of each Gsplat (THREE.Color) or function to set color for point:
  // ((THREE.Color, THREE.Vector3) => void) (default: white)
  color: t = new a.Color(1, 1, 1)
}) {
  const i = {};
  function e(h) {
    if (Q && !Q(h))
      return;
    const w = `${h.x},${h.y},${h.z}`;
    i[w] || (i[w] = h);
  }
  function n(h, w, D, y) {
    if (e(w), e(D), e(y), h >= B)
      return;
    const l = new a.Vector3().addVectors(w, D).normalize(), d = new a.Vector3().addVectors(D, y).normalize(), u = new a.Vector3().addVectors(y, w).normalize();
    n(h + 1, w, l, u), n(h + 1, l, D, d), n(h + 1, u, d, y), n(h + 1, l, d, u);
  }
  for (const h of [-1, 1])
    for (const w of [-1, 1])
      for (const D of [-1, 1]) {
        const y = new a.Vector3(h, 0, 0), l = new a.Vector3(0, w, 0), d = new a.Vector3(0, 0, D);
        n(0, y, l, d);
      }
  const s = Object.values(i), o = new a.Vector3(C, C, E), r = new a.Quaternion(), c = typeof t == "function" ? new a.Color() : t;
  for (const h of s)
    r.setFromUnitVectors(new a.Vector3(0, 0, -1), h), typeof t == "function" && t(c, h), h.multiplyScalar(I), h.add(A), g.pushSplat(h, o, r, 1, c);
}
function Xo({
  // text string to display
  text: g,
  // browser font to render text with (default: "Arial")
  font: A,
  // font size in pixels/Gsplats (default: 32)
  fontSize: I,
  // SplatMesh.recolor tint assuming white Gsplats (default: white)
  color: B,
  // Individual Gsplat color (default: white)
  rgb: Q,
  // Gsplat radius (default: 0.8 covers 1-unit spacing well)
  dotRadius: C,
  // text alignment: "left", "center", "right", "start", "end" (default: "start")
  textAlign: E,
  // line spacing multiplier, lines delimited by "\n" (default: 1.0)
  lineHeight: t,
  // Coordinate scale in object-space (default: 1.0)
  objectScale: i
}) {
  A = A ?? "Arial", I = I ?? 32, B = B ?? new a.Color(1, 1, 1), C = C ?? 0.8, E = E ?? "start", t = t ?? 1, i = i ?? 1;
  const e = g.split(`
`), n = document.createElement("canvas"), s = n.getContext("2d");
  if (!s)
    throw new Error("Failed to create canvas context");
  s.font = `${I}px ${A}`, s.textAlign = E;
  const o = s.measureText(""), r = o.fontBoundingBoxAscent + o.fontBoundingBoxDescent;
  let c = Number.POSITIVE_INFINITY, h = Number.NEGATIVE_INFINITY, w = Number.POSITIVE_INFINITY, D = Number.NEGATIVE_INFINITY;
  for (let F = 0; F < e.length; ++F) {
    const f = s.measureText(e[F]), U = r * t * F;
    c = Math.min(c, -f.actualBoundingBoxLeft), h = Math.max(h, f.actualBoundingBoxRight), w = Math.min(w, U - f.actualBoundingBoxAscent), D = Math.max(D, U + f.actualBoundingBoxDescent);
  }
  const y = Math.floor(c), l = Math.floor(w), d = Math.ceil(h) - y, u = Math.ceil(D) - l;
  n.width = d, n.height = u, s.font = `${I}px ${A}`, s.textAlign = E, s.textBaseline = "alphabetic", s.fillStyle = "#FFFFFF";
  for (let F = 0; F < e.length; ++F) {
    const f = r * t * F - l;
    s.fillText(e[F], -y, f);
  }
  const p = s.getImageData(0, 0, d, u), m = new Uint8Array(p.data.buffer), M = new ZA(), G = new a.Vector3(), J = new a.Vector3().setScalar(C * i), k = new a.Quaternion(0, 0, 0, 1);
  Q = Q ?? new a.Color(1, 1, 1);
  let N = 0;
  for (let F = 0; F < u; ++F)
    for (let f = 0; f < d; ++f) {
      const U = m[N + 3];
      if (U > 0) {
        const L = U / 255;
        G.set(f - 0.5 * (d - 1), 0.5 * (u - 1) - F, 0), G.multiplyScalar(i), M.pushSplat(G, J, k, L, Q);
      }
      N += 4;
    }
  const Y = new Ag({ packedSplats: M });
  return Y.recolor = B, Y;
}
function zo({
  // URL of the image to convert to splats (example: `url: "./image.png"`)
  url: g,
  // Radius of each Gsplat, default covers 1-unit spacing well (default: 0.8)
  dotRadius: A,
  // Subsampling factor for the image. Higher values reduce resolution,
  // for example 2 will halve the width and height by averaging (default: 1)
  subXY: I,
  // Optional callback function to modify each Gsplat before it's added.
  // Return null to skip adding the Gsplat, or a number to set the opacity
  // and add the Gsplat with parameter values in the objects center, rgba etc. were
  // passed into the forEachSplat callback. Ending the callback in `return opacity;`
  // will retain the original opacity.
  // ((width: number, height: number, index: number, center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion, opacity: number, color: THREE.Color) => number | null)
  forEachSplat: B
}) {
  return A = A ?? 0.8, I = Math.max(1, Math.floor(I ?? 1)), new Ag({
    constructSplats: async (Q) => new Promise((C, E) => {
      const t = new Image();
      t.crossOrigin = "anonymous", t.onerror = E, t.onload = () => {
        const { width: i, height: e } = t, n = document.createElement("canvas");
        n.width = i, n.height = e;
        const s = n.getContext("2d");
        if (!s) {
          E(new Error("Failed to create canvas context"));
          return;
        }
        s.imageSmoothingEnabled = !0, s.imageSmoothingQuality = "high";
        const o = Math.round(i / I), r = Math.round(e / I);
        s.drawImage(t, 0, 0, o, r);
        try {
          const c = s.getImageData(0, 0, o, r), h = new Uint8Array(c.data.buffer), w = new a.Vector3(), D = new a.Vector3().setScalar(A), y = new a.Quaternion(0, 0, 0, 1), l = new a.Color();
          let d = 0;
          for (let u = 0; u < r; ++u)
            for (let p = 0; p < o; ++p) {
              const m = d * 4, M = h[m + 3];
              if (M > 0) {
                let G = M / 255;
                l.set(
                  h[m + 0] / 255,
                  h[m + 1] / 255,
                  h[m + 2] / 255
                ), w.set(
                  p - 0.5 * (o - 1),
                  0.5 * (r - 1) - u,
                  0
                ), D.setScalar(A), y.set(0, 0, 0, 1);
                let J = !0;
                if (B) {
                  const k = B(
                    o,
                    r,
                    d,
                    w,
                    D,
                    y,
                    G,
                    l
                  );
                  G = k ?? G, J = k !== null;
                }
                J && Q.pushSplat(w, D, y, G, l);
              }
              d += 1;
            }
          C();
        } catch (c) {
          E(c);
        }
      }, t.src = g;
    })
  });
}
function eo({
  box: g,
  cells: A,
  dotScale: I,
  color: B,
  opacity: Q
}) {
  A.x = Math.max(1, Math.round(A.x)), A.y = Math.max(1, Math.round(A.y)), A.z = Math.max(1, Math.round(A.z)), Q = Q ?? 1;
  const C = A.x * A.y * A.z, E = gA("int", A.x), t = gA("int", A.y);
  gA("int", A.z);
  const i = bA(0), e = new nI({
    numSplats: C,
    generator: YA(
      { index: "int" },
      { gsplat: BA },
      ({ index: s }) => {
        if (!s)
          throw new Error("index is undefined");
        const o = mI(s, E), r = Og(s, E), c = mI(r, t), h = Og(r, t), w = KA({
          vectorType: "ivec3",
          x: o,
          y: c,
          z: h
        }), D = fC(i), y = KA({ vectorType: "ivec2", x: s, y: D }), l = UE(y), d = gA("vec3", g.min), u = gA("vec3", g.max), p = Sg(u, d), m = Og(NA(tg(w), l), gA("vec3", A));
        let M, G, J;
        B ? (M = gA("float", B.r), G = gA("float", B.g), J = gA("float", B.b)) : { r: M, g: G, b: J } = Rg(m).outputs;
        const k = KA({
          vectorType: "vec4",
          r: M,
          g: G,
          b: J,
          a: gA("float", Q)
        }), N = NA(d, rA(p, m)), Y = tg(gA("float", I)), F = gA("vec4", new a.Quaternion(0, 0, 0, 1));
        let f = lg({
          flags: _g("uint", "GSPLAT_FLAG_ACTIVE"),
          index: s,
          center: N,
          scales: Y,
          quaternion: F,
          rgba: k
        });
        return f = n.applyGsplat(f), { gsplat: f };
      },
      {
        globals: () => [pA]
      }
    ),
    update: ({ time: s }) => {
      i.value = s, n.update(e), e.updateVersion();
    }
  }), n = new hg();
  return e;
}
const ao = {
  box: new a.Box3(
    new a.Vector3(-1, -1, -1),
    new a.Vector3(1, 1, 1)
  ),
  density: 100,
  fallDirection: new a.Vector3(-1, -3, 1).normalize(),
  fallVelocity: 0.02,
  wanderScale: 0.04,
  wanderVariance: 2,
  color1: new a.Color(1, 1, 1),
  color2: new a.Color(0.5, 0.5, 1),
  minScale: 1e-3,
  maxScale: 5e-3,
  anisoScale: new a.Vector3(1, 1, 1)
}, no = {
  box: new a.Box3(
    new a.Vector3(-2, -1, -2),
    new a.Vector3(2, 5, 2)
  ),
  density: 10,
  fallDirection: new a.Vector3(0, -1, 0),
  fallVelocity: 2,
  wanderScale: 0.1,
  wanderVariance: 1,
  color1: new a.Color(1, 1, 1),
  color2: new a.Color(0.25, 0.25, 0.5),
  minScale: 5e-3,
  maxScale: 0.01,
  anisoScale: new a.Vector3(0.1, 1, 0.1)
};
function oo({
  // min and max box extents of the snowBox
  box: g,
  // minimum y-coordinate to clamp particle position, which can be used to
  // fake hitting a ground plane and lingering there for a bit
  minY: A,
  // number of Gsplats to generate (default: calculated from box and density)
  numSplats: I,
  // density of Gsplats per unit volume (default: 100)
  density: B,
  // The xyz anisotropic scale of the Gsplat, which can be used for example
  // to elongate rain particles (default: (1, 1, 1))
  anisoScale: Q,
  // Minimum Gsplat particle scale (default: 0.001)
  minScale: C,
  // Maximum Gsplat particle scale (default: 0.005)
  maxScale: E,
  // The average direction of fall (default: (0, -1, 0))
  fallDirection: t,
  // The average speed of the fall (multiplied with fallDirection) (default: 0.02)
  fallVelocity: i,
  // The world scale of wandering overlay motion (default: 0.01)
  wanderScale: e,
  // Controls how uniformly the particles wander in sync, more variance mean
  // more randomness in the motion (default: 2)
  wanderVariance: n,
  // Color 1 of the two colors interpolated between (default: (1, 1, 1))
  color1: s,
  // Color 2 of the two colors interpolated between (default: (0.5, 0.5, 1))
  color2: o,
  // The base opacity of the Gsplats (default: 1)
  opacity: r,
  // Optional callback function to call each frame.
  onFrame: c
}) {
  g = g ?? new a.Box3(new a.Vector3(-1, -1, -1), new a.Vector3(1, 1, 1));
  const h = (g.max.x - g.min.x) * (g.max.y - g.min.y) * (g.max.z - g.min.z);
  B = B ?? 100, I = I ?? Math.max(1, Math.min(1e6, Math.round(h * B)));
  const w = bA(C ?? 1e-3), D = bA(E ?? 5e-3), y = zA(
    ((Q == null ? void 0 : Q.clone()) ?? new a.Vector3(1, 1, 1)).normalize()
  ), l = zA(
    (t ?? new a.Vector3(0, -1, 0)).normalize()
  ), d = bA(i ?? 0.02), u = bA(e ?? 0.01), p = bA(n ?? 2), m = zA(s ?? new a.Color(1, 1, 1)), M = zA(o ?? new a.Color(0.5, 0.5, 1)), G = bA(r ?? 1), J = bA(0), k = zA(new a.Vector3(0, 0, 0)), N = zA(g.min), Y = zA(g.max), F = bA(A ?? Number.NEGATIVE_INFINITY), f = Sg(Y, N), U = new nI({
    numSplats: I,
    generator: YA(
      { index: "int" },
      { gsplat: BA },
      ({ index: K }) => {
        if (!K)
          throw new Error("index not defined");
        const Z = fI(K), QA = Rg(Z).outputs.w;
        let z = tg(Z), AA = Pg(rA(QA, gA("float", 100)));
        AA = SI(rA(_g("float", "PI"), AA)), AA = NA(w, rA(AA, Sg(D, w)));
        const $ = rA(AA, y), P = Pg(rA(QA, gA("float", 10))), j = Pg(QA), V = xQ(m, M, j), x = rA(V, P), uA = fI(
          KA({
            vectorType: "ivec2",
            x: K,
            y: gA("int", 6837)
          })
        );
        let iA = tg(uA), b = rA(Rg(uA).outputs.w, p);
        b = NA(J, b), z = NA(z, k);
        const nA = YQ(
          z,
          gA("vec3", new a.Vector3(1, 1, 1))
        );
        z = NA(N, rA(f, nA));
        const oA = gA("vec4", new a.Quaternion(0, 0, 0, 1));
        iA = SI(NA(tg(b), iA)), iA = rA(iA, u);
        let H = NA(z, iA), kA = Rg(H).outputs.y;
        kA = UQ(F, kA), H = KA({ vector: H, y: kA });
        let GA = lg({
          flags: _g("uint", "GSPLAT_FLAG_ACTIVE"),
          index: K,
          center: H,
          scales: $,
          quaternion: oA,
          rgb: x,
          opacity: G
        });
        return GA = L.applyGsplat(GA), { gsplat: GA };
      },
      {
        globals: () => [pA]
      }
    ),
    update: ({ object: K, time: Z, deltaTime: QA }) => {
      J.value = Z, L.update(U);
      const z = l.value.clone().multiplyScalar(d.value * QA);
      k.value.add(z), K.visible = G.value > 0, c == null || c({ object: K, time: Z, deltaTime: QA }), U.updateVersion();
    }
  }), L = new hg();
  return {
    snow: U,
    min: N,
    max: Y,
    minY: F,
    color1: m,
    color2: M,
    opacity: G,
    fallVelocity: d,
    wanderVariance: p,
    wanderScale: u,
    fallDirection: l,
    minScale: w,
    maxScale: D,
    anisoScale: y
  };
}
const jo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEFAULT_RAIN: no,
  DEFAULT_SNOW: ao,
  snowBox: oo,
  staticBox: eo
}, Symbol.toStringTag, { value: "Module" })), Jg = class Jg {
  static createButton(A, I = {}) {
    const B = navigator.xr;
    if (!B)
      return null;
    const Q = B, C = document.createElement("button");
    A.xr.enabled = !0, A.xr.setReferenceSpaceType("local");
    function E() {
      let s = null;
      async function o(h) {
        console.log("onSessionStarted"), h.addEventListener("end", r), await A.xr.setSession(h), C.textContent = "EXIT VR", s = h;
      }
      function r() {
        console.log("onSessionEnded"), s == null || s.removeEventListener("end", r), C.textContent = "ENTER VR", s = null;
      }
      C.style.display = "", C.style.cursor = "pointer", C.style.left = "calc(50% - 100px)", C.style.width = "200px", C.style.height = "100px", C.textContent = "ENTER VR";
      const c = {
        ...I,
        optionalFeatures: [
          // "local-floor",
          // "bounded-floor",
          // "layers",
          ...I.optionalFeatures || []
        ]
      };
      C.onmouseenter = () => {
        C.style.opacity = "1.0";
      }, C.onmouseleave = () => {
        C.style.opacity = "0.5";
      }, C.onclick = () => {
        s === null ? (console.log("requesting session"), Q.requestSession("immersive-vr", c).then(
          o
        )) : (console.log("ending session"), s.end());
      };
    }
    function t() {
      C.style.display = "none", C.style.cursor = "auto", C.style.left = "calc(50% - 75px)", C.style.width = "150px", C.onmouseenter = null, C.onmouseleave = null, C.onclick = null;
    }
    function i() {
      t(), C.textContent = "VR NOT SUPPORTED";
    }
    function e(s) {
      t(), console.warn(
        "Exception when trying to call xr.isSessionSupported",
        s
      ), C.textContent = "VR NOT ALLOWED";
    }
    function n(s) {
      s.style.position = "absolute", s.style.bottom = "20px", s.style.padding = "12px 6px", s.style.border = "1px solid #fff", s.style.borderRadius = "4px", s.style.background = "rgba(0,0,0,0.1)", s.style.color = "#fff", s.style.font = "normal 13px sans-serif", s.style.textAlign = "center", s.style.opacity = "0.5", s.style.outline = "none", s.style.zIndex = "999";
    }
    return C.id = "VRButton", C.style.display = "none", n(C), Q.isSessionSupported("immersive-vr").then((s) => {
      s ? E() : i(), s && Jg.xrSessionIsGranted && C.click();
    }).catch(e), C;
  }
  static registerSessionGrantedListener() {
    const A = navigator.xr;
    if (!A)
      return null;
    const I = A;
    /WebXRViewer\//i.test(navigator.userAgent) || I.addEventListener("sessiongranted", () => {
      Jg.xrSessionIsGranted = !0;
    });
  }
};
Jg.xrSessionIsGranted = !1;
let bI = Jg;
bI.registerSessionGrantedListener();
const ro = 0.5, co = 0.5, ho = 0;
var jI = /* @__PURE__ */ ((g) => (g.w = "wrist", g.t0 = "thumb-metacarpal", g.t1 = "thumb-phalanx-proximal", g.t2 = "thumb-phalanx-distal", g.t3 = "thumb-tip", g.i0 = "index-finger-metacarpal", g.i1 = "index-finger-phalanx-proximal", g.i2 = "index-finger-phalanx-intermediate", g.i3 = "index-finger-phalanx-distal", g.i4 = "index-finger-tip", g.m0 = "middle-finger-metacarpal", g.m1 = "middle-finger-phalanx-proximal", g.m2 = "middle-finger-phalanx-intermediate", g.m3 = "middle-finger-phalanx-distal", g.m4 = "middle-finger-tip", g.r0 = "ring-finger-metacarpal", g.r1 = "ring-finger-phalanx-proximal", g.r2 = "ring-finger-phalanx-intermediate", g.r3 = "ring-finger-phalanx-distal", g.r4 = "ring-finger-tip", g.p0 = "pinky-finger-metacarpal", g.p1 = "pinky-finger-phalanx-proximal", g.p2 = "pinky-finger-phalanx-intermediate", g.p3 = "pinky-finger-phalanx-distal", g.p4 = "pinky-finger-tip", g))(jI || {});
const Yt = Object.keys(jI), Oo = Yt.length, Po = {
  w: 0,
  t0: 1,
  t1: 2,
  t2: 3,
  t3: 4,
  i0: 5,
  i1: 6,
  i2: 7,
  i3: 8,
  i4: 9,
  m0: 10,
  m1: 11,
  m2: 12,
  m3: 13,
  m4: 14,
  r0: 15,
  r1: 16,
  r2: 17,
  r3: 18,
  r4: 19,
  p0: 20,
  p1: 21,
  p2: 22,
  p3: 23,
  p4: 24
}, Vg = {
  w: 0.02,
  t0: 0.02,
  t1: 0.014,
  t2: 0.0115,
  t3: 85e-4,
  i0: 0.022,
  i1: 0.012,
  i2: 85e-4,
  i3: 75e-4,
  i4: 65e-4,
  m0: 0.021,
  m1: 0.012,
  m2: 8e-3,
  m3: 75e-4,
  m4: 65e-4,
  r0: 0.019,
  r1: 0.011,
  r2: 75e-4,
  r3: 7e-3,
  r4: 6e-3,
  p0: 0.012,
  p1: 0.01,
  p2: 7e-3,
  p3: 65e-4,
  p4: 55e-4
}, wo = [
  ["w", "t0", "t1", "t2", "t3"],
  ["w", "i0", "i1", "i2", "i3", "i4"],
  ["w", "m0", "m1", "m2", "m3", "m4"],
  ["w", "r0", "r1", "r2", "r3", "r4"],
  ["w", "p0", "p1", "p2", "p3", "p4"]
], Do = [
  [8, 10, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6]
], _o = ["t3", "i4", "m4", "r4", "p4"], $o = ["i4", "m4", "r4", "p4"];
var Ut = /* @__PURE__ */ ((g) => (g.left = "left", g.right = "right", g))(Ut || {});
const HI = Object.keys(Ut);
class Ar {
  constructor() {
    this.hands = {}, this.last = {}, this.values = {}, this.tests = {}, this.lastTests = {}, this.updated = !1;
  }
  update({ xr: A, xrFrame: I }) {
    const B = A.getSession();
    if (!B)
      return;
    const Q = A.getReferenceSpace();
    if (Q && I.getJointPose) {
      this.last = this.hands, this.lastTests = this.tests, this.hands = {}, this.values = {}, this.tests = {};
      for (const C of B.inputSources) {
        if (!C.hand)
          continue;
        const E = C.handedness;
        this.hands[E] = {};
        for (const t of Yt) {
          const i = C.hand.get(jI[t]);
          if (i) {
            const e = I.getJointPose(i, Q);
            if (e) {
              const { position: n, orientation: s } = e.transform;
              this.hands[E][t] = {
                position: new SA(n.x, n.y, n.z),
                quaternion: new OI(
                  s.x,
                  s.y,
                  s.z,
                  s.w
                ),
                radius: e.radius || 1e-3
              };
            }
          }
        }
      }
      for (const C of HI)
        for (const { key: E, value: t } of [
          { key: `${C}AllTips`, value: this.allTipsTouching(C) },
          {
            key: `${C}IndexThumb`,
            value: this.touching(C, "i4", C, "t3")
          },
          {
            key: `${C}MiddleThumb`,
            value: this.touching(C, "m4", C, "t3")
          },
          {
            key: `${C}RingThumb`,
            value: this.touching(C, "r4", C, "t3")
          },
          {
            key: `${C}PinkyThumb`,
            value: this.touching(C, "p4", C, "t3")
          },
          { key: `${C}TriTips`, value: this.triTipsTouching(C) }
        ])
          this.values[E] = t, this.tests[E] = t === 1 ? !0 : t === 0 ? !1 : this.lastTests[E] ?? !1;
    }
  }
  makeGhostMesh() {
    const A = new SA(), I = new SA(0.01, 0.01, 0.01), B = new OI(0, 0, 0, 1), Q = new PI(1, 1, 1), C = Math.PI * 3, E = new PI(1, 1, 1);
    let t = 1;
    const i = new Ag({
      onFrame: () => {
        let e = 0;
        for (const n of HI) {
          const s = this.values[`${n}MiddleThumb`], o = this.hands[n];
          for (const [r, c] of wo.entries())
            for (let h = 1; h < c.length; ++h) {
              const w = Do[r][h - 1] * 2, D = h + 1 === c.length, y = o == null ? void 0 : o[c[h - 1]], l = o == null ? void 0 : o[c[h]];
              for (let d = 0; d < w; ++d) {
                const u = (d + 0.5) / w;
                if (t = 0, y && l) {
                  A.copy(y.position).lerp(l.position, u), B.copy(y.quaternion).slerp(l.quaternion, u);
                  const p = Vg[c[h - 1]], m = Vg[c[h]];
                  let M = (1 - u) * p + u * m;
                  D && u > 0.8 && (M *= Math.sqrt(1 - ((u - 0.8) / 0.2) ** 2)), I.set(0.65 * M, 0.5 * M, 3e-3), Q.set(
                    0.55 + 0.45 * Math.sin(A.x * C),
                    0.55 + 0.45 * Math.sin(A.y * C),
                    0.55 + 0.45 * Math.sin(A.z * C)
                  ), n === "right" && Q.set(1 - Q.r, 1 - Q.g, 1 - Q.b), Q.lerp(E, s), t = 0.75;
                }
                i.packedSplats.setSplat(
                  e,
                  A,
                  I,
                  B,
                  t,
                  Q
                ), e += 1;
              }
            }
        }
        i.packedSplats.numSplats = e, i.packedSplats.needsUpdate = !0, i.numSplats = e;
      }
    });
    return i;
  }
  distance(A, I, B, Q, C = !1) {
    const E = C ? this.last[A] : this.hands[A], t = C ? this.last[B] : this.hands[B], i = E == null ? void 0 : E[I], e = t == null ? void 0 : t[Q];
    return !i || !e ? Number.POSITIVE_INFINITY : i.position.distanceTo(e.position);
  }
  separation(A, I, B, Q, C = !1) {
    const E = this.distance(A, I, B, Q, C);
    return E === Number.POSITIVE_INFINITY ? Number.POSITIVE_INFINITY : E - Vg[I] - Vg[Q];
  }
  touching(A, I, B, Q, C = !1) {
    const E = this.separation(A, I, B, Q, C);
    return E === Number.POSITIVE_INFINITY ? Number.POSITIVE_INFINITY : 1 - Math.max(0, Math.min(1, E / 0.01 - ho));
  }
  allTipsTouching(A, I = !1) {
    return Math.min(
      this.touching(A, "t3", A, "i4", I),
      this.touching(A, "i4", A, "m4", I),
      this.touching(A, "m4", A, "r4", I),
      this.touching(A, "r4", A, "p4", I)
      // this.touching(hand, "p4", hand, "t3", last),
    );
  }
  triTipsTouching(A, I = !1) {
    return Math.min(
      this.touching(A, "t3", A, "i4", I),
      this.touching(A, "i4", A, "m4", I),
      this.touching(A, "m4", A, "t3", I)
    );
  }
}
class gr {
  constructor({
    xrHands: A,
    control: I,
    moveInertia: B,
    rotateInertia: Q
  }) {
    this.lastGrip = {}, this.lastPivot = new SA(), this.rotateVelocity = 0, this.velocity = new SA(), this.xrHands = A, this.control = I, this.moveInertia = B ?? ro, this.rotateInertia = Q ?? co;
  }
  update(A) {
    var C, E, t, i, e;
    const I = {};
    for (const n of HI) {
      const s = this.xrHands.hands[n];
      s && this.xrHands.tests[`${n}MiddleThumb`] && (I[n] = new SA().add(((C = s.t3) == null ? void 0 : C.position) ?? new SA()).add(((E = s.i4) == null ? void 0 : E.position) ?? new SA()).add(((t = s.m4) == null ? void 0 : t.position) ?? new SA()).add(((i = s.r4) == null ? void 0 : i.position) ?? new SA()).add(((e = s.p4) == null ? void 0 : e.position) ?? new SA()).multiplyScalar(1 / 5));
    }
    if (I.left && I.right && this.lastGrip.left && this.lastGrip.right) {
      const n = I.left.clone().add(I.right).multiplyScalar(0.5), s = this.lastGrip.left.clone().add(this.lastGrip.right).multiplyScalar(0.5);
      this.lastPivot = n;
      const o = n.clone().applyMatrix4(this.control.matrix);
      o.sub(s.clone().applyMatrix4(this.control.matrix)), o.multiplyScalar(1 / A), this.velocity.lerp(o, 1 - Math.exp(-20 * A));
      const r = Math.atan2(I.left.z - n.z, I.left.x - n.x), c = Math.atan2(
        this.lastGrip.left.z - s.z,
        this.lastGrip.left.x - s.x
      );
      let h = r - c;
      h > Math.PI ? h -= Math.PI * 2 : h < -Math.PI && (h += Math.PI * 2);
      const w = h / A, D = Math.exp(-20 * A);
      this.rotateVelocity = this.rotateVelocity * D + w * (1 - D);
    } else if (this.rotateVelocity *= Math.exp(-A / this.rotateInertia), I.left && this.lastGrip.left) {
      const n = I.left.clone().applyMatrix4(this.control.matrix);
      n.sub(this.lastGrip.left.clone().applyMatrix4(this.control.matrix)), n.multiplyScalar(1 / A), this.velocity.lerp(n, 1 - Math.exp(-20 * A));
    } else if (I.right && this.lastGrip.right) {
      const n = I.right.clone().applyMatrix4(this.control.matrix);
      n.sub(
        this.lastGrip.right.clone().applyMatrix4(this.control.matrix)
      ), n.multiplyScalar(1 / A), this.velocity.lerp(n, 1 - Math.exp(-20 * A));
    } else
      this.velocity.multiplyScalar(Math.exp(-A / this.moveInertia));
    const B = this.lastPivot.clone().negate(), Q = new uI().makeTranslation(B).premultiply(new uI().makeRotationY(this.rotateVelocity * A)).premultiply(new uI().makeTranslation(this.lastPivot));
    this.control.matrix.multiply(Q), this.control.matrix.decompose(
      this.control.position,
      this.control.quaternion,
      this.control.scale
    ), this.control.updateMatrixWorld(!0), this.control.position.sub(this.velocity.clone().multiplyScalar(A)), this.lastGrip = I;
  }
}
const lo = 1, yo = 2, uo = 2e-3, Go = 6e-3, Mo = 15e-4, No = 0.15, po = 0.15, ko = 0.1, Fo = 2, Ro = 200, Jo = 400, mo = 50, fo = {
  KeyW: new a.Vector3(0, 0, -1),
  KeyS: new a.Vector3(0, 0, 1),
  KeyA: new a.Vector3(-1, 0, 0),
  KeyD: new a.Vector3(1, 0, 0),
  KeyR: new a.Vector3(0, 1, 0),
  KeyF: new a.Vector3(0, -1, 0)
}, So = {
  ArrowUp: new a.Vector3(0, 0, -1),
  ArrowDown: new a.Vector3(0, 0, 1),
  ArrowLeft: new a.Vector3(-1, 0, 0),
  ArrowRight: new a.Vector3(1, 0, 0),
  PageUp: new a.Vector3(0, 1, 0),
  PageDown: new a.Vector3(0, -1, 0)
}, Yo = {
  KeyQ: new a.Vector3(0, 0, 1),
  KeyE: new a.Vector3(0, 0, -1)
}, Uo = {
  Home: new a.Vector3(0, -1, 0),
  End: new a.Vector3(0, 1, 0),
  Insert: new a.Vector3(-1, 0, 0),
  Delete: new a.Vector3(1, 0, 0)
};
class Ir {
  constructor({ canvas: A }) {
    this.lastTime = 0, this.fpsMovement = new xo({}), this.pointerControls = new Lo({ canvas: A });
  }
  update(A) {
    const I = performance.now(), B = (I - (this.lastTime || I)) / 1e3;
    this.lastTime = I, this.fpsMovement.update(B, A), this.pointerControls.update(B, A);
  }
}
class xo {
  constructor({
    moveSpeed: A,
    rollSpeed: I,
    stickThreshold: B,
    rotateSpeed: Q,
    keycodeMoveMapping: C,
    keycodeRotateMapping: E,
    gamepadMapping: t,
    capsMultiplier: i,
    shiftMultiplier: e,
    ctrlMultiplier: n,
    xr: s
  } = {}) {
    this.enable = !0, this.moveSpeed = A ?? lo, this.rollSpeed = I ?? yo, this.stickThreshold = B ?? ko, this.rotateSpeed = Q ?? Fo, this.keycodeMoveMapping = C ?? {
      ...fo,
      ...So
    }, this.keycodeRotateMapping = E ?? {
      ...Yo,
      ...Uo
    }, this.gamepadMapping = t ?? {
      4: "rollLeft",
      5: "rollRight",
      6: "ctrl",
      7: "shift"
    }, this.capsMultiplier = i ?? 10, this.shiftMultiplier = e ?? 5, this.ctrlMultiplier = n ?? 1 / 5, this.xr = s, this.keydown = {}, this.keycode = {}, document.addEventListener("keydown", (o) => {
      this.keydown[o.key] = !0, this.keycode[o.code] = !0;
    }), document.addEventListener("keyup", (o) => {
      this.keydown[o.key] = !1, this.keycode[o.code] = !1;
    });
  }
  // Call this method in your render loop with `control` set to the object to control
  // (`THREE.Camera` or a `THREE.Object3D` that contains it), with `deltaTime`
  // in seconds since the last update.
  update(A, I) {
    var n, s;
    if (!this.enable)
      return;
    const B = [new a.Vector2(), new a.Vector2()], Q = navigator.getGamepads()[0];
    Q && (B[0].set(Q.axes[0], Q.axes[1]), B[1].set(Q.axes[2], Q.axes[3]));
    const C = (Q == null ? void 0 : Q.buttons.map((o) => o.pressed)) || [], E = Array.from(((s = (n = this.xr) == null ? void 0 : n.getSession()) == null ? void 0 : s.inputSources) ?? []);
    for (const o of E) {
      const r = o.gamepad;
      if (r)
        switch (o.handedness) {
          case "none": {
            B[0].x += r.axes[0], B[0].y += r.axes[1], B[1].x += r.axes[2], B[1].y += r.axes[3];
            break;
          }
          case "left": {
            B[0].x += r.axes[2], B[0].y += r.axes[3];
            break;
          }
          case "right": {
            B[1].x += r.axes[2], B[1].y += r.axes[3];
            break;
          }
        }
    }
    for (const o of B)
      o.x = Math.abs(o.x) >= this.stickThreshold ? o.x : 0, o.y = Math.abs(o.y) >= this.stickThreshold ? o.y : 0;
    const t = new a.Vector3(
      B[1].x,
      B[1].y,
      0
    ).multiplyScalar(this.rotateSpeed);
    for (const [o, r] of Object.entries(this.keycodeRotateMapping))
      this.keycode[o] && t.add(r);
    for (const o in this.gamepadMapping)
      if (C[Number.parseInt(o)])
        switch (this.gamepadMapping[o]) {
          case "rollLeft":
            t.z += 1;
            break;
          case "rollRight":
            t.z -= 1;
            break;
        }
    if (t.multiply(
      new a.Vector3(this.rotateSpeed, this.rotateSpeed, this.rollSpeed)
    ), t.manhattanLength() > 0) {
      t.multiplyScalar(A);
      const o = new a.Euler().setFromQuaternion(
        I.quaternion,
        "YXZ"
      );
      o.y -= t.x, o.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, o.x - t.y)
      ), o.z = Math.max(-Math.PI, Math.min(Math.PI, o.z + t.z)), I.quaternion.setFromEuler(o);
    }
    const i = new a.Vector3(B[0].x, 0, B[0].y);
    for (const [o, r] of Object.entries(this.keycodeMoveMapping))
      this.keycode[o] && i.add(r);
    let e = 1;
    this.keydown.CapsLock && (e *= this.capsMultiplier), (this.keycode.ShiftLeft || this.keycode.ShiftRight) && (e *= this.shiftMultiplier), (this.keycode.ControlLeft || this.keycode.ControlRight) && (e *= this.ctrlMultiplier);
    for (const o in this.gamepadMapping)
      if (C[Number.parseInt(o)])
        switch (this.gamepadMapping[o]) {
          case "shift":
            e *= this.shiftMultiplier;
            break;
          case "ctrl":
            e *= this.ctrlMultiplier;
            break;
        }
    i.applyQuaternion(I.quaternion), I.position.add(
      i.multiplyScalar(this.moveSpeed * e * A)
    );
  }
}
class Lo {
  constructor({
    // The HTML canvas element to attach pointer events to
    canvas: A,
    // Speed of rotation (default DEFAULT_ROTATE_SPEED)
    rotateSpeed: I,
    // Speed of sliding when dragging with right/middle mouse button or two fingers
    // (default DEFAULT_SLIDE_SPEED)
    slideSpeed: B,
    // Speed of movement when using mouse scroll wheel (default DEFAULT_SCROLL_SPEED)
    scrollSpeed: Q,
    // Swap the direction of rotation and sliding (default: false)
    swapRotateSlide: C,
    // Reverse the direction of rotation (default: false)
    reverseRotate: E,
    // Reverse the direction of sliding (default: false)
    reverseSlide: t,
    // Reverse the direction of swipe gestures (default: false)
    reverseSwipe: i,
    // Reverse the direction of scroll wheel movement (default: false)
    reverseScroll: e,
    // Inertia factor for movement (default: DEFAULT_MOVE_INERTIA)
    moveInertia: n,
    // Inertia factor for rotation (default: DEFAULT_ROTATE_INERTIA)
    rotateInertia: s,
    // Callback for double press events (default: () => {})
    doublePress: o
  }) {
    this.enable = !0, this.canvas = A, this.rotateSpeed = I ?? uo, this.slideSpeed = B ?? Go, this.scrollSpeed = Q ?? Mo, this.swapRotateSlide = C ?? !1, this.reverseRotate = E ?? !1, this.reverseSlide = t ?? !1, this.reverseSwipe = i ?? !1, this.reverseScroll = e ?? !1, this.moveInertia = n ?? po, this.rotateInertia = s ?? No, this.doublePress = o ?? (() => {
    }), this.doublePressLimitMs = Jo, this.doublePressDistance = mo, this.lastUp = null, this.rotating = null, this.sliding = null, this.dualPress = !1, this.scroll = new a.Vector3(), this.rotateVelocity = new a.Vector3(), this.moveVelocity = new a.Vector3(), A.addEventListener("pointerdown", (c) => {
      const h = this.getPointerPosition(c), w = h.clone(), D = h.clone(), y = !this.swapRotateSlide && !this.rotating && (c.pointerType !== "mouse" || c.button === 0) || this.swapRotateSlide && this.sliding && !this.rotating && (c.pointerType !== "mouse" || c.button === 1), { pointerId: l, timeStamp: d } = c;
      if (y)
        this.rotating = { initial: w, last: D, position: h, pointerId: l, timeStamp: d }, A.setPointerCapture(c.pointerId), this.dualPress = !1;
      else if (!this.sliding) {
        const u = c.pointerType === "mouse" ? c.button : void 0;
        this.sliding = {
          initial: w,
          last: D,
          position: h,
          pointerId: l,
          button: u,
          timeStamp: d
        }, A.setPointerCapture(c.pointerId), this.dualPress = this.rotating != null && d - this.rotating.timeStamp < Ro;
      }
    });
    const r = (c) => {
      var D, y;
      ((D = this.rotating) == null ? void 0 : D.pointerId) === c.pointerId ? (this.rotating = null, A.releasePointerCapture(c.pointerId), this.dualPress && this.sliding && (A.releasePointerCapture(this.sliding.pointerId), this.sliding = null)) : ((y = this.sliding) == null ? void 0 : y.pointerId) === c.pointerId && (this.sliding = null, A.releasePointerCapture(c.pointerId), this.dualPress && this.rotating && (A.releasePointerCapture(this.rotating.pointerId), this.rotating = null));
      const h = this.getPointerPosition(c), w = this.lastUp;
      if (this.lastUp = { position: h, time: c.timeStamp }, w && w.position.distanceTo(h) < this.doublePressDistance) {
        const d = c.timeStamp - w.time;
        d < this.doublePressLimitMs && (this.lastUp = null, this.doublePress({ position: h, intervalMs: d }));
      }
    };
    document.addEventListener("pointerup", r), document.addEventListener("pointercancel", r), document.addEventListener("pointermove", (c) => {
      var h, w;
      ((h = this.rotating) == null ? void 0 : h.pointerId) === c.pointerId ? this.rotating.position = this.getPointerPosition(c) : ((w = this.sliding) == null ? void 0 : w.pointerId) === c.pointerId && (this.sliding.position = this.getPointerPosition(c));
    }), A.addEventListener("contextmenu", (c) => {
      c.preventDefault();
    }), A.addEventListener("wheel", (c) => {
      this.scroll.add(
        new a.Vector3(c.deltaX, c.deltaY, c.deltaZ)
      ), c.preventDefault();
    });
  }
  getPointerPosition(A) {
    const I = this.canvas.getBoundingClientRect();
    return new a.Vector2(
      A.clientX - I.left,
      A.clientY - I.top
    );
  }
  update(A, I) {
    if (!this.enable)
      return;
    if (this.dualPress && this.rotating && this.sliding) {
      const Q = [
        this.rotating.position.clone().sub(this.rotating.last),
        this.sliding.position.clone().sub(this.sliding.last)
      ], C = Q[0].dot(Q[1]);
      if (C >= 0.2) {
        const E = Q[0].clone().add(Q[1]), t = new a.Vector3(E.x, -E.y, 0);
        t.multiplyScalar(this.slideSpeed * (this.reverseSwipe ? 1 : -1)), t.applyQuaternion(I.quaternion), I.position.add(t), this.moveVelocity = t.clone().multiplyScalar(1 / A);
      } else if (C <= -0.2) {
        const E = this.sliding.last.clone().sub(this.rotating.last), t = E.length();
        E.multiplyScalar(1 / t).normalize();
        const i = new a.Vector2(-E.y, E.x), e = [Q[0].dot(E), Q[1].dot(E)], n = [Q[0].dot(i), Q[1].dot(i)], s = this.rotating.last.clone().add(this.sliding.last).multiplyScalar(0.5);
        let o = new a.Vector3();
        if (I instanceof a.Camera) {
          const y = new a.Vector2(
            s.x / this.canvas.clientWidth * 2 - 1,
            -(s.y / this.canvas.clientHeight) * 2 + 1
          ), l = new a.Raycaster();
          l.setFromCamera(y, I), o = l.ray.direction;
        }
        const r = e[1] - e[0], c = o.multiplyScalar(r * this.slideSpeed);
        I.position.add(c), this.moveVelocity = c.clone().multiplyScalar(1 / A);
        const h = [
          Math.atan(n[0] / (-0.5 * t)),
          Math.atan(n[1] / (0.5 * t))
        ], w = 0.5 * (h[0] + h[1]), D = new a.Euler().setFromQuaternion(
          I.quaternion,
          "YXZ"
        );
        D.z = Math.max(
          -Math.PI,
          Math.min(Math.PI, D.z + 0.5 * w)
        ), I.quaternion.setFromEuler(D);
      }
      this.rotating.last.copy(this.rotating.position), this.sliding.last.copy(this.sliding.position);
    } else {
      const Q = new a.Vector3();
      if (this.rotating && !this.dualPress) {
        const E = this.rotating.position.clone().sub(this.rotating.last);
        this.rotating.last.copy(this.rotating.position), Q.set(E.x, E.y, 0), Q.multiplyScalar(this.rotateSpeed * (this.reverseRotate ? -1 : 1)), this.rotateVelocity = Q.clone().multiplyScalar(1 / A);
      } else
        this.rotateVelocity.multiplyScalar(
          Math.exp(-A / this.rotateInertia)
        ), Q.addScaledVector(this.rotateVelocity, A);
      const C = new a.Euler().setFromQuaternion(
        I.quaternion,
        "YXZ"
      );
      if (C.y -= Q.x, C.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, C.x - Q.y)
      ), C.z *= Math.exp(-0 * A), I.quaternion.setFromEuler(C), this.sliding && !this.dualPress) {
        const E = this.sliding.position.clone().sub(this.sliding.last);
        this.sliding.last.copy(this.sliding.position);
        const t = this.sliding.button !== 2 ? new a.Vector3(E.x, 0, E.y) : new a.Vector3(E.x, -E.y, 0);
        t.multiplyScalar(this.slideSpeed * (this.reverseSlide ? -1 : 1)), t.applyQuaternion(I.quaternion), I.position.add(t), this.moveVelocity = t.clone().multiplyScalar(1 / A);
      } else
        this.moveVelocity.multiplyScalar(
          Math.exp(-A / this.moveInertia)
        ), I.position.addScaledVector(this.moveVelocity, A);
    }
    const B = this.scroll.multiplyScalar(this.scrollSpeed);
    B.set(B.x, B.z, B.y), this.reverseScroll && B.multiplyScalar(-1), B.applyQuaternion(I.quaternion), I.position.add(B), this.scroll.set(0, 0, 0);
  }
}
export {
  $o as FINGER_TIPS,
  Ir as ForgeControls,
  tI as ForgeRenderer,
  EI as ForgeViewpoint,
  xo as FpsMovement,
  HI as HANDS,
  Ut as Hand,
  gr as HandMovement,
  Yt as JOINT_IDS,
  Po as JOINT_INDEX,
  Vg as JOINT_RADIUS,
  wo as JOINT_SEGMENTS,
  Do as JOINT_SEGMENT_STEPS,
  _o as JOINT_TIPS,
  jI as JointEnum,
  Oo as NUM_JOINTS,
  ZA as PackedSplats,
  QI as PlyReader,
  Lo as PointerControls,
  II as Readback,
  es as Sint8ToFloat,
  NI as SplatAccumulator,
  BI as SplatEdit,
  Nn as SplatEditRgbaBlendMode,
  kn as SplatEditSdf,
  Gn as SplatEditSdfType,
  Fn as SplatEdits,
  rg as SplatFileType,
  nI as SplatGenerator,
  Zo as SplatLoader,
  Ag as SplatMesh,
  Jn as SplatModifier,
  vo as SplatSkinning,
  hg as SplatTransformer,
  Qo as SpzReader,
  jA as SpzWriter,
  ss as Uint8ToFloat,
  bI as VRButton,
  Ar as XrHands,
  Vo as constructAxes,
  Wo as constructGrid,
  To as constructSpherePoints,
  Ko as dyno,
  Rs as flipPixels,
  jg as floatToSint8,
  VA as floatToUint8,
  MA as fromHalf,
  jo as generators,
  Nt as getSplatFileType,
  zo as imageSplats,
  ks as isAndroid,
  ps as isMobile,
  Fs as isOculus,
  Js as pixelsToPngUrl,
  JI as setPackedSplat,
  Xo as textSplats,
  Eg as toHalf,
  qo as transcodeSpz,
  AI as unpackSplat,
  kt as unpackSplats,
  Ho as utils
};
